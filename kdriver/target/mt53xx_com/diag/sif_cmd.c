/*----------------------------------------------------------------------------*
 * Copyright Statement:                                                       *
 *                                                                            *
 *   This software/firmware and related documentation ("MediaTek Software")   *
 * are protected under international and related jurisdictions'copyright laws *
 * as unpublished works. The information contained herein is confidential and *
 * proprietary to MediaTek Inc. Without the prior written permission of       *
 * MediaTek Inc., any reproduction, modification, use or disclosure of        *
 * MediaTek Software, and information contained herein, in whole or in part,  *
 * shall be strictly prohibited.                                              *
 * MediaTek Inc. Copyright (C) 2010. All rights reserved.                     *
 *                                                                            *
 *   BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND     *
 * AGREES TO THE FOLLOWING:                                                   *
 *                                                                            *
 *   1)Any and all intellectual property rights (including without            *
 * limitation, patent, copyright, and trade secrets) in and to this           *
 * Software/firmware and related documentation ("MediaTek Software") shall    *
 * remain the exclusive property of MediaTek Inc. Any and all intellectual    *
 * property rights (including without limitation, patent, copyright, and      *
 * trade secrets) in and to any modifications and derivatives to MediaTek     *
 * Software, whoever made, shall also remain the exclusive property of        *
 * MediaTek Inc.  Nothing herein shall be construed as any transfer of any    *
 * title to any intellectual property right in MediaTek Software to Receiver. *
 *                                                                            *
 *   2)This MediaTek Software Receiver received from MediaTek Inc. and/or its *
 * representatives is provided to Receiver on an "AS IS" basis only.          *
 * MediaTek Inc. expressly disclaims all warranties, expressed or implied,    *
 * including but not limited to any implied warranties of merchantability,    *
 * non-infringement and fitness for a particular purpose and any warranties   *
 * arising out of course of performance, course of dealing or usage of trade. *
 * MediaTek Inc. does not provide any warranty whatsoever with respect to the *
 * software of any third party which may be used by, incorporated in, or      *
 * supplied with the MediaTek Software, and Receiver agrees to look only to   *
 * such third parties for any warranty claim relating thereto.  Receiver      *
 * expressly acknowledges that it is Receiver's sole responsibility to obtain *
 * from any third party all proper licenses contained in or delivered with    *
 * MediaTek Software.  MediaTek is not responsible for any MediaTek Software  *
 * releases made to Receiver's specifications or to conform to a particular   *
 * standard or open forum.                                                    *
 *                                                                            *
 *   3)Receiver further acknowledge that Receiver may, either presently       *
 * and/or in the future, instruct MediaTek Inc. to assist it in the           *
 * development and the implementation, in accordance with Receiver's designs, *
 * of certain softwares relating to Receiver's product(s) (the "Services").   *
 * Except as may be otherwise agreed to in writing, no warranties of any      *
 * kind, whether express or implied, are given by MediaTek Inc. with respect  *
 * to the Services provided, and the Services are provided on an "AS IS"      *
 * basis. Receiver further acknowledges that the Services may contain errors  *
 * that testing is important and it is solely responsible for fully testing   *
 * the Services and/or derivatives thereof before they are used, sublicensed  *
 * or distributed. Should there be any third party action brought against     *
 * MediaTek Inc. arising out of or relating to the Services, Receiver agree   *
 * to fully indemnify and hold MediaTek Inc. harmless.  If the parties        *
 * mutually agree to enter into or continue a business relationship or other  *
 * arrangement, the terms and conditions set forth herein shall remain        *
 * effective and, unless explicitly stated otherwise, shall prevail in the    *
 * event of a conflict in the terms in any agreements entered into between    *
 * the parties.                                                               *
 *                                                                            *
 *   4)Receiver's sole and exclusive remedy and MediaTek Inc.'s entire and    *
 * cumulative liability with respect to MediaTek Software released hereunder  *
 * will be, at MediaTek Inc.'s sole discretion, to replace or revise the      *
 * MediaTek Software at issue.                                                *
 *                                                                            *
 *   5)The transaction contemplated hereunder shall be construed in           *
 * accordance with the laws of Singapore, excluding its conflict of laws      *
 * principles.  Any disputes, controversies or claims arising thereof and     *
 * related thereto shall be settled via arbitration in Singapore, under the   *
 * then current rules of the International Chamber of Commerce (ICC).  The    *
 * arbitration shall be conducted in English. The awards of the arbitration   *
 * shall be final and binding upon both parties and shall be entered and      *
 * enforceable in any court of competent jurisdiction.                        *
 *---------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------
 *
 * $Author: p4admin $
 * $Date: 2015/01/15 $
 * $RCSfile: sif_cmd.c,v $
 * $Revision: #2 $
 *
 *---------------------------------------------------------------------------*/

/** @file sif_cmd.c
 *  SIF module CLI test function.
 */

//---------------------------------------------------------------------------
// Include files
//---------------------------------------------------------------------------
#include "eeprom_if.h"
#include "sif_if.h"
#include "sif_sw_drvif.h"

#include "sif_nptv_drvif.h"
#include "drvcust_if.h"

#ifdef __MW_CLI_DEF__
#include "x_mid_cli.h"
#else
#include "x_drv_cli.h"
#endif

#define DEFINE_IS_LOG      SIF_IsLog
#include "x_debug.h"
#include "x_util.h"
#include "x_hal_5381.h"

#include "x_os.h"
#include "x_printf.h"
#include "x_stl_lib.h"
#include "x_pinmux.h"
#include "x_assert.h"
#include "x_bim.h"
#include "x_serial.h"
#include "x_timer.h"

#include "drv_hdmi.h"
#include "hw_pdwnc.h"
#include "hw_hdmi.h"

#ifndef LINUX_EMU_SIFSW_SUPPORT
#define LINUX_EMU_SIFSW_SUPPORT
#endif

#ifdef CC_SOEM_BOARD
#include "panel.h"
#include "eeprom_if.h"
#endif
#ifdef CC_SUPPORT_TCON_FW_UPDATE
#include <linux/file_ops.h>
#include "util.h"
#endif

#ifdef CC_HDMI_2_0_HDCP_BIN
#include "hdcpkey_dec.h"
#endif

//---------------------------------------------------------------------------
// Configurations
//---------------------------------------------------------------------------
#define MT5391_IC_VERIFY_STAGE 1
#define SIF_SCL_STRETCH_VERIFY 0

//---------------------------------------------------------------------------
// Constant definitions
//---------------------------------------------------------------------------

#define SIF_BASE           BIM_BASE
#define SIF_REG_LENGTH      0

#define SIF_HDCP_SIZE  320
#define SIF_HDCP2X_SIZE 880
#ifdef HDCP_WithSerialNum
#define SIF_HDCPWithSerialNum_SIZE		340
#endif

// HDMI EDID 1 EERPOM GPIO pin configuration.
#ifndef SIF_EDID1_SDA
#define SIF_EDID1_SDA  (GPIO(210))
#endif
#ifndef SIF_EDID1_SCL
#define SIF_EDID1_SCL  (GPIO(211))
#endif

// HDMI EDID 2 EERPOM GPIO pin configuration.
#ifndef SIF_EDID2_SDA
#define SIF_EDID2_SDA  (GPIO(226))
#endif
#ifndef SIF_EDID2_SCL
#define SIF_EDID2_SCL  (GPIO(227))
#endif

// HDMI EDID 3 EERPOM GPIO pin configuration.
#ifdef CC_LGE_PROTO_PCBA
#ifndef SIF_EDID3_SDA
#define SIF_EDID3_SDA  (GPIO(226))
#endif
#ifndef SIF_EDID3_SCL
#define SIF_EDID3_SCL  (GPIO(227))
#endif
#else
#ifndef SIF_EDID3_SDA
#define SIF_EDID3_SDA  (GPIO(206))
#endif
#ifndef SIF_EDID3_SCL
#define SIF_EDID3_SCL  (GPIO(207))
#endif
#endif
#define SIF_EDID_SIZE  256

#define SIF_EEP_DEVICE_ADDR  0xA0

//---------------------------------------------------------------------------
// Type definitions
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Macro definitions
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Imported variables
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Imported functions
//---------------------------------------------------------------------------
#ifdef CC_Support_Sil9285
extern UINT8 vSiI9287EDIDWrite(UINT8*, UINT8*) ;
extern UINT8 vSiI9287EDIDread(UINT8, UINT8*);
extern UINT8 vSiI9287HDCPKSVread(UINT8*);
extern UINT8 bHDMISwitch5VStatus(UINT8);
extern UINT8 bHDMISwitchCLKStatus(UINT8);
extern UINT8 bHDMISwitchHDCPStatus(UINT8);
extern UINT8 bHDMISwitchHPDStatus(UINT8);
#endif
extern UINT8 u1MhlEdid[FLASH_MHL_2_0_EDID_SIZE];
//---------------------------------------------------------------------------
// Static function forward declarations
//---------------------------------------------------------------------------
static INT32 _SifSWWriteEeprom(UINT32 u4SDA, UINT32 u4SCL, UINT8* pu1Data);
static INT32 _SifSWReadCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifInitCmd(INT32 i4Argc, const CHAR** szArgv);

// General sif read/write function.
static INT32 _SifReadCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifWriteCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifWriteByteCmd(INT32 i4Argc, const CHAR** szArgv);
#ifdef CC_HDMI_2_0_HDCP_BIN
static INT32 _SifPROMWriteSramCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifPRAMWriteSramCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifHDCP1xWriteSramCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifHDCP2xWriteCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifInternalHDMI2EdidWriteSramCmd(INT32 i4Argc, const CHAR** szArgv);
#endif
static INT32 _SifInternalMHLEdidWriteSramCmd(INT32 i4Argc, const CHAR** szArgv);
// HDMI HDCP read/write function.
static INT32 _SifHDCPWriteSramCmd(INT32 i4Argc, const CHAR** szArgv);


/*
	function for miracast hdcp2.x key set:
*/
static INT32 mhdcp2x_key_eeprom(INT32 i4Argc, const CHAR** szArgv);
static INT32 mhdcp2x_key_test(INT32 i4Argc, const CHAR** szArgv);
static INT32 mhdcp2x_key_tz(INT32 i4Argc, const CHAR** szArgv);


#ifndef CC_VGA_EDID_DISABLE
static INT32 _SifVGAEdidWriteSramCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifVGAEdidReadSramCmd(INT32 i4Argc, const CHAR** szArgv);
#endif

#ifndef CC_HDMI_EDID_DISABLE
static INT32 _SifInternalEdidWriteSramCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifInternal3DEdidWriteSramCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifInternal4K2KEdidWriteSramCmd(INT32 i4Argc, const CHAR** szArgv);
#endif

static INT32 _SifHDCPReadCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifHDCPWriteByteCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifHDCPReadByteCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifHDCPWrAllByteCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifHDCPRdAllByteCmd(INT32 i4Argc, const CHAR** szArgv);

// HDMI EDID read/write function.
static INT32 _SifEDIDWriteCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifEDIDReadCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifEDID1WriteCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifEDID2WriteCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifEDID3WriteCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifEDID1ReadCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifEDID2ReadCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifEDID3ReadCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifHDMIReadEdidRam(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifEDIDWrAllByteCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifEDIDRdAllByteCmd(INT32 i4Argc, const CHAR** szArgv);

static INT32 _SifDiagCmd(INT32 i4Argc, const CHAR** szArgv);

static INT32 _SifTunerReadNoSubCmd(INT32 i4Argc, const CHAR**  szArgv);
static INT32 _SifTunerWriteNoSubCmd(INT32 i4Argc, const CHAR**  szArgv);
static INT32 _SifReadMultiCmd(INT32 i4Argc, const CHAR**  szArgv);
static INT32 _SifWriteMultiCmd(INT32 i4Argc, const CHAR**  szArgv);
static INT32 _SifRead_X_Cmd(INT32 i4Argc, const CHAR**  szArgv);
static INT32 _SifWrite_X_Cmd(INT32 i4Argc, const CHAR**  szArgv);

#if defined( CC_SUPPORT_4K2K)||defined(CC_SUPPORT_HDMI_4K2K30)
static INT32 _SifWrite_FRC_Cmd(INT32 i4Argc, const CHAR**  szArgv);
#endif

static INT32 _EDIDReadByteCmd(INT32 i4Argc, const CHAR** szArgv);

static INT32 _SifSWRead0Cmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifSWWrite0Cmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifSWWriteCmd(INT32 i4Argc, const CHAR** szArgv);

#if SIF_SCL_STRETCH_VERIFY
static INT32 _SifSCLStretchCmd(INT32 i4Argc, const CHAR** szArgv);
#endif

#ifdef CC_SUPPORT_TCON_FW_UPDATE
static INT32 _SifTconFWUpdate(INT32 i4Argc, const CHAR** szArgv);
#endif

static INT32 _SifSCLStretchStressCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifSCLStretchTestCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifSCLStretchEepromCmd(INT32 i4Argc, const CHAR** szArgv);

#ifdef LINUX_EMU_SIFSW_SUPPORT
//sifsw function
static INT32 _SifSWInitCmd(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifSWRead_X_Cmd(INT32 i4Argc, const CHAR**  szArgv);
static INT32 _SifSWWrite_X_Cmd(INT32 i4Argc, const CHAR**  szArgv);
#endif


#ifdef __KERNEL__
extern int _MTDRM_HDCP2_UseTestKey_InKernel_for_sif(int flag);
extern int _MTDRM_HDCP2_enable_tz_key(int flag);
#endif


#ifdef CUST_SOEM_DRV
static INT32 _SifWriteKeyHeader(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifReadKeyHeader(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifReadKey(INT32 i4Argc, const CHAR** szArgv);
static INT32 _SifWriteKey(INT32 i4Argc, const CHAR** szArgv);

#endif
//---------------------------------------------------------------------------
// Static variables
//---------------------------------------------------------------------------
static UINT8 _au1EEPBuf[SIF_HDCP_SIZE + 16] = { 0xff };

static const UINT8 _au1HDCP[SIF_HDCP_SIZE] =
{
    0x00 , 0x14 , 0x7c , 0xe6 , 0x2c , 0x37 , 0xf3 , 0xe8 , 0xa8 , 0x4d , 0x27 , 0x66 , 0xa8 , 0xd0 , 0x2f , 0x13,
    0x55 , 0x79 , 0x97 , 0xe7 , 0x87 , 0x37 , 0x18 , 0x04 , 0xd1 , 0x5f , 0x3b , 0x12 , 0x9f , 0x32 , 0xa4 , 0x6f,
    0x58 , 0x1c , 0x8a , 0xbc , 0x8c , 0x7f , 0xe3 , 0xcb , 0x81 , 0x9e , 0xb4 , 0x45 , 0x7c , 0x66 , 0x6a , 0xcc,
    0xdd , 0x5c , 0xc8 , 0x17 , 0xa3 , 0x90 , 0x43 , 0x91 , 0x8b , 0x01 , 0xf0 , 0x1d , 0xff , 0x8a , 0x1b , 0xde,
    0x94 , 0xd6 , 0xb6 , 0xf6 , 0x6d , 0x15 , 0x7b , 0x42 , 0x13 , 0xa2 , 0x1b , 0x04 , 0xb5 , 0xdd , 0x11 , 0xcc,
    0x42 , 0x28 , 0x66 , 0x65 , 0xf5 , 0x77 , 0xf1 , 0x65 , 0xc3 , 0x8c , 0x9b , 0x2c , 0xad , 0xb4 , 0xe9 , 0x7c,
    0xd1 , 0xbc , 0xd6 , 0x4a , 0x5d , 0xf7 , 0x45 , 0x3e , 0x2a , 0x22 , 0xec , 0xa8 , 0xdf , 0x68 , 0x54 , 0x57,
    0x5a , 0x10 , 0xc8 , 0x38 , 0x9f , 0x94 , 0xa0 , 0xa7 , 0xa0 , 0x71 , 0xa2 , 0x67 , 0x8e , 0x23 , 0xbd , 0x8d,
    0x63 , 0x89 , 0x0d , 0x01 , 0x91 , 0x97 , 0x4c , 0xba , 0x5c , 0x4d , 0x94 , 0x73 , 0x36 , 0x68 , 0x12 , 0x6c,
    0xe8 , 0xfa , 0xb1 , 0x51 , 0xc1 , 0x93 , 0xc6 , 0xce , 0x72 , 0x90 , 0xc1 , 0x6b , 0x4d , 0xf6 , 0x63 , 0x02,
    0xd3 , 0xa6 , 0x9b , 0x80 , 0x35 , 0xb6 , 0xa9 , 0xff , 0x8e , 0xfd , 0xd9 , 0x6f , 0x24 , 0xa6 , 0xdb , 0x4c,
    0xd2 , 0x0c , 0x0f , 0xcf , 0xcd , 0x1a , 0x19 , 0xe4 , 0x62 , 0x9c , 0x6d , 0x17 , 0x6b , 0x57 , 0x39 , 0xcb,
    0x6a , 0x0d , 0x80 , 0x75 , 0xfa , 0xf3 , 0x69 , 0x7d , 0x9f , 0x79 , 0xe3 , 0xc0 , 0x8b , 0x5a , 0xd2 , 0xa8,
    0xc9 , 0xd9 , 0x90 , 0x93 , 0xaa , 0xe6 , 0x1a , 0x1e , 0x17 , 0x93 , 0x03 , 0x2d , 0x43 , 0xc0 , 0xaf , 0x33,
    0x94 , 0x66 , 0xa9 , 0x18 , 0x55 , 0xcc , 0x22 , 0xf5 , 0x23 , 0xc8 , 0xc5 , 0x37 , 0xf1 , 0x81 , 0xd2 , 0x96,
    0xaf , 0x0a , 0x5a , 0xe5 , 0x8a , 0x13 , 0xef , 0x63 , 0x19 , 0x4c , 0xc6 , 0x3f , 0x6c , 0x9a , 0x7a , 0xb2,
    0xa6 , 0xd4 , 0x31 , 0x5a , 0x30 , 0x01 , 0x21 , 0xcd , 0xa2 , 0x86 , 0x74 , 0x04 , 0x46 , 0x3e , 0x38 , 0x08,
    0xe7 , 0x57 , 0xa7 , 0xb4 , 0x41 , 0x73 , 0x02 , 0x78 , 0x93 , 0x34 , 0x93 , 0xce , 0x93 , 0x5a , 0x46 , 0xd3,
    0x0a , 0x14 , 0xf7 , 0x61 , 0x03 , 0xb7 , 0x8f , 0x22 , 0xd2 , 0xf1 , 0x3a , 0x98 , 0xba , 0x28 , 0x62 , 0x53,
    0xca , 0x4c , 0x1d , 0x19 , 0xce , 0x49 , 0x87 , 0xf7 , 0xb5 , 0x26 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00
};

static UINT8 _au1EEPBuf2x[SIF_HDCP2X_SIZE + 16] = { 0xff };

static const UINT8 _au1HDCP2x_test_key[SIF_HDCP2X_SIZE] =
{
    0x7d, 0x10, 0xdc, 0x5e, 0xfe, 0x03, 0xb1, 0xfa, 0xbb, 0x34, 0xbb, 0xf6, 0x40, 0x40, 0x3d, 0xba,
    0xac, 0xd9, 0x16, 0x3a, 0x24, 0x6c, 0x82, 0x14, 0x2b, 0x3c, 0x51, 0xc5, 0x6b, 0x79, 0x74, 0xeb,
    0xde, 0x1c, 0x2e, 0x34, 0xef, 0xe3, 0x6b, 0x6e, 0x0f, 0x04, 0xf0, 0x54, 0x49, 0x9a, 0x07, 0x37,
    0x00, 0x85, 0x9d, 0x66, 0x7e, 0xe5, 0x15, 0x8f, 0x03, 0xd6, 0xbe, 0x19, 0xd6, 0xe3, 0x7c, 0x7a,
    0x41, 0x5d, 0xf5, 0x75, 0xed, 0x60, 0xcc, 0x28, 0xe3, 0x7a, 0xab, 0xd8, 0x48, 0x76, 0xbd, 0x1e,
    0x7d, 0x02, 0xcb, 0x8f, 0x2f, 0xa6, 0x4b, 0x08, 0x4b, 0xad, 0xa4, 0x53, 0x75, 0x3f, 0x0b, 0x29,
    0xfe, 0x04, 0x7c, 0xd0, 0x03, 0xd3, 0x7f, 0xfb, 0xf6, 0x90, 0x4d, 0x5e, 0x69, 0xbb, 0x46, 0x12,
    0x98, 0xa6, 0x3a, 0xb2, 0x56, 0x13, 0x2a, 0xd0, 0x3b, 0x35, 0x87, 0x25, 0x42, 0x08, 0xf7, 0xe3,
    0xfd, 0x09, 0x54, 0x13, 0x9a, 0xb2, 0x86, 0x7b, 0xfd, 0xfd, 0x4d, 0xf9, 0x75, 0x64, 0x78, 0x39,
    0x23, 0x7e, 0xab, 0x32, 0x96, 0x34, 0x92, 0xcf, 0x4e, 0x86, 0x48, 0x94, 0x0b, 0x2d, 0xb5, 0x28,
    0x3d, 0xe8, 0xb1, 0x89, 0x83, 0xf2, 0x86, 0xd5, 0x46, 0x94, 0xb4, 0xa4, 0x6f, 0x1f, 0x91, 0xf0,
    0xb5, 0xb9, 0x1a, 0x95, 0xc6, 0xb7, 0x1f, 0x0d, 0x52, 0x30, 0xdd, 0x33, 0x2a, 0x2a, 0x2d, 0xf5,
    0xa1, 0xe0, 0xe7, 0xcf, 0xad, 0xa8, 0x4c, 0x41, 0x8e, 0x0a, 0x9c, 0x56, 0xe0, 0xe4, 0x02, 0xa7,
    0xb4, 0xd3, 0x57, 0x3e, 0xe0, 0x50, 0xcf, 0x4c, 0x53, 0x0a, 0xf1, 0x29, 0x3d, 0x85, 0x81, 0x38,
    0xb6, 0x39, 0x65, 0xc4, 0x54, 0x78, 0x06, 0x25, 0xa6, 0x01, 0x58, 0xd9, 0x4b, 0x8f, 0x57, 0x58,
    0x01, 0x7a, 0x9e, 0x44, 0x4d, 0x07, 0x39, 0xea, 0x19, 0x37, 0xde, 0xe1, 0xb8, 0x51, 0xee, 0xc0,
    0xb9, 0x25, 0xa5, 0xcd, 0x73, 0x03, 0x1b, 0x38, 0x90, 0xeb, 0x36, 0x3c, 0x41, 0xf2, 0x93, 0xaf,
    0x30, 0x77, 0xe7, 0x2e, 0x5d, 0xae, 0xd8, 0x1c, 0x2e, 0x67, 0x75, 0x7a, 0xda, 0x15, 0x52, 0x77,
    0x7b, 0x5b, 0xa8, 0x15, 0xab, 0xc9, 0x1b, 0xc3, 0x64, 0xc9, 0xfc, 0x0e, 0x81, 0x5b, 0x01, 0xc8,
    0x52, 0xb6, 0x96, 0x8a, 0x2c, 0xb3, 0x63, 0xda, 0xbf, 0xf2, 0x06, 0x11, 0xfd, 0x75, 0x86, 0x29,
    0xc1, 0x83, 0x4c, 0x56, 0xee, 0xca, 0x5d, 0xf3, 0x39, 0xe4, 0x8a, 0x68, 0x10, 0xdd, 0xee, 0x5c,
    0xa4, 0x1d, 0xed, 0x14, 0xfd, 0x5a, 0x5d, 0x90, 0xe2, 0x02, 0x5a, 0xea, 0x4b, 0xe0, 0x5e, 0xf4,
    0x7e, 0x1e, 0x41, 0x75, 0x98, 0x05, 0x57, 0x69, 0x92, 0x4b, 0x90, 0x0b, 0xd2, 0x31, 0x25, 0xd6,
    0x1c, 0xa6, 0x51, 0x0f, 0x62, 0x95, 0xaf, 0x97, 0x9b, 0x81, 0xc8, 0xfe, 0xb6, 0x59, 0x73, 0xba,
    0xa5, 0xe5, 0xc0, 0xd9, 0xa9, 0x4e, 0xee, 0x96, 0x7c, 0x95, 0xd5, 0x91, 0xd0, 0xd0, 0x19, 0x65,
    0x84, 0x7b, 0x00, 0x67, 0xdf, 0x67, 0xa3, 0xa5, 0x46, 0xc1, 0x54, 0x92, 0x33, 0xb7, 0xfa, 0x31,
    0xee, 0x9d, 0x4e, 0x83, 0x00, 0xfd, 0xdb, 0xb4, 0x40, 0x74, 0x05, 0x30, 0x9e, 0xb8, 0x45, 0xfb,
    0xe0, 0x5e, 0x3b, 0x11, 0x7c, 0xf9, 0xd5, 0x63, 0xce, 0xd1, 0xd3, 0x2b, 0x41, 0x71, 0x5c, 0xd4,
    0x8d, 0x34, 0x4d, 0x8d, 0x5a, 0xa1, 0x21, 0x5e, 0xac, 0x98, 0xaf, 0x34, 0xf0, 0x33, 0xf1, 0xd0,
    0xc1, 0x20, 0x82, 0x59, 0x62, 0x00, 0xb7, 0xc1, 0x40, 0xf9, 0xd4, 0x5e, 0xfb, 0xfc, 0xde, 0x1e,
    0x01, 0xda, 0xe5, 0xe2, 0xd4, 0x13, 0x85, 0xd2, 0xd5, 0xbd, 0xa8, 0x19, 0x89, 0x13, 0xe4, 0xf2,
    0x6d, 0x2b, 0x01, 0xe9, 0xee, 0xcd, 0xf2, 0x91, 0xfe, 0xdd, 0xaa, 0x59, 0xa9, 0x91, 0xdf, 0x79,
    0x71, 0xc8, 0xd0, 0x43, 0x23, 0x4f, 0x92, 0x7e, 0x98, 0x4e, 0xd2, 0xc4, 0xca, 0x4e, 0xe5, 0x6e,
    0x13, 0xba, 0x42, 0x87, 0xf0, 0xa0, 0x32, 0x5c, 0x49, 0xfb, 0x6e, 0x3a, 0x8e, 0xf9, 0x2f, 0xa4,
    0x9d, 0x5a, 0x56, 0x7d, 0x65, 0x3d, 0x97, 0x3e, 0x15, 0xff, 0x89, 0x32, 0x26, 0xc8, 0xc4, 0x15,
    0x37, 0x1b, 0xd3, 0x26, 0x74, 0x70, 0x38, 0x13, 0xdb, 0xd7, 0x71, 0xd7, 0xdb, 0x29, 0xdb, 0xce,
    0x48, 0xa8, 0xd1, 0x31, 0x26, 0xfa, 0x5a, 0xea, 0x8d, 0xd5, 0xb8, 0xba, 0x0b, 0xd0, 0xa5, 0x0a,
    0x81, 0xa5, 0x77, 0xba, 0xe8, 0xc6, 0x07, 0x86, 0xee, 0x50, 0x2b, 0xca, 0x54, 0xa8, 0xda, 0x3b,
    0xd4, 0x3d, 0x9a, 0xd9, 0x49, 0x58, 0xdd, 0xcc, 0xcd, 0x4c, 0x20, 0x5a, 0x56, 0x68, 0x9a, 0xec,
    0x18, 0x1c, 0x8b, 0xc5, 0x45, 0xaa, 0xcb, 0x31, 0x4d, 0xd0, 0xb6, 0x2b, 0x0a, 0xc5, 0x8c, 0xb3,
    0xf0, 0x2b, 0x92, 0xd9, 0x8e, 0x4c, 0xa6, 0x23, 0xa5, 0xf0, 0x4b, 0x48, 0x0c, 0xe9, 0xa5, 0x2c,
    0x3a, 0xe8, 0x85, 0x9b, 0x98, 0xd1, 0x47, 0x82, 0x34, 0xf3, 0xc1, 0xd0, 0x84, 0x1e, 0x35, 0xfa,
    0x2c, 0x83, 0x3d, 0xe9, 0xab, 0x3f, 0xff, 0x9c, 0xff, 0x8f, 0x60, 0xf3, 0xf5, 0x97, 0x1a, 0x94,
    0x4f, 0xf6, 0x14, 0x14, 0xdd, 0x9d, 0x3f, 0x4d, 0x19, 0x26, 0xea, 0xa6, 0xb1, 0x0b, 0xea, 0x90,
    0x7c, 0x14, 0x97, 0x1c, 0xce, 0xb4, 0xc0, 0xa7, 0x20, 0x67, 0xbf, 0x45, 0x61, 0xff, 0x25, 0xa1,
    0x00, 0x49, 0x56, 0xc2, 0x01, 0xf3, 0xc6, 0xd6, 0xcf, 0x6b, 0xb4, 0x67, 0xee, 0xee, 0x0c, 0x67,
    0x60, 0xf8, 0xd5, 0xee, 0x28, 0x19, 0x47, 0x9a, 0x82, 0xcf, 0x02, 0xdd, 0xe0, 0x25, 0xef, 0x9c,
    0x8d, 0xaf, 0x92, 0xa9, 0xb5, 0x4d, 0x50, 0x17, 0xe4, 0xb2, 0xef, 0xc1, 0x28, 0x2f, 0x6f, 0x88,
    0x79, 0x72, 0xa2, 0x82, 0x4e, 0x12, 0xfe, 0xd0, 0x0b, 0x0b, 0xb5, 0x4f, 0xe4, 0xdd, 0x26, 0x56,
    0xfe, 0x99, 0xd1, 0xfb, 0x78, 0xce, 0x2f, 0xdf, 0xe6, 0x25, 0x9a, 0x04, 0x79, 0x49, 0x9c, 0xb8,
    0xdc, 0xd5, 0x3e, 0xc1, 0xd6, 0x1a, 0x6c, 0x40, 0xae, 0x15, 0x0c, 0x23, 0x92, 0x51, 0x3f, 0x1a,
    0x22, 0xd5, 0x80, 0xaf, 0xe9, 0xaf, 0x5b, 0x40, 0x4d, 0xc0, 0x3a, 0x81, 0x5e, 0x16, 0xa5, 0xfe,
    0xb7, 0x8f, 0x58, 0x14, 0x76, 0x76, 0xf6, 0x52, 0x2b, 0x57, 0xa9, 0x7a, 0x1f, 0x1a, 0x6e, 0x41,
    0xea, 0x97, 0xc8, 0x23, 0xda, 0x37, 0x64, 0x09, 0xde, 0xa0, 0x25, 0x43, 0x0f, 0x6d, 0x5a, 0x84,
    0x10, 0x41, 0xfe, 0xa7, 0xde, 0x2b, 0x0c, 0x07, 0x17, 0x95, 0xc6, 0x00, 0x50, 0xa3, 0x36, 0xe5
};

#if defined(CUST_SOEM_DRV) || defined(CC_MAPLE_CUST_DRV)

static const UINT8 _au1HDCP2x_production_key[SIF_HDCP2X_SIZE] =
{
		0x77, 0xca, 0x67, 0x79, 0x20, 0x0d, 0x0e, 0xd3, 0xe3, 0xed, 0xd9, 0xc8, 0x0b, 0x41, 0xd1, 0x9e,
		0xa6, 0x45, 0xb5, 0x18, 0x53, 0x77, 0x73, 0xdc, 0x85, 0x98, 0xef, 0x4f, 0x8a, 0x1d, 0xe9, 0x59,
		0xf0, 0x32, 0x90, 0x84, 0x8f, 0xee, 0x65, 0x91, 0x35, 0x3a, 0xc7, 0xde, 0x65, 0xaa, 0x20, 0x45,
		0xf4, 0x7a, 0x96, 0x94, 0xd8, 0x20, 0x56, 0xd4, 0xcf, 0xfa, 0x15, 0x7d, 0x1e, 0x02, 0xad, 0x34,
		0x9e, 0xeb, 0x4b, 0x82, 0x08, 0x10, 0x1c, 0x1f, 0x83, 0x05, 0xc7, 0x5f, 0x0a, 0xdc, 0x86, 0x23,
		0xfe, 0xc6, 0x2a, 0x8b, 0x08, 0x48, 0xab, 0x6a, 0x92, 0x34, 0x44, 0x45, 0x4b, 0x4c, 0xdd, 0xb2,
		0xf9, 0x4b, 0x4c, 0x9e, 0x0a, 0xdc, 0x9a, 0xaa, 0xe0, 0xda, 0x3e, 0x5f, 0xe4, 0x93, 0xfa, 0x50,
		0x72, 0xb5, 0xac, 0xae, 0x03, 0x96, 0x6e, 0x53, 0x60, 0xc4, 0xab, 0x26, 0x21, 0x08, 0x13, 0xce,
		0x41, 0xb7, 0x77, 0x8e, 0x18, 0x3d, 0x38, 0xde, 0x89, 0x20, 0xfb, 0xd1, 0x5e, 0x84, 0xd3, 0xd6,
		0x58, 0x43, 0xbd, 0x05, 0x53, 0x5b, 0xd2, 0x16, 0x0d, 0xaf, 0x46, 0x75, 0x5a, 0x8a, 0xbf, 0xa3,
		0x92, 0x7f, 0xf8, 0xf1, 0xba, 0x41, 0xf5, 0xbc, 0x6f, 0x00, 0xd8, 0xdd, 0x9c, 0x03, 0xfc, 0xa6,
		0xb5, 0x09, 0x6b, 0x3f, 0x8b, 0x73, 0xd5, 0xbd, 0xc4, 0xcf, 0x23, 0xf1, 0xa3, 0xca, 0x61, 0x4c,
		0x05, 0x4d, 0x4b, 0x67, 0x76, 0x48, 0xf4, 0x92, 0x6c, 0xbc, 0xf8, 0xda, 0xef, 0x7b, 0xd0, 0xf5,
		0x30, 0x3c, 0xe1, 0x9f, 0xd0, 0x41, 0x1f, 0x76, 0x4b, 0xab, 0xb8, 0xae, 0xf6, 0xae, 0xf5, 0x0f,
		0xcc, 0x63, 0x04, 0x46, 0xf4, 0xf0, 0x73, 0xe2, 0x42, 0x50, 0x94, 0x10, 0x5d, 0x83, 0x73, 0x69,
		0x28, 0x4a, 0x2a, 0x95, 0x25, 0x96, 0x3d, 0xeb, 0x85, 0x23, 0x67, 0x80, 0x4e, 0x79, 0x80, 0xcd,
		0x01, 0x39, 0x7d, 0x79, 0x47, 0x65, 0x4c, 0x7e, 0x39, 0x18, 0xee, 0x80, 0xfd, 0x2e, 0xc1, 0x84,
		0x98, 0x86, 0x92, 0xb1, 0xfd, 0xc4, 0x81, 0xd7, 0xfb, 0xbf, 0x87, 0x47, 0xf7, 0xa1, 0x7f, 0x75,
		0x86, 0xf9, 0x6c, 0x9f, 0x23, 0x39, 0xbe, 0x54, 0xfc, 0xff, 0xbe, 0x1c, 0x47, 0xa9, 0xbd, 0xfb,
		0x79, 0x95, 0x81, 0xcc, 0x59, 0x2a, 0x4a, 0xac, 0xea, 0x5b, 0x23, 0x7a, 0xbd, 0xad, 0x08, 0x3a,
		0x9a, 0x46, 0x8d, 0xaa, 0x99, 0x4b, 0xc8, 0x6f, 0x9c, 0xe7, 0xba, 0x72, 0x2d, 0x98, 0x1b, 0xb7,
		0x7b, 0xa1, 0xf3, 0x78, 0xc6, 0xa2, 0xa1, 0xe7, 0xb4, 0xdc, 0x32, 0x3a, 0xe2, 0xc3, 0x1c, 0xa5,
		0x08, 0xe3, 0x05, 0x29, 0xc3, 0xc0, 0x61, 0x7d, 0xf9, 0x56, 0xe9, 0x5c, 0xdb, 0xdd, 0x05, 0x85,
		0xba, 0x36, 0x81, 0x15, 0x31, 0xf3, 0x2f, 0x92, 0xf6, 0xab, 0x35, 0xa1, 0xa1, 0xda, 0xfc, 0xe0,
		0xc7, 0x1c, 0xc9, 0xed, 0xb2, 0xda, 0x6a, 0x29, 0x8c, 0xe8, 0xd9, 0x9c, 0x3d, 0x3b, 0x92, 0x52,
		0x48, 0xeb, 0xd5, 0x18, 0x89, 0xe3, 0x5d, 0xc5, 0x63, 0xc3, 0x18, 0xdd, 0xa8, 0x46, 0x75, 0xa2,
		0x0a, 0xe5, 0x61, 0x12, 0x93, 0x03, 0x8e, 0xfc, 0x50, 0x54, 0xdc, 0xe6, 0x02, 0xcf, 0x24, 0xbc,
		0xac, 0xca, 0xc8, 0x93, 0xe8, 0x37, 0x7c, 0x1a, 0x8d, 0x66, 0x30, 0xdc, 0x50, 0x60, 0xab, 0xb1,
		0x4c, 0xa8, 0x62, 0x2a, 0xde, 0x97, 0x6a, 0x58, 0x81, 0x4a, 0x38, 0xc3, 0x10, 0x22, 0x09, 0xc2,
		0xbd, 0x9a, 0xa0, 0xac, 0xda, 0x9d, 0xe0, 0x5d, 0x4a, 0x39, 0xb9, 0x43, 0xd8, 0x88, 0x28, 0x4a,
		0x16, 0x9c, 0x40, 0xc1, 0x54, 0x70, 0xc6, 0x50, 0x41, 0xd8, 0x4a, 0x9e, 0xb7, 0xef, 0xbd, 0x39,
		0x60, 0xd1, 0x9f, 0xa3, 0x31, 0x4d, 0x37, 0xd1, 0xaf, 0xce, 0x88, 0xed, 0x60, 0x66, 0xd7, 0x9c,
		0x05, 0x90, 0xf3, 0x2b, 0x35, 0x88, 0xef, 0xf3, 0xe3, 0x20, 0xba, 0x28, 0x7d, 0xe5, 0x1e, 0xca,
		0x42, 0xd8, 0x75, 0x0c, 0x0d, 0x13, 0xde, 0x85, 0x25, 0x8c, 0xe4, 0x82, 0x4c, 0x47, 0x63, 0x60,
		0x2e, 0x31, 0xcd, 0xac, 0x1c, 0xe5, 0xd9, 0x97, 0xa4, 0xb3, 0xf0, 0xec, 0x2a, 0x71, 0xcb, 0x03,
		0x55, 0xab, 0x81, 0x73, 0xe4, 0x5f, 0xc1, 0x3d, 0x92, 0xd1, 0x8e, 0x1e, 0xc3, 0x62, 0xb1, 0x84,
		0x01, 0x86, 0x80, 0x6a, 0xbe, 0xf4, 0x65, 0xb2, 0x25, 0x24, 0x20, 0x2a, 0x8e, 0x3e, 0xf8, 0x51,
		0x39, 0x8c, 0x75, 0x11, 0x82, 0xc8, 0xad, 0x69, 0x20, 0x46, 0x29, 0xcd, 0xc1, 0xcb, 0xad, 0xd1,
		0xf5, 0xc4, 0xd6, 0x5d, 0x59, 0xbb, 0x37, 0xb1, 0xa6, 0x96, 0xfa, 0xfc, 0x6f, 0xcb, 0xcd, 0x3f,
		0x49, 0x54, 0x0f, 0xb1, 0xc7, 0x3c, 0x55, 0x78, 0xdf, 0xae, 0x5f, 0x7a, 0x81, 0xe8, 0xb8, 0xc1,
		0x44, 0x84, 0xa8, 0x28, 0xde, 0x92, 0xd8, 0x6d, 0xb6, 0x34, 0xf9, 0x3e, 0xa1, 0xce, 0xf3, 0x76,
		0x08, 0x28, 0x5e, 0xda, 0x91, 0x4a, 0x0c, 0x48, 0x4c, 0x35, 0x6a, 0xf5, 0x06, 0x97, 0xed, 0x45,
		0xdd, 0x3c, 0x24, 0x71, 0x3f, 0x67, 0x1b, 0x21, 0xaf, 0x14, 0x24, 0x46, 0x8d, 0x99, 0xde, 0x18,
		0x73, 0x1b, 0x9f, 0x29, 0xcb, 0x3a, 0x73, 0xce, 0x6b, 0x35, 0x5d, 0x71, 0x8d, 0x45, 0x57, 0x0f,
		0x76, 0xc0, 0xa5, 0x60, 0x2a, 0x2f, 0x50, 0x0b, 0xbd, 0x1f, 0x17, 0x3a, 0xa2, 0x25, 0x58, 0xdb,
		0xb7, 0xc1, 0xa3, 0x9e, 0xcc, 0x19, 0x89, 0x00, 0x23, 0xfd, 0xbb, 0xa1, 0x11, 0x32, 0x03, 0x68,
		0x9b, 0xcf, 0xcc, 0x73, 0xaf, 0xf5, 0xe8, 0x48, 0x11, 0xd2, 0x87, 0xfc, 0xd2, 0x0e, 0xc1, 0x90,
		0x8d, 0x5d, 0x3d, 0xa5, 0xe4, 0x31, 0x4a, 0xb4, 0x28, 0xa7, 0x12, 0x36, 0xa1, 0x5b, 0xc0, 0x08,
		0xd0, 0xac, 0xed, 0x62, 0x61, 0xff, 0xfa, 0x13, 0xb8, 0x09, 0x9a, 0x58, 0x8d, 0xf7, 0x98, 0xc0,
		0x2a, 0x95, 0x27, 0xb6, 0x04, 0xda, 0xd8, 0x45, 0x0a, 0x50, 0x7f, 0x11, 0xd3, 0xd2, 0x73, 0xb1,
		0x93, 0x03, 0x4c, 0xc7, 0x0e, 0xbe, 0x15, 0x71, 0xb9, 0x12, 0x20, 0xc3, 0x8e, 0x69, 0x11, 0x71,
		0x93, 0x0c, 0x64, 0x45, 0x9d, 0xe4, 0xe6, 0xff, 0x84, 0x31, 0xe7, 0xd4, 0x5a, 0x61, 0x38, 0x28,
		0xa7, 0xd3, 0x61, 0x80, 0xf2, 0xda, 0x31, 0xb3, 0x13, 0x18, 0x5f, 0x6e, 0x00, 0xcd, 0x23, 0xf2,
		0xcf, 0x29, 0xc3, 0xcf, 0x96, 0xb6, 0xe4, 0xb7, 0x63, 0x19, 0x72, 0xfb, 0xb4, 0xdf, 0x61, 0xff,
		0xc9, 0x6f, 0xbc, 0xe7, 0xfd, 0xd0, 0x91, 0x09, 0xae, 0xfb, 0x53, 0x75, 0x95, 0xf4, 0x24, 0x8e,

};




#else
/*genearl mtk hdcp key*/

static const UINT8 _au1HDCP2x_production_key[SIF_HDCP2X_SIZE] =
{
    0xc6, 0x6a, 0x7c, 0x4c, 0xaa, 0xbd, 0x58, 0xcf, 0x69, 0x21, 0x52, 0xc2, 0x09, 0x83, 0x6c, 0xcc,
    0x44, 0x3f, 0xd3, 0x78, 0x90, 0x62, 0xb8, 0x1a, 0xee, 0x47, 0x5a, 0x25, 0x27, 0x1d, 0x87, 0xbc,
    0xf3, 0xe3, 0xf3, 0x70, 0x2e, 0xfe, 0x50, 0x93, 0x33, 0x9b, 0xf4, 0x56, 0x5e, 0x0e, 0xe3, 0x4e,
    0x3c, 0x8f, 0x3a, 0xe9, 0x64, 0xcb, 0xd7, 0xd8, 0x45, 0x56, 0x40, 0x20, 0x58, 0x00, 0x41, 0x6e,
    0x95, 0x70, 0x46, 0xa2, 0x41, 0xac, 0x7b, 0xb9, 0x2b, 0x38, 0x85, 0xf7, 0xd9, 0x1f, 0x0f, 0xb8,
    0x8f, 0xfb, 0xd4, 0x9e, 0xf6, 0xc2, 0x1a, 0xbb, 0xa9, 0x2d, 0x1a, 0x44, 0x2e, 0x5c, 0x0f, 0x30,
    0xeb, 0x77, 0x4a, 0x6e, 0x9e, 0x98, 0xd6, 0x43, 0x11, 0x08, 0xfe, 0xf2, 0xe7, 0x67, 0x42, 0x61,
    0x2d, 0xb3, 0x79, 0x4e, 0xd3, 0xed, 0xb5, 0xff, 0xc7, 0xca, 0x1d, 0x6f, 0xc3, 0xc9, 0xc2, 0xeb,
    0x9b, 0x8f, 0xd8, 0xd1, 0xf0, 0x80, 0x97, 0xdc, 0xe0, 0x65, 0xd1, 0x54, 0x32, 0x36, 0xd1, 0x0a,
    0xbc, 0xa1, 0x8b, 0x7d, 0xaf, 0x8e, 0x6c, 0xdc, 0x15, 0x1e, 0x9d, 0x4a, 0x24, 0xb2, 0xfa, 0xd2,
    0xfd, 0x90, 0x3a, 0xbb, 0xea, 0xeb, 0x1a, 0xf5, 0x5e, 0x0b, 0x61, 0x4a, 0x88, 0x7d, 0xc7, 0xde,
    0x43, 0x89, 0xc1, 0x28, 0x5b, 0x84, 0x96, 0x0c, 0x37, 0x4c, 0x32, 0x73, 0x9f, 0x8d, 0x61, 0xc8,
    0xe6, 0xa8, 0x5a, 0x47, 0xb8, 0x7b, 0x92, 0x53, 0x02, 0x0a, 0x69, 0x74, 0x85, 0x4e, 0x9a, 0x24,
    0xf2, 0x9e, 0xfd, 0x97, 0x01, 0xf0, 0xa8, 0xcd, 0xfc, 0x6d, 0xdb, 0x4a, 0x9d, 0x3e, 0xd5, 0x4e,
    0xa8, 0xc6, 0xb8, 0xc9, 0x96, 0x85, 0xe9, 0x14, 0x3b, 0x7a, 0xcc, 0xcc, 0x64, 0x1f, 0x26, 0x8a,
    0x92, 0x4e, 0xcb, 0x37, 0x74, 0x28, 0x78, 0xc8, 0x46, 0x65, 0x20, 0xaa, 0xe8, 0x30, 0x7a, 0x08,
    0x6e, 0xb2, 0x3d, 0xb0, 0x2c, 0x62, 0x5e, 0x15, 0x13, 0x64, 0xeb, 0x4a, 0x8d, 0xa9, 0x8f, 0x42,
    0xd8, 0xf3, 0xe0, 0x3f, 0x4c, 0x0a, 0xa1, 0xe2, 0x90, 0x9e, 0x95, 0x3c, 0x04, 0x91, 0xe0, 0x9b,
    0x51, 0xae, 0x6f, 0xa9, 0x19, 0x9e, 0x9d, 0x0a, 0x4e, 0xb0, 0x6f, 0xad, 0x39, 0x17, 0x8d, 0xc2,
    0x6d, 0xed, 0x61, 0x78, 0x0d, 0x41, 0xc3, 0x64, 0x7e, 0xf3, 0xbf, 0x7e, 0xda, 0xec, 0x3a, 0xa3,
    0xa7, 0x0a, 0x37, 0x2d, 0xe8, 0x35, 0x64, 0x3a, 0xf6, 0x5b, 0x0c, 0xe5, 0xd3, 0x6a, 0xc4, 0xce,
    0x41, 0x24, 0xd5, 0x11, 0x89, 0x66, 0x29, 0x64, 0x6b, 0x3e, 0x66, 0xb7, 0x7c, 0xa5, 0x9b, 0x2f,
    0x0f, 0x02, 0x0f, 0xe9, 0x6f, 0x99, 0x8b, 0xbc, 0x7f, 0x8e, 0xc6, 0xa1, 0xcc, 0x99, 0x2b, 0xac,
    0x32, 0x8b, 0xf4, 0x59, 0x91, 0x9a, 0x55, 0xd7, 0x6a, 0xf5, 0x00, 0xbf, 0x8d, 0x5d, 0x64, 0x5b,
    0x9c, 0x0c, 0xdb, 0xdc, 0x1a, 0x6b, 0xef, 0x08, 0x24, 0x6b, 0xb3, 0x25, 0xbd, 0xe2, 0x9d, 0xa1,
    0xee, 0x6d, 0xee, 0xa5, 0xb5, 0xdd, 0xa9, 0x5e, 0x2c, 0xa6, 0x5a, 0x7c, 0xcb, 0x63, 0xde, 0x19,
    0xcf, 0xdf, 0x45, 0x6f, 0x3d, 0x60, 0x73, 0x86, 0x22, 0xe8, 0x4c, 0x40, 0xfc, 0x62, 0x57, 0x6a,
    0x86, 0xf7, 0x64, 0x94, 0x5e, 0xcc, 0x6b, 0xdb, 0xf4, 0xbe, 0x5d, 0xcc, 0x9e, 0x39, 0xfe, 0x66,
    0x70, 0x27, 0x3e, 0x56, 0xd0, 0x8d, 0xb5, 0x1d, 0xc7, 0xa1, 0x46, 0xf8, 0xa0, 0x1b, 0x6f, 0x6b,
    0xd1, 0x2b, 0xc7, 0x47, 0xb3, 0xc6, 0x6f, 0x36, 0xc8, 0x52, 0x36, 0x38, 0x3c, 0xa7, 0xcd, 0x57,
    0xac, 0xe1, 0x9d, 0xee, 0x8b, 0xdb, 0x08, 0x93, 0x82, 0xfd, 0x7b, 0xd8, 0xcb, 0xcb, 0xa3, 0x7a,
    0x0c, 0x12, 0x47, 0x7c, 0x2d, 0xb7, 0x16, 0x07, 0x7b, 0xbb, 0xff, 0x2f, 0x7f, 0x01, 0xca, 0xc8,
    0x60, 0xa4, 0x0c, 0x3a, 0x61, 0x8d, 0x6b, 0x9f, 0xdd, 0xa7, 0xc8, 0xa6, 0xf5, 0x22, 0x68, 0xab,
    0x1f, 0xfb, 0xca, 0x7d, 0x01, 0x7f, 0xd0, 0x2c, 0x80, 0x6c, 0xf1, 0x70, 0xec, 0x76, 0x35, 0xcb,
    0x71, 0x80, 0x40, 0x76, 0x9c, 0xe9, 0x74, 0x6b, 0x91, 0xbd, 0xd9, 0x23, 0x81, 0xda, 0xd0, 0xe8,
    0x3c, 0xcf, 0x02, 0x5b, 0x34, 0x4d, 0xa7, 0x0c, 0x11, 0x0e, 0xad, 0xd7, 0x20, 0x7a, 0x56, 0x8e,
    0xe0, 0xcc, 0xbb, 0x80, 0xc7, 0xba, 0x9e, 0x8c, 0xb9, 0xa2, 0xce, 0x15, 0xe2, 0xae, 0x74, 0xc8,
    0x70, 0x9c, 0x31, 0x88, 0xc8, 0x9b, 0x06, 0x91, 0x8b, 0x79, 0x33, 0x58, 0x69, 0xbf, 0xd2, 0x3a,
    0x67, 0x26, 0x32, 0xa8, 0x47, 0xc0, 0x60, 0x96, 0x5b, 0x0f, 0xfa, 0xf6, 0x91, 0xe4, 0x42, 0xdf,
    0x8a, 0xce, 0x6a, 0xaa, 0xd6, 0x97, 0xee, 0xfc, 0x91, 0x8d, 0x0f, 0xd7, 0x71, 0x9a, 0xcf, 0xd6,
    0xd2, 0xd4, 0xf1, 0x77, 0x47, 0xc7, 0x3b, 0x94, 0x5a, 0x31, 0x71, 0xe4, 0x92, 0x6a, 0xea, 0x35,
    0x40, 0x29, 0x76, 0xaa, 0x49, 0x21, 0x9b, 0x2c, 0xa5, 0xc5, 0x69, 0x7f, 0x73, 0x1f, 0xbc, 0x99,
    0x83, 0xc7, 0xe2, 0xea, 0x84, 0x52, 0x1c, 0xb4, 0x96, 0x25, 0xcd, 0x43, 0xac, 0x81, 0xe5, 0x29,
    0x2e, 0x65, 0x86, 0x46, 0xc9, 0x0d, 0xf3, 0x1f, 0x18, 0x28, 0x0c, 0x53, 0x48, 0x3f, 0x49, 0x37,
    0x6f, 0x54, 0x84, 0x04, 0x69, 0x56, 0x1e, 0xe2, 0x2b, 0x77, 0x11, 0xe5, 0x5e, 0x77, 0xe9, 0xce,
    0xf8, 0xe3, 0xec, 0x6c, 0x54, 0xcb, 0x07, 0xde, 0x6d, 0x06, 0x06, 0x36, 0x4c, 0xd8, 0x77, 0x6c,
    0x2b, 0x83, 0x8d, 0xb8, 0x64, 0x06, 0x19, 0x9f, 0xcb, 0x40, 0xce, 0x31, 0xfb, 0xe7, 0xce, 0x67,
    0xd8, 0xa4, 0xfc, 0x8d, 0xb3, 0x0a, 0x29, 0x84, 0xf4, 0x5e, 0xdf, 0x4e, 0x80, 0xdf, 0x46, 0xbc,
    0xde, 0x03, 0x44, 0x30, 0xca, 0xe4, 0x28, 0xb4, 0x02, 0xf6, 0xce, 0x5e, 0xed, 0x22, 0x89, 0xe5,
    0x69, 0x87, 0xe8, 0x0d, 0x2d, 0x76, 0xcf, 0x82, 0x93, 0x33, 0x5f, 0x14, 0xef, 0xfb, 0x92, 0x1e,
    0x48, 0xf7, 0x7a, 0x65, 0x4c, 0x2d, 0x96, 0x49, 0x02, 0x26, 0xa3, 0x64, 0xfc, 0x03, 0x33, 0x94,
    0x3b, 0x6e, 0x28, 0x66, 0x83, 0x7b, 0xab, 0xe4, 0x68, 0x34, 0x1c, 0x23, 0x6f, 0x64, 0x27, 0x56,
    0x1a, 0xd9, 0x22, 0xbc, 0x7a, 0x33, 0xe9, 0x5b, 0x12, 0xd1, 0x81, 0x56, 0xcc, 0xe3, 0xde, 0xca,
    0xb7, 0x16, 0xe8, 0x5f, 0x00, 0xf4, 0xdf, 0x0b, 0xd4, 0x84, 0x06, 0x47, 0x7a, 0xfe, 0x3b, 0x6b,
    0xdc, 0x68, 0x41, 0x65, 0xdb, 0xf1, 0x49, 0x20, 0xff, 0x85, 0x9a, 0x1b, 0xde, 0xef, 0x5e, 0x76
};
#endif

#ifdef CC_LGE_PROTO_PCBA
static UINT8 _au1EDID_CEC_192k_DeepColor12B_P1[SIF_EDID_SIZE] =
{
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,  0x1E, 0x6D, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x19, 0x01, 0x03, 0x80, 0xA0, 0x5A, 0x78,  0x0A, 0xEE, 0x91, 0xA3, 0x54, 0x4C, 0x99, 0x26,
    0x0F, 0x50, 0x54, 0xA1, 0x08, 0x00, 0x31, 0x40,  0x45, 0x40, 0x61, 0x40, 0x71, 0x40, 0x81, 0x80,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A,  0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1E,  0x66, 0x21, 0x50, 0xB0, 0x51, 0x00, 0x1B, 0x30,
    0x40, 0x70, 0x36, 0x00, 0x40, 0x84, 0x63, 0x00,  0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x3A,
    0x3E, 0x1E, 0x53, 0x10, 0x00, 0x0A, 0x20, 0x20,  0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC,
    0x00, 0x4C, 0x47, 0x20, 0x54, 0x56, 0x0A, 0x20,  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xE6,

    0x02, 0x03, 0x23, 0xF1, 0x48, 0x90, 0x22, 0x20,  0x05, 0x04, 0x03, 0x02, 0x01, 0x29, 0x3D, 0x06,
    0xC0, 0x15, 0x07, 0x50, 0x09, 0x57, 0x07, 0x67,  0x03, 0x0C, 0x00, 0x10, 0x00, 0x80, 0x1E, 0xE3,
    0x05, 0x00, 0x00, 0x02, 0x3A, 0x80, 0x18, 0x71,  0x38, 0x2D, 0x40, 0x58, 0x2C, 0x45, 0x00, 0x40,
    0x84, 0x63, 0x00, 0x00, 0x1E, 0x01, 0x1D, 0x80,  0x18, 0x71, 0x1C, 0x16, 0x20, 0x58, 0x2C, 0x25,
    0x00, 0x40, 0x84, 0x63, 0x00, 0x00, 0x9E, 0x01,  0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E,
    0x28, 0x55, 0x00, 0x40, 0x84, 0x63, 0x00, 0x00,  0x1E, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 0x2D,
    0x10, 0x10, 0x3E, 0x96, 0x00, 0x40, 0x84, 0x63,  0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65
};
#else
static UINT8 _au1EDID_CEC_192k_DeepColor12B_P1[SIF_EDID_SIZE] =
{
    0x00, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0xFF, 0x00,   0x36, 0x8B, 0x01, 0x00,  0x01, 0x01, 0x01, 0x01,
    0x01, 0x0F, 0x01, 0x03,  0x80, 0x3C, 0x22, 0x78,   0x0A, 0x0D, 0xC9, 0xA0,  0x57, 0x47, 0x98, 0x27,
    0x12, 0x48, 0x4C, 0xBF,  0xEF, 0x00, 0x01, 0x01,   0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x1D,   0x00, 0x72, 0x51, 0xD0,  0x1E, 0x20, 0x6E, 0x28,
    0x55, 0x00, 0xC4, 0x8E,  0x21, 0x00, 0x00, 0x1E,   0x01, 0x1D, 0x80, 0x18,  0x71, 0x1C, 0x16, 0x20,
    0x58, 0x2C, 0x25, 0x00,  0xC4, 0x8E, 0x21, 0x00,   0x00, 0x9E, 0x00, 0x00,  0x00, 0xFC, 0x00, 0x4D,
    0x54, 0x4B, 0x20, 0x4C,  0x43, 0x44, 0x54, 0x56,   0x0A, 0x20, 0x20, 0x20,  0x00, 0x00, 0x00, 0xFD,
    0x00, 0x31, 0x4C, 0x0F,  0x50, 0x0E, 0x00, 0x0A,   0x20, 0x20, 0x20, 0x20,  0x20, 0x20, 0x01, 0x56,
    0x02, 0x03, 0x23, 0x74,  0x4B, 0x84, 0x10, 0x1F,   0x05, 0x13, 0x14, 0x01,  0x02, 0x11, 0x06, 0x15,
    0x26, 0x09, 0x7F, 0x03,  0x11, 0x7F, 0x18, 0x83,   0x01, 0x00, 0x00, 0x67,  0x03, 0x0C, 0x00, 0x10,
    0x00, 0xB8, 0x2D, 0x01,  0x1D, 0x00, 0xBC, 0x52,   0xD0, 0x1E, 0x20, 0xB8,  0x28, 0x55, 0x40, 0xC4,
    0x8E, 0x21, 0x00, 0x00,  0x1E, 0x01, 0x1D, 0x80,   0xD0, 0x72, 0x1C, 0x16,  0x20, 0x10, 0x2C, 0x25,
    0x80, 0xC4, 0x8E, 0x21,  0x00, 0x00, 0x9E, 0x8C,   0x0A, 0xD0, 0x8A, 0x20,  0xE0, 0x2D, 0x10, 0x10,
    0x3E, 0x96, 0x00, 0x13,  0x8E, 0x21, 0x00, 0x00,   0x18, 0x8C, 0x0A, 0xD0,  0x90, 0x20, 0x40, 0x31,
    0x20, 0x0C, 0x40, 0x55,  0x00, 0x13, 0x8E, 0x21,   0x00, 0x00, 0x18, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x52
};
#endif


static UINT8 _au1EDID_CEC_192k_DeepColor12B_P2[SIF_EDID_SIZE] =
{
    0x00, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0xFF, 0x00,   0x36, 0x8B, 0x01, 0x00,  0x01, 0x01, 0x01, 0x01,
    0x01, 0x0F, 0x01, 0x03,  0x80, 0x3C, 0x22, 0x78,   0x0A, 0x0D, 0xC9, 0xA0,  0x57, 0x47, 0x98, 0x27,
    0x12, 0x48, 0x4C, 0xBF,  0xEF, 0x00, 0x01, 0x01,   0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x1D,   0x00, 0x72, 0x51, 0xD0,  0x1E, 0x20, 0x6E, 0x28,
    0x55, 0x00, 0xC4, 0x8E,  0x21, 0x00, 0x00, 0x1E,   0x01, 0x1D, 0x80, 0x18,  0x71, 0x1C, 0x16, 0x20,
    0x58, 0x2C, 0x25, 0x00,  0xC4, 0x8E, 0x21, 0x00,   0x00, 0x9E, 0x00, 0x00,  0x00, 0xFC, 0x00, 0x4D,
    0x54, 0x4B, 0x20, 0x4C,  0x43, 0x44, 0x54, 0x56,   0x0A, 0x20, 0x20, 0x20,  0x00, 0x00, 0x00, 0xFD,
    0x00, 0x31, 0x4C, 0x0F,  0x50, 0x0E, 0x00, 0x0A,   0x20, 0x20, 0x20, 0x20,  0x20, 0x20, 0x01, 0x56,
    0x02, 0x03, 0x23, 0x74,  0x4B, 0x84, 0x10, 0x1F,   0x05, 0x13, 0x14, 0x01,  0x02, 0x11, 0x06, 0x15,
    0x26, 0x09, 0x7F, 0x03,  0x11, 0x7F, 0x18, 0x83,   0x01, 0x00, 0x00, 0x67,  0x03, 0x0C, 0x00, 0x20,
    0x00, 0xB8, 0x2D, 0x01,  0x1D, 0x00, 0xBC, 0x52,   0xD0, 0x1E, 0x20, 0xB8,  0x28, 0x55, 0x40, 0xC4,
    0x8E, 0x21, 0x00, 0x00,  0x1E, 0x01, 0x1D, 0x80,   0xD0, 0x72, 0x1C, 0x16,  0x20, 0x10, 0x2C, 0x25,
    0x80, 0xC4, 0x8E, 0x21,  0x00, 0x00, 0x9E, 0x8C,   0x0A, 0xD0, 0x8A, 0x20,  0xE0, 0x2D, 0x10, 0x10,
    0x3E, 0x96, 0x00, 0x13,  0x8E, 0x21, 0x00, 0x00,   0x18, 0x8C, 0x0A, 0xD0,  0x90, 0x20, 0x40, 0x31,
    0x20, 0x0C, 0x40, 0x55,  0x00, 0x13, 0x8E, 0x21,   0x00, 0x00, 0x18, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x42
};
#ifdef CC_LGE_PROTO_PCBA
static UINT8 _au1EDID_CEC_192k_DeepColor12B_P3[SIF_EDID_SIZE] =
{
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,  0x1E, 0x6D, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x19, 0x01, 0x03, 0x80, 0xA0, 0x5A, 0x78,  0x0A, 0xEE, 0x91, 0xA3, 0x54, 0x4C, 0x99, 0x26,
    0x0F, 0x50, 0x54, 0xA1, 0x08, 0x00, 0x31, 0x40,  0x45, 0x40, 0x61, 0x40, 0x71, 0x40, 0x81, 0x80,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A,  0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1E,  0x66, 0x21, 0x50, 0xB0, 0x51, 0x00, 0x1B, 0x30,
    0x40, 0x70, 0x36, 0x00, 0x40, 0x84, 0x63, 0x00,  0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x3A,
    0x3E, 0x1E, 0x53, 0x10, 0x00, 0x0A, 0x20, 0x20,  0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC,
    0x00, 0x4C, 0x47, 0x20, 0x54, 0x56, 0x0A, 0x20,  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xE6,

    0x02, 0x03, 0x23, 0xF1, 0x48, 0x90, 0x22, 0x20,  0x05, 0x04, 0x03, 0x02, 0x01, 0x29, 0x3D, 0x06,
    0xC0, 0x15, 0x07, 0x50, 0x09, 0x57, 0x07, 0x67,  0x03, 0x0C, 0x00, 0x20, 0x00, 0x80, 0x1E, 0xE3,
    0x05, 0x00, 0x00, 0x02, 0x3A, 0x80, 0x18, 0x71,  0x38, 0x2D, 0x40, 0x58, 0x2C, 0x45, 0x00, 0x40,
    0x84, 0x63, 0x00, 0x00, 0x1E, 0x01, 0x1D, 0x80,  0x18, 0x71, 0x1C, 0x16, 0x20, 0x58, 0x2C, 0x25,
    0x00, 0x40, 0x84, 0x63, 0x00, 0x00, 0x9E, 0x01,  0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E,
    0x28, 0x55, 0x00, 0x40, 0x84, 0x63, 0x00, 0x00,  0x1E, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 0x2D,
    0x10, 0x10, 0x3E, 0x96, 0x00, 0x40, 0x84, 0x63,  0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55
};
#else
static UINT8 _au1EDID_CEC_192k_DeepColor12B_P3[SIF_EDID_SIZE] =
{
    0x00, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0xFF, 0x00,   0x36, 0x8B, 0x01, 0x00,  0x01, 0x01, 0x01, 0x01,
    0x01, 0x0F, 0x01, 0x03,  0x80, 0x3C, 0x22, 0x78,   0x0A, 0x0D, 0xC9, 0xA0,  0x57, 0x47, 0x98, 0x27,
    0x12, 0x48, 0x4C, 0xBF,  0xEF, 0x00, 0x01, 0x01,   0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x1D,   0x00, 0x72, 0x51, 0xD0,  0x1E, 0x20, 0x6E, 0x28,
    0x55, 0x00, 0xC4, 0x8E,  0x21, 0x00, 0x00, 0x1E,   0x01, 0x1D, 0x80, 0x18,  0x71, 0x1C, 0x16, 0x20,
    0x58, 0x2C, 0x25, 0x00,  0xC4, 0x8E, 0x21, 0x00,   0x00, 0x9E, 0x00, 0x00,  0x00, 0xFC, 0x00, 0x4D,
    0x54, 0x4B, 0x20, 0x4C,  0x43, 0x44, 0x54, 0x56,   0x0A, 0x20, 0x20, 0x20,  0x00, 0x00, 0x00, 0xFD,
    0x00, 0x31, 0x4C, 0x0F,  0x50, 0x0E, 0x00, 0x0A,   0x20, 0x20, 0x20, 0x20,  0x20, 0x20, 0x01, 0x56,
    0x02, 0x03, 0x23, 0x74,  0x4B, 0x84, 0x10, 0x1F,   0x05, 0x13, 0x14, 0x01,  0x02, 0x11, 0x06, 0x15,
    0x26, 0x09, 0x7F, 0x03,  0x11, 0x7F, 0x18, 0x83,   0x01, 0x00, 0x00, 0x67,  0x03, 0x0C, 0x00, 0x30,
    0x00, 0xB8, 0x2D, 0x01,  0x1D, 0x00, 0xBC, 0x52,   0xD0, 0x1E, 0x20, 0xB8,  0x28, 0x55, 0x40, 0xC4,
    0x8E, 0x21, 0x00, 0x00,  0x1E, 0x01, 0x1D, 0x80,   0xD0, 0x72, 0x1C, 0x16,  0x20, 0x10, 0x2C, 0x25,
    0x80, 0xC4, 0x8E, 0x21,  0x00, 0x00, 0x9E, 0x8C,   0x0A, 0xD0, 0x8A, 0x20,  0xE0, 0x2D, 0x10, 0x10,
    0x3E, 0x96, 0x00, 0x13,  0x8E, 0x21, 0x00, 0x00,   0x18, 0x8C, 0x0A, 0xD0,  0x90, 0x20, 0x40, 0x31,
    0x20, 0x0C, 0x40, 0x55,  0x00, 0x13, 0x8E, 0x21,   0x00, 0x00, 0x18, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x32
};

#endif

#if defined(CC_MT5363P1V1)
static UINT8 _au1EDID_CEC_192k_DeepColor12B_P4[SIF_EDID_SIZE] =
{
    0x00, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0xFF, 0x00,   0x36, 0x8B, 0x01, 0x00,  0x01, 0x01, 0x01, 0x01,
    0x01, 0x0F, 0x01, 0x03,  0x80, 0x3C, 0x22, 0x78,   0x0A, 0x0D, 0xC9, 0xA0,  0x57, 0x47, 0x98, 0x27,
    0x12, 0x48, 0x4C, 0xBF,  0xEF, 0x00, 0x01, 0x01,   0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x1D,   0x00, 0x72, 0x51, 0xD0,  0x1E, 0x20, 0x6E, 0x28,
    0x55, 0x00, 0xC4, 0x8E,  0x21, 0x00, 0x00, 0x1E,   0x01, 0x1D, 0x80, 0x18,  0x71, 0x1C, 0x16, 0x20,
    0x58, 0x2C, 0x25, 0x00,  0xC4, 0x8E, 0x21, 0x00,   0x00, 0x9E, 0x00, 0x00,  0x00, 0xFC, 0x00, 0x4D,
    0x54, 0x4B, 0x20, 0x4C,  0x43, 0x44, 0x54, 0x56,   0x0A, 0x20, 0x20, 0x20,  0x00, 0x00, 0x00, 0xFD,
    0x00, 0x31, 0x4C, 0x0F,  0x50, 0x0E, 0x00, 0x0A,   0x20, 0x20, 0x20, 0x20,  0x20, 0x20, 0x01, 0x56,
    0x02, 0x03, 0x23, 0x74,  0x4B, 0x84, 0x10, 0x1F,   0x05, 0x13, 0x14, 0x01,  0x02, 0x11, 0x06, 0x15,
    0x26, 0x09, 0x7F, 0x03,  0x11, 0x7F, 0x18, 0x83,   0x01, 0x00, 0x00, 0x67,  0x03, 0x0C, 0x00, 0x40,
    0x00, 0xB8, 0x2D, 0x01,  0x1D, 0x00, 0xBC, 0x52,   0xD0, 0x1E, 0x20, 0xB8,  0x28, 0x55, 0x40, 0xC4,
    0x8E, 0x21, 0x00, 0x00,  0x1E, 0x01, 0x1D, 0x80,   0xD0, 0x72, 0x1C, 0x16,  0x20, 0x10, 0x2C, 0x25,
    0x80, 0xC4, 0x8E, 0x21,  0x00, 0x00, 0x9E, 0x8C,   0x0A, 0xD0, 0x8A, 0x20,  0xE0, 0x2D, 0x10, 0x10,
    0x3E, 0x96, 0x00, 0x13,  0x8E, 0x21, 0x00, 0x00,   0x18, 0x8C, 0x0A, 0xD0,  0x90, 0x20, 0x40, 0x31,
    0x20, 0x0C, 0x40, 0x55,  0x00, 0x13, 0x8E, 0x21,   0x00, 0x00, 0x18, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x22
};
#endif

/* Declare the debug on/off/level and RegTest functions */
CLIMOD_DEBUG_FUNCTIONS(SIF)
/* End of Declare */

static INT32 _Sif_Monitor_Cmd(INT32 i4Argc, const CHAR** szArgv)
{
    char* pstr;
    INT32 i4PinNum, i4PinFunc, i4Ret, i4PinGrp, i4PinOldFunc;

    if (i4Argc < 2)
    {
        Printf("Arg: [Option=ps,...] [Option Parameter]\n");
        return 0;
    }

    pstr = (char*)szArgv[1] ;

    if ( x_strcmp(pstr, "ps") == 0 )
    {
        if ( i4Argc == 2 )
        {
            Printf("... ps gpio#   pin_func \n");
            return -1;
        }
        else if ( i4Argc == 3 ) //sif.m ps xxx
        {
            i4PinNum = StrToInt( szArgv[2] );
            i4PinFunc = BSP_PinGpioGet( i4PinNum , (UINT32*)&i4PinGrp );
            Printf("Gpio %d 's pin_func= %d\n", i4PinNum, i4PinFunc );
        }
        else    //sif.m ps xxx func
        {
            i4PinNum = StrToInt( szArgv[2] );
            i4PinFunc = StrToInt( szArgv[3] );
            i4PinOldFunc = BSP_PinGpioGet( i4PinNum , (UINT32*)&i4PinGrp ) ;
            i4Ret = BSP_PinSet(i4PinGrp, i4PinFunc);
            Printf("Gpio %d 's old pin_func %d -->set to %d %s\n", i4PinNum, i4PinOldFunc , i4PinFunc, i4Ret == 0 ? "OK" : "Fail" );
        }
    }

    return 0;
}

static INT32 _SifScan(INT32 i4Argc, const CHAR**  szArgv)
{
    UINT8 u1Data[128];
    INT32   i4Ret, i4Index;
    UINT8 u1BusId;

    SIF_Init();

    Printf("Scan SIF device(s) on all buses...\n");
    for (u1BusId = 0; u1BusId < SIF_BUS_MAX; u1BusId++)
    {
        switch (u1BusId)
        {
            case SIF_BUS_SYSTEM_I2C:
                Printf("\rSystem BUS:                                      \n");
                break;
            case SIF_BUS_TUNER_I2C:
                Printf("\rTuner BUS:                                      \n");
                break;
            case SIF_BUS_SECOND_I2C:
                Printf("\rSecond BUS:                                      \n");
                break;
            case SIF_BUS_PDWNC_I2C:
                Printf("\rPdwnc BUS0:                                      \n");
                break;
            case SIF_BUS_PDWNC_I2C_1:
                Printf("\rPdwnc BUS1:                                      \n");
                break;
            case SIF_BUS_8295B_I2C_0:
                Printf("\r8295B BUS0:                                      \n");
                break;
            case SIF_BUS_8295B_I2C_1:
                Printf("\r8295B BUS1:                                      \n");
                break;
            default:
                Printf("\rBUS %d:                                      \n", u1BusId);
                break;
        }

        for (i4Index = 0x00;  i4Index <= 0xFF ; i4Index += 2)
        {
            Printf("\rScan (read) device addr 0x%02X", i4Index );
            //        i4Ret = SIF_TunerReadNoSubAddr(0x100, i4Index, u1Data, 1);
            i4Ret = SIF_X_Read(u1BusId , 0x100, i4Index, 0 , 0 , u1Data, 1);
            if ( i4Ret > 0 )
            {
                Printf("\rFound readable device at addr 0x%02X\n", i4Index);
            }
        };
        Printf("\r                                           \n");
    }

    Printf("\rDone.                                      \n");
    return 0;
}

#ifdef CC_Support_Sil9285
UINT8 NVRAMboottable[64] =
{
    0xAA, 0x55, 0x04, 0x1F, 0x0F, 0x00, 0x00, 0xFF, 0xFF, 0xFF,  0x9D, 0xFF, 0x10, 0x00, 0x20, 0x00,
    0x30, 0x00, 0x40, 0x00, 0x50, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0x38, 0x28, 0x18, 0x08,
    0xF8, 0x00, 0x00, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00,
    0x00, 0x00, 0x00, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00
};

UINT8 NVRAMtable[256] =
{
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x4D, 0xD9, 0x01, 0xEA, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x14, 0x01, 0x03, 0x80, 0xA0, 0x5A, 0x78, 0x0A, 0x83, 0xAD, 0xA2, 0x56, 0x49, 0x9B, 0x25,
    0x0F, 0x47, 0x4A, 0x21, 0x08, 0x00, 0x81, 0x80, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1E, 0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20,
    0x6E, 0x28, 0x55, 0x00, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x3A,
    0x3E, 0x0F, 0x46, 0x0F, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC,
    0x00, 0x53, 0x4F, 0x4E, 0x59, 0x20, 0x54, 0x56, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x5F,
    0x02, 0x03, 0x20, 0x70, 0x49, 0x10, 0x04, 0x05, 0x03, 0x02, 0x07, 0x06, 0x20, 0x01, 0x26, 0x09,
    0x07, 0x07, 0x15, 0x07, 0x50, 0x83, 0x01, 0x00, 0x00, 0x66, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x80,
    0x01, 0x1D, 0x80, 0x18, 0x71, 0x1C, 0x16, 0x20, 0x58, 0x2C, 0x25, 0x00, 0x40, 0x84, 0x63, 0x00,
    0x00, 0x9E, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0x40, 0x84,
    0x63, 0x00, 0x00, 0x18, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00,
    0xB0, 0x84, 0x43, 0x00, 0x00, 0x18, 0x8C, 0x0A, 0xA0, 0x14, 0x51, 0xF0, 0x16, 0x00, 0x26, 0x7C,
    0x43, 0x00, 0xB0, 0x84, 0x43, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38
};

extern UINT8 _bHDMI9287switchstopflag;
static INT32 _SifHDMISwitchI2CCtrl(INT32 i4Argc, const CHAR**  szArgv)
{
    if (i4Argc != 2)
    {
        Printf("Usage: %s 1 is stop/ 0 is resume\n", szArgv[0]);
        return 0;
    }
    _bHDMI9287switchstopflag = (UINT8)StrToInt(szArgv[1]);
    if (_bHDMI9287switchstopflag)
    {
        Printf("Stop HDMI 9287 I2C access\n");
    }
    else
    {
        Printf("Resume HDMI 9287 I2C access\n");
    }
    return 0;
}

static INT32 _SifHDMI9287SwitchEDIDRead(INT32 i4Argc, const CHAR**  szArgv)
{
    UINT32 ret;
    UINT8 bEDID[256];
    if (i4Argc != 2)
    {
        Printf("Usage: %s  is port ,port 5 is NVRAMboottable and port 6 is NVRAMtable\n", szArgv[0]);
        return 0;
    }
    ret = vSiI9287EDIDread((UINT8)StrToInt(szArgv[1]) , bEDID);
    if (ret)
    {
        Printf(" HDMI 9287 I2C EDID read OK\n");

    }
    else
    {
        Printf(" HDMI 9287 I2C EDID read fail\n");
    }
    return 0;
}

static INT32 _SifHDMI9287SwitchKSVRead(INT32 i4Argc, const CHAR**  szArgv)
{
    UINT8 ret;
    UINT8 bKSV[5];
    ret = vSiI9287HDCPKSVread(bKSV);
    if (ret)
    {
        Printf(" HDMI 9287 I2C KSV read OK\n");
    }
    else
    {
        Printf(" HDMI 9287 I2C KSV read fail\n");
    }
    return 0;
}

static INT32 _SifHDMI9287SwitchEDIDWrite(INT32 i4Argc, const CHAR**  szArgv)
{
    UINT8 ret;

    ret = vSiI9287EDIDWrite(NVRAMboottable, NVRAMtable);
    if (ret)
    {
        Printf(" HDMI 9287 I2C EDID write success \n");
    }
    else
    {
        Printf(" HDMI 9287 I2C EDID write fail\n");
    }
    return 0;
}

static INT32 _SifHDMISwitchPWRStatus(INT32 i4Argc, const CHAR**  szArgv)
{

    if (i4Argc != 2)
    {
        Printf("Usage: %s port \n", szArgv[0]);
        return 0;
    }
    Printf("HDMI 9287 port %s PWR5V = %d", szArgv[1], bHDMISwitch5VStatus((UINT8)StrToInt(szArgv[1])));
    return 0;
}

static INT32 _SifHDMISwitchCLKStatus(INT32 i4Argc, const CHAR**  szArgv)
{

    if (i4Argc != 2)
    {
        Printf("Usage: %s port \n", szArgv[0]);
        return 0;
    }
    Printf("HDMI 9287 port %s CLK status = %d", szArgv[1], bHDMISwitchCLKStatus((UINT8)StrToInt(szArgv[1])));
    return 0;
}

static INT32 _SifHDMI9287SwitchHDCPStatusRead(INT32 i4Argc, const CHAR**  szArgv)
{
    UINT8 ret;
    ret = bHDMISwitchHDCPStatus(1);
    Printf(" HDMI 9287 I2C HDCP status =%x\n", ret);
    return 0;
}

static INT32 _SifHDMISwitchHPDStatus(INT32 i4Argc, const CHAR**  szArgv)
{

    if (i4Argc != 2)
    {
        Printf("Usage: %s port \n", szArgv[0]);
        return 0;
    }
    Printf("HDMI 9287 port %s HPD status = %d", szArgv[1], bHDMISwitchHPDStatus((UINT8)StrToInt(szArgv[1])));
    return 0;
}
#endif

static CLI_EXEC_T _arSifCmdTbl [] =
{
#if !defined(CLI_STRESS_MODE) && !defined(DRV_CLI_DISABLE)
    // General sif diagnostic function.
    { "init", "i", _SifInitCmd, NULL, "Sif init", CLI_GUEST },
    { "diag", NULL, _SifDiagCmd, NULL, "Sif diagnostic", CLI_SUPERVISOR },

    // General sif read/write function.
    { "read", "r", _SifReadCmd, NULL, "Sif read", CLI_GUEST },
    { "write", "w", _SifWriteCmd, NULL, "Sif write", CLI_SUPERVISOR },
    { "writebyte", "wb", _SifWriteByteCmd, NULL, "Sif write byte", CLI_GUEST },
    { "softread", "sr", _SifSWReadCmd, NULL, "Sif S/W Read", CLI_SUPERVISOR },
    { "softwrite", "sw", _SifSWWriteCmd, NULL, "Sif S/W Write", CLI_SUPERVISOR },

    { "softread(0-SubAddr)", "sr0", _SifSWRead0Cmd, NULL, "Sif S/W Read(0-SubAddr)", CLI_SUPERVISOR },
    { "softwrite(0-SubAddr)", "sw0", _SifSWWrite0Cmd, NULL, "Sif S/W Write(0-SubAddr)", CLI_SUPERVISOR },
    #ifdef CC_HDMI_2_0_HDCP_BIN
	{ "prom", NULL, _SifPROMWriteSramCmd, NULL, "Sif write PROM SRAM default value", CLI_GUEST },
	{ "pram", NULL, _SifPRAMWriteSramCmd, NULL, "Sif write PRAM SRAM default value", CLI_GUEST },
	{ "hdcp1x", NULL, _SifHDCP1xWriteSramCmd, NULL, "Sif write PRAM SRAM default value", CLI_GUEST },
	{ "hdcp2x", NULL, _SifHDCP2xWriteCmd, NULL, "Sif wirte HDCP2x rx key value", CLI_GUEST },
	#endif
    // HDMI HDCP read/write function.
    { "hdcp", NULL, _SifHDCPWriteSramCmd, NULL, "Sif write HDCP SRAM default value", CLI_GUEST },

	/*write miracast hdcp2.x key */
    { "mhdcp2x_key_eeprom", NULL, mhdcp2x_key_eeprom, NULL, "write wfd hdcp2.x key into eeprom", CLI_GUEST },
    { "mhdcp2x_key_tz", NULL, mhdcp2x_key_tz, NULL, "use wfd hdcp2.x key in tz", CLI_GUEST },
    { "mhdcp2x_key_test", NULL, mhdcp2x_key_test, NULL, "config wfd hdcp2.x key type", CLI_GUEST },
    
#ifndef CC_VGA_EDID_DISABLE
    { "vgaedid", NULL, _SifVGAEdidWriteSramCmd, NULL, "Sif write Vga edid and read to SRAM default value", CLI_GUEST },
    { "rvgaedid", "rvgae", _SifVGAEdidReadSramCmd, NULL, "Sif read vga edid from SRAM", CLI_GUEST},
#endif

#ifndef CC_HDMI_EDID_DISABLE
    { "internaledid", NULL, _SifInternalEdidWriteSramCmd, NULL, "Sif write built-in HDMI edid and set to internal SRAM", CLI_GUEST },
    { "edid3D", NULL, _SifInternal3DEdidWriteSramCmd, NULL, "Sif write built-in HDMI 3D edid and set to internal SRAM", CLI_GUEST },
    { "edid4k2k", NULL, _SifInternal4K2KEdidWriteSramCmd, NULL, "Sif write built-in HDMI 4K2K edid and set to internal SRAM", CLI_GUEST },
    #ifdef CC_HDMI_2_0_HDCP_BIN
    { "edid2", NULL, _SifInternalHDMI2EdidWriteSramCmd, NULL, "Sif write built-in HDMI 4K2K edid and set to internal SRAM", CLI_GUEST },
    #endif
    { "edidmhl", NULL, _SifInternalMHLEdidWriteSramCmd, NULL, "Sif write built-in HDMI 4K2K edid and set to internal SRAM", CLI_GUEST },
#endif

    { "rhdcp", NULL, _SifHDCPReadCmd, NULL, "Sif read HDCP", CLI_GUEST },
    { "wbhdcp", NULL, _SifHDCPWriteByteCmd, NULL, "Sif write byte to HDCP", CLI_GUEST },
    { "rbhdcp", NULL, _SifHDCPReadByteCmd, NULL, "Sif read byte from HDCP", CLI_GUEST },
#endif /* !defined(CLI_STRESS_MODE) && !defined(DRV_CLI_DISABLE) */
    { "wallhdcp", "wah", _SifHDCPWrAllByteCmd, NULL, "Sif write all 320 bytes to HDCP", CLI_SUPERVISOR },
    { "rallhdcp", "rah", _SifHDCPRdAllByteCmd, NULL, "Sif read all 320 bytes from HDCP", CLI_SUPERVISOR },
#if !defined(CLI_STRESS_MODE) && !defined(DRV_CLI_DISABLE)
    // HDMI EDID read/write function.
    { "edid", NULL, _SifEDIDWriteCmd, NULL, "Sif write EDID default value", CLI_GUEST },
    { "redid", NULL, _SifEDIDReadCmd, NULL, "Sif read EDID", CLI_GUEST },
    { "edid1", NULL, _SifEDID1WriteCmd, NULL, "Sif write EDID port 1 default value", CLI_GUEST },
    { "edid2", NULL, _SifEDID2WriteCmd, NULL, "Sif write EDID port 2 default value", CLI_GUEST },
    { "edid3", NULL, _SifEDID3WriteCmd, NULL, "Sif write EDID port 3 default value", CLI_GUEST },
    { "redid1", NULL, _SifEDID1ReadCmd, NULL, "Sif read EDID port 1", CLI_GUEST },
    { "redid2", NULL, _SifEDID2ReadCmd, NULL, "Sif read EDID port 2", CLI_GUEST },
    { "redid3", NULL, _SifEDID3ReadCmd, NULL, "Sif read EDID port 3", CLI_GUEST },
#endif /* !defined(CLI_STRESS_MODE) && !defined(DRV_CLI_DISABLE) */
    {"EDID RAM", "redidram", _SifHDMIReadEdidRam, NULL, "READ EDID RAM", CLI_GUEST},
    { "walledid", "wae", _SifEDIDWrAllByteCmd, NULL, "Sif write all 256 bytes to EDID", CLI_SUPERVISOR },
    { "ralledid", "rae", _SifEDIDRdAllByteCmd, NULL, "Sif read all 256 bytes from EDID", CLI_SUPERVISOR },
#if !defined(CLI_STRESS_MODE) && !defined(DRV_CLI_DISABLE)
    //TUNER I2C Function
    { "tunerread", "tr", _SifTunerReadNoSubCmd, NULL, "Tuner I2C No-sub-addr read", CLI_GUEST },
    { "tunerwrite", "tw", _SifTunerWriteNoSubCmd, NULL, "Tuner I2C No-sub-addr write", CLI_GUEST },

    //Multiple-sub-addr read /write
    { "multipleread", "mr", _SifReadMultiCmd, NULL, "Multiple sub-addr I2C read", CLI_GUEST },
    { "multiplewrite", "mw", _SifWriteMultiCmd, NULL, "Multiple sub-addr I2C write", CLI_GUEST },

    //scan bus functions
    { "scan", "s", _SifScan, NULL, "Scan all SIF Buses", CLI_GUEST },
#ifdef CC_Support_Sil9285
    { "swstop", "sws", _SifHDMISwitchI2CCtrl, NULL, "Silicon image 9287 switch I2C access 1 is stop / 0 is resume", CLI_GUEST },
    { "swedidr", "swedidr", _SifHDMI9287SwitchEDIDRead, NULL, "Silicon image 9287 switch EDID read", CLI_GUEST },
    { "swedidw", "swedidw", _SifHDMI9287SwitchEDIDWrite, NULL, "Silicon image 9287 switch EDID write", CLI_GUEST },
    { "swksvr", "swksvr", _SifHDMI9287SwitchKSVRead, NULL, "Silicon image 9287 switch KSV read", CLI_GUEST },
    { "sw5vr", "sw5vr", _SifHDMISwitchPWRStatus, NULL, "Silicon image 9287 switch 5V status  read", CLI_GUEST },
    { "swclkr", "swclkr", _SifHDMISwitchCLKStatus, NULL, "Silicon image 9287 switch clock status  read", CLI_GUEST },
    { "swhdcpr", "swhdcpr", _SifHDMI9287SwitchHDCPStatusRead, NULL, "Silicon image 9287 switch hdcp status  read", CLI_GUEST },
    { "swhpdr", "swhpdr", _SifHDMISwitchHPDStatus, NULL, "Silicon image 9287 switch HPD status  read", CLI_GUEST },
#endif
    //sif_x read write
    { "sif_x_read", "xr", _SifRead_X_Cmd, NULL, "fully functional sif read", CLI_GUEST },
    { "sif_x_write", "xw", _SifWrite_X_Cmd, NULL, "fully functional sif write", CLI_GUEST },
#if defined( CC_SUPPORT_4K2K)||defined(CC_SUPPORT_HDMI_4K2K30)
    { "sif_frc write", "frcw", _SifWrite_FRC_Cmd, NULL, "FRC sif write", CLI_GUEST },
#endif

    { "scltest", "sclst", _SifSCLStretchTestCmd, NULL, "SCL test", CLI_GUEST },

    { "sclstress", "sclstress", _SifSCLStretchStressCmd, NULL, "SCL stress test", CLI_GUEST },
    { "scleeprom", "scleep", _SifSCLStretchEepromCmd, NULL, "SCL test via EEPROM access", CLI_GUEST },

    //edid read byte
    { "edidreadbyte", "edidrb", _EDIDReadByteCmd, NULL, "edid read byte", CLI_SUPERVISOR },
    { "monitor", "m", _Sif_Monitor_Cmd, NULL, "Montor CLI", CLI_SUPERVISOR },
#if SIF_SCL_STRETCH_VERIFY
    { "SCLstretchtest", "sclst", _SifSCLStretchCmd, NULL, "SCL_STRETCH Test", CLI_GUEST },
#endif
#ifdef CC_SUPPORT_TCON_FW_UPDATE
    { "TconFWUpdate", "tfwut", _SifTconFWUpdate, NULL, "Tcon FW update", CLI_GUEST },
#endif

#ifdef LINUX_EMU_SIFSW_SUPPORT
    //sifsw
    { "swinit", "swi", _SifSWInitCmd, NULL, "SifSW init", CLI_GUEST },
    { "sifsw_x_read", "swxr", _SifSWRead_X_Cmd, NULL, "fully functional sifsw read", CLI_GUEST },
    { "sifsw_x_write", "swxw", _SifSWWrite_X_Cmd, NULL, "fully functional sifsw write", CLI_GUEST },
#endif

#endif /* !defined(CLI_STRESS_MODE) && !defined(DRV_CLI_DISABLE) */

#ifdef CUST_SOEM_DRV
	{ "keyheader", "kh", _SifWriteKeyHeader, NULL, "write key header", CLI_GUEST },
	{ "rkeyheader", "rkh", _SifReadKeyHeader, NULL, "read key header", CLI_GUEST },
	{ "setkey", "sk", _SifWriteKey, NULL, "write key ", CLI_GUEST },
	{ "getkey", "gk", _SifReadKey, NULL, "read key ", CLI_GUEST },	
#endif
    // Register test.
    CLIMOD_DEBUG_CLIENTRY(SIF),

    { NULL, NULL, NULL, NULL, NULL, CLI_SUPERVISOR }
};


CLI_MAIN_COMMAND_ITEM(Sif)
{
    "sif", NULL, NULL, _arSifCmdTbl, "Sif command", CLI_GUEST
};

//---------------------------------------------------------------------------
// Static functions
//---------------------------------------------------------------------------
extern UINT32 FlashPanel_GetHdmiEdidIndex(void);

static INT32 _SifInitCmd(INT32 i4Argc, const CHAR** szArgv)
{
    UNUSED(i4Argc);

    UNUSED(szArgv);

    SIF_Init();
#ifndef MT5391_IC_VERIFY_STAGE
    // initail HDCP SRAM.
    if (EEPHDCP_Init() != 0)
    {
        Printf("HDCP Init failed\n");
    }
#endif
    Printf("SIF_Init OK!\n");

    return 0;
}

static INT32 _SifDiagCmd(INT32 i4Argc, const CHAR** szArgv)
{
#ifdef __MODEL_slt__
    return _SIF_Diag();
#else
    _SIF_Diag();

    return 0;
#endif
}

//-------------------------------------------------------------------------
/** _SifReadCmd
 *  SIF CLI read function.
 *  @param  i4Argc              user's CLI input length.
 *  @param  szArgv              user's CLI input string.
 *  @retval  1  SUCCESS.
 *  @retval  0  FAIL.
 */
//-------------------------------------------------------------------------
static INT32 _SifReadCmd(INT32 i4Argc, const CHAR** szArgv)
{
    UINT8 u1Dev;

    UINT32 u4Idx;
    UINT32 u4ClkDiv;
    UINT32 u4Addr;
    UINT32 u4Count;
    UINT8* pu1Buf;
    UINT8* pu2Buf;
    UINT32 u4ReturnValue;

    if (i4Argc < 5)
    {
        Printf("Arg: u4ClkDiv u1Dev u4Addr u4Count\n");
        return 0;
    }

    u4ClkDiv = StrToInt(szArgv[1]);
    u1Dev = (UINT8)StrToInt(szArgv[2]);
    u4Addr = StrToInt(szArgv[3]);
    u4Count = StrToInt(szArgv[4]);
    pu1Buf = (UINT8*)x_mem_alloc(u4Count);
    if (pu1Buf == NULL)
    {
        return -1;
    }
    x_memset((VOID*)pu1Buf, 0, u4Count);

    pu2Buf = pu1Buf;

    while (u4Count > 0)
    {
        u4ReturnValue = SIF_Read(u4ClkDiv, u1Dev, u4Addr, pu1Buf, u4Count);

        Printf("u1Dev=0x%X, u4Addr=0x%X, u4Count=%d, u4ReturnValue=%d.\n",
               u1Dev,
               u4Addr,
               u4Count,
               u4ReturnValue);

        if (u4ReturnValue > 0)
        {
            // print sif read data content.
            for (u4Idx = 0; u4Idx < u4ReturnValue; u4Idx ++)
            {
                if (!(u4Idx % 8))
                {
                    Printf("\n0x%08X :", u4Idx);
                }

                Printf(" 0x%02X,", pu1Buf[u4Idx]);
            }
            Printf("\n");

            if (((u4ReturnValue + u4Addr) % 256) == 0)
            {
                u1Dev += 2;
                u4Addr = 0;
            }
            else
            {
                u4Addr += u4ReturnValue;
            }

            u4Count -= u4ReturnValue;

            pu1Buf += u4ReturnValue;
        }
        else
        {
            // fail.
            Printf("sif read fail.\n");
            u4Count = 0;
        }
    }

    x_mem_free((VOID*)pu2Buf);

    return 0;
}

//-------------------------------------------------------------------------
/** _SifSWReadCmd
 *  SIF CLI SW IIC read function.
 *  @param  i4Argc              user's CLI input length.
 *  @param  szArgv              user's CLI input string.
 *  @retval  1  SUCCESS.
 *  @retval  0  FAIL.
 */
//-------------------------------------------------------------------------
static INT32 _SifSWReadCmd(INT32 i4Argc, const CHAR** szArgv)
{
    UINT32 u4Dev;
    UINT32 u4SDA;
    UINT32 u4SCL;

    UINT32 u4Idx;
    UINT32 u4Addr;
    UINT32 u4Count;
    UINT32 u4Count1;
    UINT8* pu1Buf;
    UINT8* pu2Buf;
    UINT32 u4ReturnValue;

    if (i4Argc < 6)
    {
        Printf("Arg: SDA_pin SCL_pin u1Dev u4Addr u4Count.\n");
        return 0;
    }

    u4SDA = StrToInt(szArgv[1]);
    u4SCL = StrToInt(szArgv[2]);
    u4Dev = (UINT8)StrToInt(szArgv[3]);
    u4Addr = StrToInt(szArgv[4]);
    u4Count = StrToInt(szArgv[5]);
    pu1Buf = (UINT8*)x_mem_alloc(u4Count + 8);
    if (pu1Buf == NULL)
    {
        return -1;
    }
    x_memset((VOID*)pu1Buf, 0, u4Count + 8);

    // initial SIF sda, scl pin.
    SIFSW_Init(u4SDA, u4SCL);

    pu2Buf = pu1Buf;

    while (u4Count > 0)
    {
        u4Count1 = (u4Count > 256) ? 256 : u4Count;
        u4ReturnValue = SIFSW_ReadData((UINT8)u4Dev, (UINT8)u4Addr, (UINT16)u4Count1, pu1Buf, 0xFFU);

        Printf("u4Dev=0x%X, u4Addr=0x%X, u4Count=%d, u4ReturnValue=%d.\n",
               u4Dev,
               u4Addr,
               u4Count1,
               u4ReturnValue);

        if (!u4ReturnValue)
        {
            Printf("Read error !\n");
            x_mem_free((VOID*)pu2Buf);
            SIFSW_Remove();
            return 0;
        }

        if (u4Count1 > 0)
        {
            for (u4Idx = 0; u4Idx < u4Count1; u4Idx += 8)
            {
                Printf(
                    "0x%08X : 0x%02X 0x%02X 0x%02X 0x%02X, 0x%02X 0x%02X 0x%02X 0x%02X.\n",
                    u4Idx,
                    pu1Buf[u4Idx],
                    pu1Buf[u4Idx + 1],
                    pu1Buf[u4Idx + 2],
                    pu1Buf[u4Idx + 3],
                    pu1Buf[u4Idx + 4],
                    pu1Buf[u4Idx + 5],
                    pu1Buf[u4Idx + 6],
                    pu1Buf[u4Idx + 7]);
            }
        }

        if (((u4Count1 + u4Addr) % 256) == 0)
        {
            u4Dev += 2;
            u4Addr = 0;
        }
        else
        {
            u4Addr += u4Count1;
        }
        u4Count -= u4Count1;

        pu1Buf += u4Count1;
    }

    x_mem_free((VOID*)pu2Buf);
    SIFSW_Remove();
    return 0;
}
//-------------------------------------------------------------------------
/** _SifWriteCmd
 *  SIF CLI write function.
 *  @param  i4Argc              user's CLI input length.
 *  @param  szArgv              user's CLI input string.
 *  @retval  1  SUCCESS.
 *  @retval  0  FAIL.
 */
//-------------------------------------------------------------------------
static INT32 _SifWriteCmd(INT32 i4Argc, const CHAR** szArgv)
{
    UINT8 u1Dev;

    UINT32 u4ClkDiv;
    UINT32 u4Addr;
    UINT32 u4Count;
    UINT32 u4ReturnValue;
    UINT32 u4Memptr;

    if (i4Argc < 6)
    {
        Printf("Arg: u4ClkDiv u1Dev u4Addr u4Memptr u4Count.\n");
        return 0;
    }

    u4ClkDiv = StrToInt(szArgv[1]);
    u1Dev = (UINT8)StrToInt(szArgv[2]);
    u4Addr = StrToInt(szArgv[3]);
    u4Memptr = StrToInt(szArgv[4]);
    u4Count = StrToInt(szArgv[5]);

    u4ReturnValue = SIF_Write(u4ClkDiv, u1Dev, u4Addr, (UINT8*)u4Memptr, u4Count);

    if (u4ReturnValue == 0xFF)
    {
        Printf("write fail.\n");
    }
    else
    {
        Printf("write successfully! byte count = %d\n", u4ReturnValue);
    }

    return 0;
}

EXTERN INT32 SIF_SCLHIGH(void)  ;
EXTERN void SIF_SCLLOW(void);
EXTERN void SIFSW_Init(UINT32 u4SDA, UINT32 u4SCL);

UINT16 _SifSwFreq2Delay(UINT16 u2Freq)
{
    UINT16  u2Delay;
    u2Delay = ((1000 / u2Freq - 10) / 2);
    return u2Delay;
}

static INT32 _SifSWRead0Cmd(INT32 i4Argc, const CHAR** szArgv)
{
    return 0;
}

static INT32 _SifSWWrite0Cmd(INT32 i4Argc, const CHAR** szArgv)
{
    return 0;
}
static INT32 _SifSWWriteCmd(INT32 i4Argc, const CHAR** szArgv)
{
    return 0;
}

//-------------------------------------------------------------------------
/** _SifWriteByteCmd
 *  SIF CLI write byte function.
 *  @param  i4Argc              user's CLI input length.
 *  @param  szArgv              user's CLI input string.
 *  @retval  1  SUCCESS.
 *  @retval  0  FAIL.
 */
//-------------------------------------------------------------------------
static INT32 _SifWriteByteCmd(INT32 i4Argc, const CHAR** szArgv)
{
    UINT8 u1Dev;

    UINT32 u4ClkDiv;
    UINT32 u4Addr;
    UINT32 u4ReturnValue;
    UINT8 u1ByteValue;

    if (i4Argc < 5)
    {
        Printf("Arg: u4ClkDiv u1Dev u4Addr u1ByteValue.\n");
        return 0;
    }

    u4ClkDiv = StrToInt(szArgv[1]);
    u1Dev = (UINT8)StrToInt(szArgv[2]);
    u4Addr = StrToInt(szArgv[3]);
    u1ByteValue = (UINT8)(StrToInt(szArgv[4]) & 0xFF);

    u4ReturnValue = SIF_Write(u4ClkDiv, u1Dev, u4Addr, (UINT8*)&u1ByteValue, 1);

    if (u4ReturnValue == 0xFF)
    {
        Printf("write fail.\n");
    }
    else
    {
        Printf("write successfully! byte count = %d\n", u4ReturnValue);
    }
    return 0;
}

#ifndef CC_VGA_EDID_DISABLE
#define SIF_VGAEDID_SIZE 256
extern void vVGA_INTERNAL_EDID_Init(void);
extern CODE UINT8 VGA_EDID_TABLE[256];

static INT32 _InternalVgaEdidRead(void)
{
    INT32 fgSet;
    INT32 i;
    UINT8 u1Checksum = 0;
    UINT8 u1Buf = 0;

    fgSet = EEPVGAEDID_Read(0, (UINT32)_au1EEPBuf, SIF_VGAEDID_SIZE);
    if (fgSet)
    {
        Printf("read  back fail.\n");
        return 0;
    }

    for (i = 0; i < SIF_VGAEDID_SIZE; i += 16)
    {
        Printf("0x%04X : %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X.\n",
               i,
               _au1EEPBuf[i],
               _au1EEPBuf[i + 1],
               _au1EEPBuf[i + 2],
               _au1EEPBuf[i + 3],
               _au1EEPBuf[i + 4],
               _au1EEPBuf[i + 5],
               _au1EEPBuf[i + 6],
               _au1EEPBuf[i + 7],
               _au1EEPBuf[i + 8],
               _au1EEPBuf[i + 9],
               _au1EEPBuf[i + 10],
               _au1EEPBuf[i + 11],
               _au1EEPBuf[i + 12],
               _au1EEPBuf[i + 13],
               _au1EEPBuf[i + 14],
               _au1EEPBuf[i + 15]
              );
    }

    // checksum
    u1Buf = 0;
    for (i = 0; i < 127; i++)
    {
        u1Buf += _au1EEPBuf[i];
    }

    u1Checksum = 0x100 - u1Buf;
    if (u1Checksum == _au1EEPBuf[127])
    {
        Printf("Block0 checksum ok: 0x%02X \n", u1Checksum);
    }
    else
    {
        Printf("Block0 checksum ERR: 0x%02X \n", u1Checksum);
    }


    return 0;
}

//-------------------------------------------------------------------------
/** _SifVGAEdidWriteSramCmd
 *  SIF CLI write VGA Edid in system EEPROM/nand function.
 *  @param  i4Argc              user's CLI input length.
 *  @param  szArgv              user's CLI input string.
 *  @retval  1  SUCCESS.
 *  @retval  0  FAIL.
 */
//-------------------------------------------------------------------------
static INT32 _SifVGAEdidWriteSramCmd(INT32 i4Argc, const CHAR** szArgv)
{
    //adam , wait for eeproom ready
    INT32 fgSet;
    INT32 i;
    fgSet = EEPVGAEDID_Write(0, (UINT32)VGA_EDID_TABLE, SIF_VGAEDID_SIZE);
    if (fgSet)
    {
        Printf("EEPHDCP_Write fail.\n");
        return 0;
    }

    fgSet = EEPVGAEDID_Read(0, (UINT32)_au1EEPBuf, SIF_VGAEDID_SIZE);
    if (fgSet)
    {
        Printf("read eeprom back fail.\n");
        return 0;
    }

    for (i = 0; i < SIF_VGAEDID_SIZE; i++)
    {
        if (VGA_EDID_TABLE[i] != _au1EEPBuf[i])
        {
            Printf("write fail !\n");
            return 0;
        }
    }

    Printf("write successfully !\n");

    vVGA_INTERNAL_EDID_Init();

    return 0;
}
//-------------------------------------------------------------------------
/** _SifVGAEdidReadSramCmd
 *  SIF CLI read VGA Edid located in sram function.
 *  @param  i4Argc              user's CLI input length.
 *  @param  szArgv              user's CLI input string.
 *  @retval  1  SUCCESS.
 *  @retval  0  FAIL.
 */
//-------------------------------------------------------------------------
static INT32 _SifVGAEdidReadSramCmd(INT32 i4Argc, const CHAR** szArgv)
{
    UINT32 i, j;
    UINT32 u4Tmp;
    UINT8* pu1Tmp;

    Printf("eeprom/flash dump\n");
    _InternalVgaEdidRead();

    Printf("Internal sram dump\n");
    pu1Tmp = (UINT8*)&u4Tmp;
    vIO32WriteFldAlign(PDWNC_VGA_ADDR, 0, FLD_VGA_ADDR) ; //start from 0 and auto increase
    //VGA EDID dowload
    for (i = 0; i < 64 / 4; i++)
    {
        Printf("%04X |", i * 16);
        for (j = 0; j < 4; j++)
        {
            u4Tmp = IO32ReadFldAlign(PDWNC_VGA_DATA, FLD_VGA_DATA);
            Printf("%02X %02X %02X %02X ", pu1Tmp[0], pu1Tmp[1], pu1Tmp[2], pu1Tmp[3]);
        }
        Printf("\n");
    }
    return 0;
}
#endif

#ifndef CC_HDMI_EDID_DISABLE
#define SIF_HDMIEDID_SIZE 256
extern void vHDMI_INTERNAL_EDID_Init(void);
extern UINT8 HDMIEDID_CEC_192k_DeepColor12B_P0[256];
static INT32 _InternalEdidWriteSram(void)
{
    INT32 fgSet;
    INT32 i;
#if defined(CC_SOEM_BOARD)
	UINT64 u8Offset;
	UINT8 idx = 0;
	idx = (UINT8 )FlashPanel_GetHdmiEdidIndex();
	if(idx < 1)
	{
		idx = 1 ;
	}
	idx--; 
	Printf("\nHdmi edid idx %d\n", idx);
	if((idx+1)*HDMI_EDID_SIZE > HDMI_EDID_STORAGE_SIZE)
    {
        u8Offset = 0;
    }
    else
    {
        u8Offset = idx*HDMI_EDID_SIZE;
    }
	fgSet = EEPHDMIEDID_Write(u8Offset, (UINT32)HDMIEDID_CEC_192k_DeepColor12B_P0, SIF_HDMIEDID_SIZE);
    if (fgSet)
    {
        Printf("EDID_Write fail.\n");
        return 0;
    }
	fgSet = EEPHDMIEDID_Read(u8Offset, (UINT32)_au1EEPBuf, SIF_HDMIEDID_SIZE);
#else
    fgSet = EEPHDMIEDID_Write(0, (UINT32)HDMIEDID_CEC_192k_DeepColor12B_P0, SIF_HDMIEDID_SIZE);
    if (fgSet)
    {
        Printf("EDID_Write fail.\n");
        return 0;
    }

    fgSet = EEPHDMIEDID_Read(0, (UINT32)_au1EEPBuf, SIF_HDMIEDID_SIZE);
    if (fgSet)
    {
        Printf("read eeprom back fail.\n");
        return 0;
    }
#endif
    for (i = 0; i < SIF_HDMIEDID_SIZE; i++)
    {
        if (HDMIEDID_CEC_192k_DeepColor12B_P0[i] != _au1EEPBuf[i])
        {
            Printf("write fail !\n");
            return 0;
        }
    }

    Printf("write successfully !\n");

    vHDMI_INTERNAL_EDID_Init();

    return 0;
}

extern UINT8 HDMIEDID_3D_CEC_192k_DeepColor12B_P0[256];
static INT32 _Internal3DEdidWriteSram(void)
{
    INT32 fgSet;
    INT32 i;
    fgSet = EEPHDMIEDID_Write(0, (UINT32)HDMIEDID_3D_CEC_192k_DeepColor12B_P0, SIF_HDMIEDID_SIZE);
    if (fgSet)
    {
        Printf("EEPHDCP_Write fail.\n");
        return 0;
    }

    fgSet = EEPHDMIEDID_Read(0, (UINT32)_au1EEPBuf, SIF_HDMIEDID_SIZE);
    if (fgSet)
    {
        Printf("read eeprom back fail.\n");
        return 0;
    }

    for (i = 0; i < SIF_HDMIEDID_SIZE; i++)
    {
        if (HDMIEDID_3D_CEC_192k_DeepColor12B_P0[i] != _au1EEPBuf[i])
        {
            Printf("write fail !\n");
            return 0;
        }
    }

    Printf("write successfully !\n");

    vHDMI_INTERNAL_EDID_Init();

    return 0;
}

extern UINT8 HDMIEDID_4K2K_P0[256];
static INT32 _Internal4K2KEdidWriteSram(void)
{
    INT32 fgSet;
    INT32 i;
#if defined(CC_SOEM_BOARD)
		UINT64 u8Offset;
		UINT8 idx = 0;
		idx = (UINT8 )FlashPanel_GetHdmiEdidIndex();
		if(idx < 1)
		{
			idx = 1 ;
		}
		idx--; 
		Printf("\nHdmi edid idx %d\n", idx);
		if((idx+1)*HDMI_EDID_SIZE > HDMI_EDID_STORAGE_SIZE)
		{
			u8Offset = 0;
		}
		else
		{
			u8Offset = idx*HDMI_EDID_SIZE;
		}
		fgSet = EEPHDMIEDID_Write(u8Offset, (UINT32)HDMIEDID_CEC_192k_DeepColor12B_P0, SIF_HDMIEDID_SIZE);
		if (fgSet)
		{
			Printf("4k2kEDID_Write fail.\n");
			return 0;
		}
		fgSet = EEPHDMIEDID_Read(u8Offset, (UINT32)_au1EEPBuf, SIF_HDMIEDID_SIZE);
#else

    fgSet = EEPHDMIEDID_Write(0, (UINT32)HDMIEDID_4K2K_P0, SIF_HDMIEDID_SIZE);
    if (fgSet)
    {
        Printf("4k2kEDID_Write fail.\n");
        return 0;
    }

    fgSet = EEPHDMIEDID_Read(0, (UINT32)_au1EEPBuf, SIF_HDMIEDID_SIZE);
#endif
    if (fgSet)
    {
        Printf("read eeprom back fail.\n");
        return 0;
    }

    for (i = 0; i < SIF_HDMIEDID_SIZE; i++)
    {
        if (HDMIEDID_4K2K_P0[i] != _au1EEPBuf[i])
        {
            Printf("write fail !\n");
            return 0;
        }
    }

    Printf("write successfully !\n");

    vHDMI_INTERNAL_EDID_Init();

    return 0;
}
static INT32 _InternalEdidRead(void)
{
    INT32 fgSet;
    INT32 i;
    UINT8 u1PAOffset = 0;
    UINT8 u1Hdmi1PA = 0;
    UINT8 u1Checksum = 0;
    UINT8 u1Buf = 0;
#if defined(CC_SOEM_BOARD)
    UINT64 u8Offset;
    UINT8 idx = 0;
	idx = (UINT8 )FlashPanel_GetHdmiEdidIndex();
	if(idx < 1)
	{
		idx = 1 ;
	}
	idx--; 
	Printf("\nHdmi edid idx %d\n", idx);


	if((idx+1)*HDMI_EDID_SIZE > HDMI_EDID_STORAGE_SIZE)
	{
		u8Offset = 0;
	}
	else
	{
		u8Offset = idx*HDMI_EDID_SIZE;
	}
    fgSet = EEPHDMIEDID_Read(u8Offset, (UINT32)_au1EEPBuf, SIF_HDMIEDID_SIZE);
#else
    fgSet = EEPHDMIEDID_Read(0, (UINT32)_au1EEPBuf, SIF_HDMIEDID_SIZE);
#endif
    if (fgSet)
    {
        Printf("read eeprom back fail.\n");
        return 0;
    }

    for (i = 0; i < SIF_HDMIEDID_SIZE; i += 8)
    {
        Printf("0x%08X : 0x%02X 0x%02X 0x%02X 0x%02X, 0x%02X 0x%02X 0x%02X 0x%02X.\n",
               i,
               _au1EEPBuf[i],
               _au1EEPBuf[i + 1],
               _au1EEPBuf[i + 2],
               _au1EEPBuf[i + 3],
               _au1EEPBuf[i + 4],
               _au1EEPBuf[i + 5],
               _au1EEPBuf[i + 6],
               _au1EEPBuf[i + 7]);
    }

    // checksum
    u1Buf = 0;
    for (i = 0; i < 127; i++)
    {
        u1Buf += _au1EEPBuf[i];
    }

    u1Checksum = 0x100 - u1Buf;
    if (u1Checksum == _au1EEPBuf[127])
    {
        Printf("Block0 checksum ok: 0x%02X \n", u1Checksum);
    }
    else
    {
        Printf("Block0 checksum ERR: 0x%02X \n", u1Checksum);
    }

    u1Buf = 0;
    for (i = 128 ; i < 255 ; i++)
    {
        u1Buf += _au1EEPBuf[i];
    }

    u1Checksum = 0x100 - u1Buf;
    if (u1Checksum == _au1EEPBuf[255])
    {
        Printf("Block1 checksum ok: 0x%02X \n", u1Checksum);
    }
    else
    {
        Printf("Block1 checksum ERR: 0x%02 \nX", u1Checksum);
    }

    // PA
    for (i = 128 ; i < 256 ; i++)
    {
        if ((_au1EEPBuf[i] == 0x3) && \
            (_au1EEPBuf[i + 1] == 0xc) && \
            (_au1EEPBuf[i + 2] == 0x0))
        {
            u1PAOffset = i + 3;
        }
    }

    if (u1PAOffset < 255)
    {
        u1Hdmi1PA = _au1EEPBuf[u1PAOffset];
        Printf("CEC Physical offset %d\n", u1PAOffset);
        Printf("HDMI1 Physical adr 0x%x\n", u1Hdmi1PA);
    }
    else
    {
        Printf("!!!Invalid CEC Physical address offset\n");
    }

    return 0;
}

//-------------------------------------------------------------------------
/** _SifVGAEdidWriteSramCmd
 *  SIF CLI write VGA Edid in system EEPROM/nand function.
 *  @param  i4Argc              user's CLI input length.
 *  @param  szArgv              user's CLI input string.
 *  @retval  1  SUCCESS.
 *  @retval  0  FAIL.
 */
//-------------------------------------------------------------------------
static INT32 _SifInternalEdidWriteSramCmd(INT32 i4Argc, const CHAR** szArgv)
{
    _InternalEdidWriteSram();
    return 0;
}

static INT32 _SifInternal3DEdidWriteSramCmd(INT32 i4Argc, const CHAR** szArgv)
{
    _Internal3DEdidWriteSram();
    return 0;
}

static INT32 _SifInternal4K2KEdidWriteSramCmd(INT32 i4Argc, const CHAR** szArgv)
{
    _Internal4K2KEdidWriteSram();
    return 0;
}
#ifdef CC_HDMI_2_0_HDCP_BIN

static INT32 _SifInternalHDMI2EdidWriteSramCmd(INT32 i4Argc, const CHAR** szArgv)
{
	vHDMI20EDIDWriteToEep();
	vHDMILoadEDID2ToSram();
	return 0;
}
#endif
static INT32 _SifInternalMHLEdidWriteSramCmd(INT32 i4Argc, const CHAR** szArgv)
{
	INT32 val,i;
	if(i4Argc < 2)
	{
		printf("usage:0-->Write default MHL EDID to SRAM without writting to EEP/FLASH firstly!\n");
		printf("    1-->Write default MHL EDID to SRAM with writting to EEP/FLASH firstly!\n");
		return 0;
	}
	
	val = (INT32)StrToInt(szArgv[1]);
	if(val == 0)
	{
		for(i=0; i < FLASH_MHL_2_0_EDID_SIZE; i++)
		{
#if defined(CC_MT5890)//MT5861 share the define with MT5890.
			if(IS_IC_5861())//only 5861.
			{
				vIO32Write1B(PDWNC_MHL_EDID_ADDR,i);
				vIO32Write4B(PDWNC_MHL_EDID_DATA,u1MhlEdid[i]);
				//vUtDelay2us(1);
			}
#endif
		}
		return 0;
	}
#ifdef CC_HDMI_2_0_HDCP_BIN
	vMHL20EDIDWriteToEep();
	vHDMILoadMhlEdidToSram();
#endif
	return 0;
}

#endif

#ifdef CC_HDMI_2_0_HDCP_BIN
static INT32 _SifPROMWriteSramCmd(INT32 i4Argc, const CHAR** szArgv)
{
	vHDMI20LoadPromToSram();
	return 0;
}
static INT32 _SifPRAMWriteSramCmd(INT32 i4Argc, const CHAR** szArgv)
{
	vHDMI20LoadPramToSram();
	return 0;
}
static INT32 _SifHDCP1xWriteSramCmd(INT32 i4Argc, const CHAR** szArgv)
{
	vHDMI14HDCP1KeyWriteToEep();
	vHDMILoadHdcp14KeyToSram();
	return 0;
}
static INT32 _SifHDCP2xWriteCmd(INT32 i4Argc, const CHAR** szArgv)
{
	vHDMI20HDCP2KeyWriteToEep();
  	vHDMI20LoadHdcp2KeyToSram();

    return 0;
}
#endif

//-------------------------------------------------------------------------
/** _SifHDCPWriteSramCmd
 *  SIF CLI write HDMI HDCP in system EEPROM function.
 *  @param  i4Argc              user's CLI input length.
 *  @param  szArgv              user's CLI input string.
 *  @retval  1  SUCCESS.
 *  @retval  0  FAIL.
 */
//-------------------------------------------------------------------------
static INT32 _SifHDCPWriteSramCmd(INT32 i4Argc, const CHAR** szArgv)
{
    INT32 fgSet;
    INT32 i;

    fgSet = EEPHDCP_Write(0, (UINT32)_au1HDCP, SIF_HDCP_SIZE);
    if (fgSet)
    {
        Printf("EEPHDCP_Write fail.\n");
        return 0;
    }

    fgSet = EEPHDCP_Read(0, (UINT32)_au1EEPBuf, SIF_HDCP_SIZE);
    if (fgSet)
    {
        Printf("read eeprom back fail.\n");
        return 0;
    }

    for (i = 0; i < SIF_HDCP_SIZE; i++)
    {
        if (_au1HDCP[i] != _au1EEPBuf[i])
        {
            Printf("write fail !\n");
            return 0;
        }
    }

    Printf("write successfully !\n");

    fgSet = EEPHDCP_Init();
    if (fgSet)
    {
        Printf("EEPHDCP_Init fail.\n");
        return 0;
    }

    Printf("load to HDCP SRAM successfully !\n");

    fgSet = EEPHDCP_SetSramDevice(1, 0xA0);
    if (fgSet)
    {
        Printf("EEPHDCP_SetSramDevice fail.\n");
        return 0;
    }

    Printf("Open HDCP SRAM device address = 0xA0 !\n");

    return 0;
}

//-------------------------------------------------------------------------
/** mhdcp2x_key_eeprom
 *  SIF CLI write Miracast HDCP key in system EEPROM function.
 *  @param  i4Argc              user's CLI input length.
 *  @param  szArgv              user's CLI input string.
 *  @retval  1  SUCCESS.
 *  @retval  0  FAIL.
 */
//-------------------------------------------------------------------------
static INT32 mhdcp2x_key_eeprom(INT32 i4Argc, const CHAR** szArgv)
{
    INT32 fgSet;
    INT32 i;



#ifdef CUST_SOEM_DRV
	Printf("_SifHDCP2xWriteCmd(sony salvia)\n");
#endif

#ifdef CC_MAPLE_CUST_DRV
	Printf("_SifHDCP2xWriteCmd(sony sakura)\n");
#endif


    fgSet = EEPHDCP2x_Write(0, (UINT32)_au1HDCP2x_production_key, SIF_HDCP2X_SIZE);
    if (fgSet)
    {
        Printf("EEPHDCP_Write fail.\n");
        return 0;
    }


    x_memset(_au1EEPBuf2x, 0, sizeof(_au1EEPBuf2x));

    fgSet = EEPHDCP2x_Read(0, (UINT32)_au1EEPBuf2x, SIF_HDCP2X_SIZE);
    if (fgSet)
    {
        Printf("read eeprom back fail.\n");
        return 0;
    }

    for (i = 0; i < SIF_HDCP2X_SIZE; i++)
    {
        if (_au1HDCP2x_production_key[i] != _au1EEPBuf2x[i])
        {
            Printf("write fail !\n");
            return 0;
        }
    }

    Printf("write hdcp production key successfully !\n");

    return 0;
}



/** mhdcp2x_key_test

 */
//-------------------------------------------------------------------------

static INT32 mhdcp2x_key_test(INT32 i4Argc, const CHAR** szArgv)
{

#ifdef __KERNEL__

    int key_type_flag = 0;

    Printf("mhdcp2x_key_test HDCP2X KEY TYPE:[%d]\n", key_type_flag);

    if (2 != i4Argc)
    {
        Printf("mhdcp2x_key_test: wrong arg number\n", key_type_flag);
        return 0;
    }

    if (0 != key_type_flag && 1 != key_type_flag)
    {
        Printf("mhdcp2x_key_test: wrong arg value(should be 1 or 0)\n", key_type_flag);
        return 0;
    }

    key_type_flag = StrToInt(szArgv[1]);

    if (0 == key_type_flag)
    {
        Printf("Set HDCP2X KEY TYPE: PRODUCTION KEY\n");
    }
    else
    {
        Printf("Set HDCP2X KEY TYPE: TEST KEY(2.2 R1)\n");
    }

    _MTDRM_HDCP2_UseTestKey_InKernel_for_sif(key_type_flag);

#endif

    return 0;
}




/** mhdcp2x_key_test

 */
//-------------------------------------------------------------------------

static INT32 mhdcp2x_key_tz(INT32 i4Argc, const CHAR** szArgv)
{

#ifdef __KERNEL__
    int flag = 0;

    if (2 != i4Argc)
    {
        Printf("mhdcp2x_key_tz: wrong arg number\n", flag);
        return 0;
    }



    flag = StrToInt(szArgv[1]);
    if (1 == flag)
    {
        Printf("use hdcp2.x key in tz\n");
    }
    else
    {
        Printf("not use hdcp2.x key in tz\n");
    }
	

    _MTDRM_HDCP2_enable_tz_key(flag);
#endif

    return 0;
}



//--------------------------
//-------------------------------------------------------------------------
/** _SifHDCPReadCmd
 *  SIF CLI read HDMI HDCP in system EEPROM function.
 *  @param  i4Argc              user's CLI input length.
 *  @param  szArgv              user's CLI input string.
 *  @retval  1  SUCCESS.
 *  @retval  0  FAIL.
 */
//-------------------------------------------------------------------------
static INT32 _SifHDCPReadCmd(INT32 i4Argc, const CHAR** szArgv)
{
    UINT32 u4Idx;
    UINT32 u4Data[4];
    INT32 fgSet;

    fgSet = EEPHDCP_Init();
    if (fgSet)
    {
        Printf("EEPHDCP_Init fail.\n");
        return 0;
    }

    // write to hdcp sram pointer.
    vIO32Write4B(HDCP_ADDR, 0);

    for (u4Idx = 0; u4Idx < SIF_HDCP_SIZE; u4Idx += 16)
    {
        u4Data[0] = u4IO32Read4B(HDCP_DATA);
        u4Data[1] = u4IO32Read4B(HDCP_DATA);
        u4Data[2] = u4IO32Read4B(HDCP_DATA);
        u4Data[3] = u4IO32Read4B(HDCP_DATA);

        Printf("0x%08X : 0x%08X, 0x%08X, 0x%08X, 0x%08X.\n", u4Idx, u4Data[0], u4Data[1], u4Data[2], u4Data[3]);
    }

    return 0;
}

//-------------------------------------------------------------------------
/** _SifHDCPWriteByteCmd
 *  SIF CLI SW IIC write byte function.
 *  @param  i4Argc              user's CLI input length.
 *  @param  szArgv              user's CLI input string.
 *  @retval  1  SUCCESS.
 *  @retval  0  FAIL.
 */
//-------------------------------------------------------------------------
static INT32 _SifHDCPWriteByteCmd(INT32 i4Argc, const CHAR** szArgv)
{
    INT32 fgSet;
    UINT32 u4Addr;
    UINT8 u1ByteValue;

    if (i4Argc < 3)
    {
        Printf("Arg: u4Addr u1ByteValue.\n");
        return 0;
    }
    u4Addr = StrToInt(szArgv[1]);
    u1ByteValue = (UINT8)(StrToInt(szArgv[2]) & 0xFF);

    if ((u4Addr + 1) > SIF_HDCP_SIZE)
    {
        Printf("hdcp size only 320 bytes.\n");
        return 0;
    }

    fgSet = EEPHDCP_Write((UINT64)u4Addr, (UINT32)&u1ByteValue, 1);
    if (fgSet)
    {
        Printf("write fail.\n");
        return 0;
    }
    Printf("write successfully !\n");

    return 0;
}

//-------------------------------------------------------------------------
/** _SifHDCPReadByteCmd
 *  SIF CLI SW IIC read byte function.
 *  @param  i4Argc              user's CLI input length.
 *  @param  szArgv              user's CLI input string.
 *  @retval  1  SUCCESS.
 *  @retval  0  FAIL.
 */
//-------------------------------------------------------------------------
static INT32 _SifHDCPReadByteCmd(INT32 i4Argc, const CHAR** szArgv)
{
    INT32 fgSet;
    UINT32 u4Addr;
    UINT8 u1ByteValue = 0;

    if (i4Argc < 2)
    {
        Printf("Arg: u4Addr.\n");
        return 0;
    }
    u4Addr = StrToInt(szArgv[1]);

    if (u4Addr >= SIF_HDCP_SIZE)
    {
        Printf("hdcp size only 320 bytes.\n");
        return 0;
    }

    fgSet = EEPHDCP_Read((UINT64)u4Addr, (UINT32)&u1ByteValue, 1);
    if (fgSet)
    {
        Printf("read fail.\n");
        return 0;
    }

    // send out data to console.
    SerPollPutChar(u1ByteValue);
    Printf("read successfully !\n");
    return 0;
}

static INT32 _SifHDCPWrAllByteCmd(INT32 i4Argc, const CHAR** szArgv)
{
    INT32 i, fgSet;
    HAL_TIME_T rOrgTime, rNewTime, rDeltaTime;

    HAL_GetTime(&rOrgTime);
    for (i = 0; i < SIF_HDCP_SIZE; i++)
    {
        HAL_GetTime(&rNewTime);
        HAL_GetDeltaTime(&rDeltaTime, &rOrgTime, &rNewTime);
        if (rDeltaTime.u4Seconds > 15)
        {
            SerPollPutChar('F');
            return 1;
        }
        _au1EEPBuf[i] = SerPollGetChar();
    }

    fgSet = EEPHDCP_Write((UINT64)0, (UINT32)_au1EEPBuf, SIF_HDCP_SIZE);
    if (fgSet)
    {
        SerPollPutChar('F');
        return 1;
    }

    SerPollPutChar('S');
    return 0;
}

static INT32 _SifHDCPRdAllByteCmd(INT32 i4Argc, const CHAR** szArgv)
{
    INT32 i, x, fgSet;

    fgSet = EEPHDCP_Read((UINT64)0, (UINT32)_au1EEPBuf, SIF_HDCP_SIZE);
    if (fgSet)
    {
        x_memset(_au1EEPBuf, 0, SIF_HDCP_SIZE);
    }
    for (i = 0; i < SIF_HDCP_SIZE; i++)
    {
        if (_au1EEPBuf[i] == 0x18)
        {
            fgSet++;
        }
        if (_au1EEPBuf[i] == 0x00)
        {
            fgSet++;
        }
        SerPollPutChar(_au1EEPBuf[i]);
        // delay 1ms.
        for (x = 0; x < 30000; x++) { }
    }

    return 0;
}

//-------------------------------------------------------------------------
/** _SifSWWriteEeprom
 *  SIF CLI SW IIC write EEPROM function.
 * @param u4SDA 	GPIO number as SDA.
 * @param u4SCL 	GPIO number as SCL.
 * @param pbData pointer of data to be sent out
 *  @retval  1  SUCCESS.
 *  @retval  0  FAIL.
 */
//-------------------------------------------------------------------------
static INT32 _SifSWWriteEeprom(UINT32 u4SDA, UINT32 u4SCL, UINT8* pu1Data)
{
    UINT8 u1Ret = 0;
    INT32 fgSet;
    UINT32 u4Index = 0;
    UINT32 u4Cnt;
    UINT32 u4DeviceAddr;

    UINT32 u4EdidWP, u4EdidWPEnable, u4Flag = 0;

    // disable write protect.
    if (0 == DRVCUST_OptQuery(eEdidEepromWPGpio, &u4EdidWP) &&
        (0 == DRVCUST_OptQuery(eEdidEepromWPEnablePolarity, &u4EdidWPEnable)))
    {
        u4Flag = 1;
        fgSet = !(INT32)u4EdidWPEnable;
        VERIFY(GPIO_Output((INT32)u4EdidWP, &fgSet) == fgSet);
    }

    Printf("Write EDID EEPROM SDA = GPIO%d, SCL = GPIO%d.\n", u4SDA, u4SCL);

    // initial SIF sda, scl pin.
    SIFSW_Init(u4SDA, u4SCL);

    u4Index = 0;
    // EEPROM page length = 8 bytes.
    while (u4Index < SIF_EDID_SIZE)
    {
        u4Cnt = ((SIF_EDID_SIZE -  u4Index) > 8) ? 8 : (SIF_EDID_SIZE -  u4Index);

        // lower device address [b3, b2, b1] are from address [A10, A9, A8].
        u4DeviceAddr = (u4Index >> 7) & 0x0E;
        u4DeviceAddr |= 0xA0;

        u1Ret = SIFSW_WriteData(0xA0, u4Index, u4Cnt, (UINT8*)&pu1Data[u4Index], 0xFF);

        if (u1Ret == 0)
        {
            Printf("write fail.\n");

            // enable write protect.
            if (u4Flag)
            {
                fgSet = (INT32)u4EdidWPEnable;
                VERIFY(GPIO_Output((INT32)u4EdidWP, &fgSet) == fgSet);
            }

            SIFSW_Remove();
            return 0;
        }
        // Wait EEPROM to program.
        x_thread_delay(20);

        u4Index += u4Cnt;
    }

    Printf("Write successfully !\n");

    // enable write protect.
    if (u4Flag)
    {
        fgSet = (INT32)u4EdidWPEnable;
        VERIFY(GPIO_Output((INT32)u4EdidWP, &fgSet) == fgSet);
    }

    SIFSW_Remove();

    return 1;
}

//-------------------------------------------------------------------------
/** _SifEDIDWriteCmd
 *  SIF CLI SW IIC write HDMI EDID EEPROM function.
 *  @param  i4Argc              user's CLI input length.
 *  @param  szArgv              user's CLI input string.
 *  @retval  1  SUCCESS.
 *  @retval  0  FAIL.
 */
//-------------------------------------------------------------------------
static UINT8 _bPreHdmiPort = 0;
static INT32 _SifEDIDWriteCmd(INT32 i4Argc, const CHAR** szArgv)
{
#if !defined(CC_HDMI_EDID_DISABLE)
    _InternalEdidWriteSram();
    UNUSED(_bPreHdmiPort);
#else
    _bPreHdmiPort = _bHDMICurrSwitch;

    vHDMISetSwitch(1);
    Printf("Write 1st EDID EEPROM.\n");
    _SifSWWriteEeprom(SIF_EDID1_SDA, SIF_EDID1_SCL, (UINT8*)_au1EDID_CEC_192k_DeepColor12B_P1);

    vHDMISetSwitch(2);
    Printf("\nWrite 2nd EDID EEPROM.\n");
    _SifSWWriteEeprom(SIF_EDID2_SDA, SIF_EDID2_SCL, (UINT8*)_au1EDID_CEC_192k_DeepColor12B_P2);

#if defined(CC_MT5363P1V1)
    vHDMISetSwitch(3);
    Printf("\nWrite 3rd EDID EEPROM.\n");
    _SifSWWriteEeprom(SIF_EDID2_SDA, SIF_EDID2_SCL, (UINT8*)_au1EDID_CEC_192k_DeepColor12B_P3);
#endif

#if defined(CC_MT5363P1V1)
    vHDMISetSwitch(4);
    Printf("\nWrite 4th EDID EEPROM.\n");
    _SifSWWriteEeprom(SIF_EDID2_SDA, SIF_EDID2_SCL, (UINT8*)_au1EDID_CEC_192k_DeepColor12B_P4);
#endif

    vHDMISetSwitch(_bPreHdmiPort);
#endif

    return 0;
}
static INT32 _SifEDID1WriteCmd(INT32 i4Argc, const CHAR** szArgv)
{
    Printf("Write 1st EDID EEPROM.\n");    //_SifSWWriteEeprom(SIF_EDID1_SDA, SIF_EDID1_SCL, (UINT8 *)_au1EDID);
    _SifSWWriteEeprom(SIF_EDID1_SDA, SIF_EDID1_SCL, (UINT8*)_au1EDID_CEC_192k_DeepColor12B_P1);
    return 0;
}
static INT32 _SifEDID2WriteCmd(INT32 i4Argc, const CHAR** szArgv)
{
    Printf("\nWrite 2nd EDID EEPROM.\n");
    _SifSWWriteEeprom(SIF_EDID2_SDA, SIF_EDID2_SCL, (UINT8*)_au1EDID_CEC_192k_DeepColor12B_P2);
    return 0;
}
static INT32 _SifEDID3WriteCmd(INT32 i4Argc, const CHAR** szArgv)
{
    Printf("\nWrite 3rd EDID EEPROM.\n");
    _SifSWWriteEeprom(SIF_EDID3_SDA, SIF_EDID3_SCL, (UINT8*)_au1EDID_CEC_192k_DeepColor12B_P3);
    return 0;
}

//-------------------------------------------------------------------------
/** _SifEDIDReadCmd
 *  SIF CLI SW IIC write HDMI EDID EEPROM function.
 *  @param  i4Argc              user's CLI input length.
 *  @param  szArgv              user's CLI input string.
 *  @retval  1  SUCCESS.
 *  @retval  0  FAIL.
 */
//-------------------------------------------------------------------------
static INT32 _SifEDIDReadCmd(INT32 i4Argc, const CHAR** szArgv)
{
#if !defined(CC_HDMI_EDID_DISABLE)
    _InternalEdidRead();
#else
    _bPreHdmiPort = _bHDMICurrSwitch;

    vHDMISetSwitch(1);
    Printf("Read 1st EDID EEPROM SDA = GPIO%d, SCL = GPIO%d.\n", SIF_EDID1_SDA, SIF_EDID1_SCL);
    CLI_Parser_Arg("sif.sr %d %d 0xA0 0 256", SIF_EDID1_SDA, SIF_EDID1_SCL);

    vHDMISetSwitch(2);
    Printf("\nRead 2nd EDID EEPROM SDA = GPIO%d, SCL = GPIO%d.\n", SIF_EDID2_SDA, SIF_EDID2_SCL);
    CLI_Parser_Arg("sif.sr %d %d 0xA0 0 256", SIF_EDID2_SDA, SIF_EDID2_SCL);

#if defined(CC_MT5363P1V1)
    vHDMISetSwitch(3);
    Printf("\nRead 3rd EDID EEPROM SDA = GPIO%d, SCL = GPIO%d.\n", SIF_EDID2_SDA, SIF_EDID2_SCL);
    CLI_Parser_Arg("sif.sr %d %d 0xA0 0 256", SIF_EDID2_SDA, SIF_EDID2_SCL);
#endif

#if defined(CC_MT5363P1V1)
    vHDMISetSwitch(4);
    Printf("\nRead 4th EDID EEPROM SDA = GPIO%d, SCL = GPIO%d.\n", SIF_EDID2_SDA, SIF_EDID2_SCL);
    CLI_Parser_Arg("sif.sr %d %d 0xA0 0 256", SIF_EDID2_SDA, SIF_EDID2_SCL);
#endif

    vHDMISetSwitch(_bPreHdmiPort);
#endif

    return 0;
}
static INT32 _SifEDID1ReadCmd(INT32 i4Argc, const CHAR** szArgv)
{

    Printf("Read 1st EDID EEPROM SDA = GPIO%d, SCL = GPIO%d.\n", SIF_EDID1_SDA, SIF_EDID1_SCL);
    CLI_Parser_Arg("sif.sr %d %d 0xA0 0 256", SIF_EDID1_SDA, SIF_EDID1_SCL);
    return 0;
}
static INT32 _SifEDID2ReadCmd(INT32 i4Argc, const CHAR** szArgv)
{

    Printf("\nRead 2nd EDID EEPROM SDA = GPIO%d, SCL = GPIO%d.\n", SIF_EDID2_SDA, SIF_EDID2_SCL);
    CLI_Parser_Arg("sif.sr %d %d 0xA0 0 256", SIF_EDID2_SDA, SIF_EDID2_SCL);
    return 0;
}
static INT32 _SifEDID3ReadCmd(INT32 i4Argc, const CHAR** szArgv)
{

    Printf("\nRead 3rd EDID EEPROM SDA = GPIO%d, SCL = GPIO%d.\n", SIF_EDID3_SDA, SIF_EDID3_SCL);
    CLI_Parser_Arg("sif.sr %d %d 0xA0 0 256", SIF_EDID3_SDA, SIF_EDID3_SCL);
    return 0;
}

static INT32 _SifHDMIReadEdidRam(INT32 i4Argc, const CHAR** szArgv)
{
    UINT16 i = 0;
    UINT16 j = 0;
    for (i = 0; i < 4; i ++)
    {
        j = 0;
        Printf("EDID%d:\n", i);
        while (j < 256)
        {
            if ((j % 16) == 0)
            {
                Printf("0x%08X ", j);
            }
            vIO32Write1B(PDWNC_EDID_ADDR, j);

            if ( j == IO32ReadFldAlign(PDWNC_EDID_CTL1 + (i - 1) * 4, FLD_OFFSET1) && (i != 0))
            {
                Printf("0x%02X ", IO32ReadFldAlign(PDWNC_EDID_CTL1 + (i - 1) * 4, FLD_PHY_ADDR1));
            }
            else if ((j == 255) && (i != 0))
            {

                Printf("0x%02X ", IO32ReadFldAlign(PDWNC_EDID_CTL1 + (i - 1) * 4, FLD_CHKSUM1));
            }
            else
            {
                Printf("0x%02X ", IO32ReadFldAlign(PDWNC_EDID_DATA, FLD_EDID_DATA));
            }
            if (((j + 1) % 16) == 0)
            {
                Printf("\n");
            }
            j++;
        }
    }

    return 0;
}

//-------------------------------------------------------------------------
/** _SifEDIDWriteByteCmd
 *  SIF CLI SW IIC write function.
 *  @param  i4Argc              user's CLI input length.
 *  @param  szArgv              user's CLI input string.
 *  @retval  1  SUCCESS.
 *  @retval  0  FAIL.
 */
//-------------------------------------------------------------------------
static INT32 _SifEDIDWrAllByteCmd(INT32 i4Argc, const CHAR** szArgv)
{
    INT32 i;
    HAL_TIME_T rOrgTime, rNewTime, rDeltaTime;

    HAL_GetTime(&rOrgTime);
    for (i = 0; i < SIF_EDID_SIZE; i++)
    {
        HAL_GetTime(&rNewTime);
        HAL_GetDeltaTime(&rDeltaTime, &rOrgTime, &rNewTime);
        if (rDeltaTime.u4Seconds > 15)
        {
            SerPollPutChar('F');
            return 1;
        }
        _au1EEPBuf[i] = SerPollGetChar();
    }

    if (0 == _SifSWWriteEeprom(SIF_EDID1_SDA, SIF_EDID1_SCL, _au1EEPBuf))
    {
        Printf("write 1st EDID fail.\n");
        SerPollPutChar('F');
        return 0;
    }

    if (0 == _SifSWWriteEeprom(SIF_EDID2_SDA, SIF_EDID2_SCL, _au1EEPBuf))
    {
        Printf("write 2nd EDID fail.\n");
        SerPollPutChar('F');
        return 0;
    }

    if (0 == _SifSWWriteEeprom(SIF_EDID3_SDA, SIF_EDID3_SCL, _au1EEPBuf))
    {
        Printf("write 3rd EDID fail.\n");
        SerPollPutChar('F');
        return 0;
    }

    Printf("write successfully !\n");
    SerPollPutChar('S');

    return 0;
}

static INT32 _SifEDIDRdAllByteCmd(INT32 i4Argc, const CHAR** szArgv)
{
    UINT32 u4Dev;
    UINT32 u4SDA;
    UINT32 u4SCL;
    UINT32 u4Addr;
    UINT32 u4Count;
    UINT32 u4ReturnValue;
    INT32 i, x;

    u4SDA = SIF_EDID1_SDA;
    u4SCL = SIF_EDID1_SCL;
    u4Dev = 0xa0;
    u4Addr = 0;
    u4Count = 256;

    SIFSW_Init(u4SDA, u4SCL);

    u4ReturnValue = SIFSW_ReadData(u4Dev, u4Addr, u4Count, _au1EEPBuf, 0xFF);

    SIFSW_Remove();

    for (i = 0; i < SIF_EDID_SIZE; i++)
    {
        if (!u4ReturnValue)
        {
            SerPollPutChar(0xFF);
        }
        else
        {
            SerPollPutChar(_au1EEPBuf[i]);
        }
        // delay 1ms.
        for (x = 0; x < 30000; x++) { }
    }

    return 0;
}

static INT32 _SifTunerReadNoSubCmd(INT32 i4Argc, const CHAR**  szArgv)
{
#define	ARGC_BASE	0
    UINT8 u1Dev;
    UINT32 u4Idx;
    UINT32 u4ClkDiv;
    UINT32 u4Count;
    UINT8* pu1Buf;
    UINT8* pu2Buf;
    INT32 i4ReturnValue;

    if (i4Argc < 4)
    {
        Printf("Arg: u4ClkDiv u1Dev  u4Count\n");
        return 0;
    }

    u4ClkDiv = StrToInt(szArgv[ARGC_BASE + 1]);
    u1Dev = (UINT8)StrToInt(szArgv[ARGC_BASE + 2]);
    u4Count = StrToInt(szArgv[ARGC_BASE + 3]);
    pu1Buf = (UINT8*)x_mem_alloc(u4Count);
    if (pu1Buf == NULL)
    {
        return -1;
    }
    x_memset((VOID*)pu1Buf, 0, u4Count);

    pu2Buf = pu1Buf;

    i4ReturnValue = SIF_TunerReadNoSubAddr(u4ClkDiv, u1Dev, pu1Buf, u4Count);

    Printf("u1Dev=0x%X,  u4Count=%d, i4ReturnValue=%d.\n",
           u1Dev,
           u4Count,
           i4ReturnValue);

    if (i4ReturnValue > 0)
    {
        // print sif read data content.
        for (u4Idx = 0; u4Idx < i4ReturnValue; u4Idx ++)
        {
            if (!(u4Idx % 8))
            {
                Printf("\n0x%08X :", u4Idx);
            }

            Printf(" 0x%02X,", pu1Buf[u4Idx]);
        }
        Printf("\n");
    }
    else
    {
        // fail.
        Printf("sif read fail.\n");
    }

    x_mem_free((VOID*)pu2Buf);

    return 0;
}

static INT32 _SifTunerWriteNoSubCmd(INT32 i4Argc, const char** szArgv)
{
    UINT8 u1Dev;

    UINT32 u4ClkDiv;
    UINT32 u4Count;
    INT32 i4ReturnValue;
    UINT8* pu1Buf;
    UINT8* pu2Buf;
    int i;

    if (i4Argc < 5)
    {
        Printf("Arg: u4ClkDiv u1Dev u4Count  [Data] [Data] [Data] ...\n");
        return 0;
    }

    u4ClkDiv = StrToInt(szArgv[1]);
    u1Dev = (UINT8)StrToInt(szArgv[2]);
    u4Count = StrToInt(szArgv[3]);
    pu1Buf = (UINT8*) x_mem_alloc( u4Count ) ;
    if ( pu1Buf == NULL )
    {
        return -1;
    }

    for (i = 0; i < u4Count; i++)
    {
        pu1Buf[i] = StrToInt( szArgv[i + 4] );
    }

    pu2Buf = pu1Buf;
    i4ReturnValue = SIF_TunerWriteNoSubAddr(u4ClkDiv, u1Dev, (UINT8*)pu1Buf, u4Count);

    Printf("u1Dev=0x%X,  u4Count=%d, i4ReturnValue=%d.\n",
           u1Dev,
           u4Count,
           i4ReturnValue);

    if (i4ReturnValue > 0)
    {
        Printf("write successfully! byte count = %d\n", i4ReturnValue);
    }
    else
    {
        Printf("write fail.\n");
    }

    x_mem_free(pu2Buf);
    return 0;
}

static INT32 _SifReadMultiCmd(INT32 i4Argc, const CHAR**  szArgv)
{
#define	ARGC_BASE	0
    UINT8 u1Dev;
    UINT32 u4Idx;
    UINT32 u4ClkDiv;
    UINT32 u4Addr;
    UINT32 u4Count;
    UINT8* pu1Buf;
    UINT8* pu2Buf;
    INT32 i4ReturnValue;
    UINT8 u1AddrNum;

    if (i4Argc < 6)
    {
        Printf("Arg: u4ClkDiv u1Dev u1AddrNum u4Addr u4Count\n");
        return 0;
    }

    u4ClkDiv = StrToInt(szArgv[ARGC_BASE + 1]);
    u1Dev = (UINT8)StrToInt(szArgv[ARGC_BASE + 2]);
    u1AddrNum = StrToInt(szArgv[ARGC_BASE + 3]);
    u4Addr = StrToInt(szArgv[ARGC_BASE + 4]);
    u4Count = StrToInt(szArgv[ARGC_BASE + 5]);
    pu1Buf = (UINT8*)x_mem_alloc(u4Count);
    if (pu1Buf == NULL)
    {
        return -1;
    }
    x_memset((VOID*)pu1Buf, 0, u4Count);

    pu2Buf = pu1Buf;

    i4ReturnValue = SIF_ReadMultipleSubAddr(u4ClkDiv, u1Dev, u1AddrNum , u4Addr, pu1Buf, u4Count);

    Printf("u1Dev=0x%X, u4Addr=0x%X, u4Count=%d, i4ReturnValue=%d.\n",
           u1Dev,
           u4Addr,
           u4Count,
           i4ReturnValue);

    if (i4ReturnValue > 0)
    {
        // print sif read data content.
        for (u4Idx = 0; u4Idx < i4ReturnValue; u4Idx ++)
        {
            if (!(u4Idx % 8))
            {
                Printf("\n0x%08X :", u4Idx);
            }

            Printf(" 0x%02X,", pu1Buf[u4Idx]);
        }
        Printf("\n");
    }
    else
    {
        // fail.
        Printf("sif read fail.\n");
    }


    x_mem_free((VOID*)pu2Buf);

    return 0;
}

static INT32 _SifWriteMultiCmd(INT32 i4Argc, const CHAR**  szArgv)
{
#define	ARGC_BASE	0
    UINT8  u1Dev;
    UINT32 u4ClkDiv;
    UINT32 u4Addr;
    UINT32 u4Count;
    UINT8* pu1Buf;
    UINT8* pu2Buf;
    INT32 i4ReturnValue;
    UINT8 u1AddrNum;
    int i;

    if (i4Argc < 7)
    {
        Printf("Arg: u4ClkDiv u1Dev u1AddrNum u4Addr u4Count [Data] [Data] [Data]...\n");
        return 0;
    }

    u4ClkDiv = StrToInt(szArgv[ARGC_BASE + 1]);
    u1Dev = (UINT8)StrToInt(szArgv[ARGC_BASE + 2]);
    u1AddrNum = StrToInt(szArgv[ARGC_BASE + 3]);
    u4Addr = StrToInt(szArgv[ARGC_BASE + 4]);
    u4Count = StrToInt(szArgv[ARGC_BASE + 5]);
    pu1Buf = (UINT8*)x_mem_alloc(u4Count);

    x_memset((VOID*)pu1Buf, 0, u4Count);

    pu2Buf = pu1Buf;

    if (pu1Buf == NULL)
    {
        return -1;
    }

    for (i = 0; i < u4Count; i++)
    {
        pu1Buf[i] = StrToInt( szArgv[i + 6] );
    }

    i4ReturnValue = SIF_WriteMultipleSubAddr(u4ClkDiv, u1Dev, u1AddrNum , u4Addr, (UINT8*)pu1Buf, u4Count);

    if (i4ReturnValue > 0)
    {
        Printf("write successfully! byte count = %d\n", i4ReturnValue);
    }
    else if (i4ReturnValue == 0)
    {
        Printf("Warning: IOCTL should never returns ZERO.\n");
    }
    else
    {
        Printf("write fail.\n");
    }

    x_mem_free((VOID*)pu2Buf);

    return 0;
}

static INT32 _SifRead_X_Cmd(INT32 i4Argc, const CHAR**  szArgv)
{
#define	ARGC_BASE	0
    UINT8 u1Dev;
    UINT32 u4Idx;
    UINT32 u4ClkDiv;
    UINT32 u4Addr;
    UINT32 u4Count;
    UINT8* pu1Buf;
    UINT8* pu2Buf;
    INT32 i4ReturnValue;
    UINT8 u1AddrNum;
    UINT8 u1ChannelId;

    if (i4Argc < 7)
    {
        Printf("Arg: u1ChannelId, u4ClkDiv u1Dev u1AddrNum u4Addr u4Count\n");
        return 0;
    }

    u1ChannelId = StrToInt(szArgv[ARGC_BASE + 1]);
    u4ClkDiv = StrToInt(szArgv[ARGC_BASE + 2]);
    u1Dev = (UINT8)StrToInt(szArgv[ARGC_BASE + 3]);
    u1AddrNum = StrToInt(szArgv[ARGC_BASE + 4]);
    u4Addr = StrToInt(szArgv[ARGC_BASE + 5]);
    u4Count = StrToInt(szArgv[ARGC_BASE + 6]);
    pu1Buf = (UINT8*)x_mem_alloc(u4Count);
    if (pu1Buf == NULL)
    {
        return -1;
    }
    x_memset((VOID*)pu1Buf, 0, u4Count);

    pu2Buf = pu1Buf;

    i4ReturnValue = SIF_X_Read(u1ChannelId, u4ClkDiv, u1Dev, u1AddrNum , u4Addr, pu1Buf, u4Count);

    Printf("u1ChannelId = %X, u1Dev=0x%X, u4Addr=0x%X, u4Count=%d, i4ReturnValue=%d.\n",
           u1ChannelId,
           u1Dev,
           u4Addr,
           u4Count,
           i4ReturnValue);

    if (i4ReturnValue > 0)
    {
        // print sif read data content.
        for (u4Idx = 0; u4Idx < i4ReturnValue; u4Idx++)
        {
            if (!(u4Idx % 8))
            {
                Printf("\n0x%08X :", u4Idx);
            }

            Printf(" 0x%02X,", pu1Buf[u4Idx]);
        }
        Printf("\n");
    }
    else
    {
        // fail.
        Printf("sif read fail.\n");
    }

    x_mem_free((VOID*)pu2Buf);

    return 0;
}

static INT32 _SifWrite_X_Cmd(INT32 i4Argc, const CHAR**  szArgv)
{
#define	ARGC_BASE	0
    UINT8  u1Dev;
    UINT32 u4ClkDiv;
    UINT32 u4Addr;
    UINT32 u4Count;
    UINT8* pu1Buf;
    UINT8* pu2Buf;
    INT32 i4ReturnValue;
    UINT8 u1AddrNum;
    UINT8 u1ChannelId;
    int i;

    if (i4Argc < 8)
    {
        Printf("Arg: u1ChannelId u4ClkDiv u1Dev u1AddrNum u4Addr u4Count [Data] [Data] [Data]...\n");
        return 0;
    }
    u1ChannelId = StrToInt(szArgv[ARGC_BASE + 1]);
    u4ClkDiv = StrToInt(szArgv[ARGC_BASE + 2]);
    u1Dev = (UINT8)StrToInt(szArgv[ARGC_BASE + 3]);
    u1AddrNum = StrToInt(szArgv[ARGC_BASE + 4]);
    u4Addr = StrToInt(szArgv[ARGC_BASE + 5]);
    u4Count = StrToInt(szArgv[ARGC_BASE + 6]);
    pu1Buf = (UINT8*)x_mem_alloc(u4Count);
    if (pu1Buf == NULL)
    {
        return -1;
    }

    for (i = 0; i < u4Count; i++)
    {
        pu1Buf[i] = StrToInt( szArgv[i + 7] );
    }

    pu2Buf = pu1Buf ;
    i4ReturnValue = SIF_X_Write(u1ChannelId, u4ClkDiv, u1Dev, u1AddrNum , u4Addr, (UINT8*)pu1Buf, u4Count);

    if (i4ReturnValue > 0)
    {
        Printf("write successfully! byte count = %d\n", i4ReturnValue);
    }
    else if (i4ReturnValue == 0)
    {
        Printf("Warning: IOCTL should never returns ZERO.\n");
    }
    else
    {
        Printf("write fail.\n");
    }

    x_mem_free( (VOID*)pu2Buf );
    return 0;
}

#ifdef CC_SUPPORT_TCON_FW_UPDATE//rc test
//#define UPDATE_FILE_NAME "/mnt/usb/sda1/tcon_upgrade.BIN"
#define TCON_I2C_CH SIF_BUS_SECOND_I2C
#define TCON_DEV_ADDR_W 0x98
#define TCON_DEV_ADDR_R 0x99
#define TCON_DEBUG_DEV_ADDR 0xb4
#define TCON_UPDATE_I2C_SPEED 0x43//I2C speed is 400kbps
//#define SAVE_FILE_NAME "/mnt/usb/sda1/save.BIN"

static INT32 _SifTconFWUpdate(INT32 i4Argc, const CHAR** szArgv)
{
    struct file* fp = NULL;
    UINT8 u1Array[5];
    UINT8 _au1TconFwBuf[2060];
    UINT8 u1StatusValue;
    UINT8 u1ReadStaus = 0;
    UINT32 u4Length;
    UINT64 u8Offset = 0;
    UINT32 u4ReadSize = 0;
    UINT32 u4WriteSize = 0;
    int i;
    int j;
    UINT32 u4FlashAddr;
    UINT32 u4ReadCount = 0;//for blank checking
    UINT8* pu1Buf;//for blank checking
    UINT32 u4Count;//for blank checking
#if defined(ANDROID)
    const char updatefilename[50] = {"/mnt/usbdisk/tcon_upgrade.BIN"};
#else
    const char updatefilename[50] = {"/mnt/usb/sda1/tcon_upgrade.BIN"};
#endif
    u4Count = 0x8000; //for blank checking

    //1.enter ISP mode
    Printf("Enter 1.enter ISP mode----\n");
    u1Array[0] = 0x24;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
    u1Array[0] = 0x4d;
    u1Array[1] = 0x53;
    u1Array[2] = 0x54;
    u1Array[3] = 0x41;
    u1Array[4] = 0x52;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 5);

    //2.command for SPI_WP pull high
    Printf("Enter 2.command for SPI_WP pull high----\n");
    u1Array[0] = 0x53;
    u1Array[1] = 0x45;
    u1Array[2] = 0x52;
    u1Array[3] = 0x44;
    u1Array[4] = 0x42;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEBUG_DEV_ADDR, 0, 0x0, u1Array, 5);
    u1Array[0] = 0x10;
    u1Array[1] = 0xc0;
    u1Array[2] = 0xc1;
    u1Array[3] = 0x53;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEBUG_DEV_ADDR, 0, 0x0, u1Array, 4);
    u1Array[0] = 0x10;
    u1Array[1] = 0x00;
    u1Array[2] = 0x1e;
    u1Array[3] = 0x9a;
    u1Array[4] = 0x00;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEBUG_DEV_ADDR, 0, 0x0, u1Array, 5);
    u1Array[3] = 0x76;
    u1Array[4] = 0x80;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEBUG_DEV_ADDR, 0, 0x0, u1Array, 5);
    u1Array[3] = 0x25;
    u1Array[4] = 0x00;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEBUG_DEV_ADDR, 0, 0x0, u1Array, 5);
    u1Array[3] = 0x1d;
    u1Array[4] = 0x02;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEBUG_DEV_ADDR, 0, 0x0, u1Array, 5);
    u1Array[1] = 0xc0;
    u1Array[2] = 0xc1;
    u1Array[3] = 0xff;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEBUG_DEV_ADDR, 0, 0x0, u1Array, 4);
    u1Array[0] = 0x45;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEBUG_DEV_ADDR, 0, 0x0, u1Array, 1);
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEBUG_DEV_ADDR, 0, 0x0, u1Array, 1);
    //3.chip erase
    Printf("Enter 3.Chip erase ----\n");
    u1Array[0] = 0x10;
    u1Array[1] = 0x05;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 2);
    u1Array[0] = 0x11;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
    SIF_X_Read(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_R, 0 , 0x0, &u1StatusValue, 1);
    Printf("u1StatusValue(%d) ----\n", u1StatusValue);
    u1Array[0] = 0x12;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
    //Printf("write 0x00 to status register----\n");
    Printf("write enable----\n");
    u1Array[0] = 0x10;
    u1Array[1] = 0x06;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 2);
    u1Array[0] = 0x12;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
    Printf("write 0x00 to status register----\n");
    u1Array[0] = 0x10;
    u1Array[1] = 0x01;
    u1Array[2] = 0x00;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 3);
    u1Array[0] = 0x12;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
    Printf("write disable----\n");
    u1Array[0] = 0x10;
    u1Array[1] = 0x04;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 2);
    u1Array[0] = 0x12;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
    Printf("C wait for flash ready----\n");
    u1Array[0] = 0x10;
    u1Array[1] = 0x05;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 2);
    u1Array[0] = 0x11;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
    u1ReadStaus = 1;
    SIF_X_Read(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_R, 0 , 0x0, &u1ReadStaus, 1);
    while ((u1ReadStaus & 0x01) != 0x0)
    {
        Printf("c wait for flash ready\n");
        u1Array[0] = 0x12;
        SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
        u1Array[0] = 0x10;
        u1Array[1] = 0x05;
        SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 2);
        u1Array[0] = 0x11;
        SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
        u1ReadStaus = 1;
        SIF_X_Read(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_R, 0 , 0x0, &u1ReadStaus, 1);
        Printf("c u1ReadStaus(%d) ----\n", u1ReadStaus);
    }
    u1Array[0] = 0x12;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
    Printf("c flash ready ----\n");
    //chip erase
    Printf("D write enable----\n");
    u1Array[0] = 0x10;
    u1Array[1] = 0x06;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 2);
    u1Array[0] = 0x12;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
    Printf("chip erase----\n");
    u1Array[0] = 0x10;
    u1Array[1] = 0xc7;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 2);
    u1Array[0] = 0x12;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
    Printf("E wait for flash ready again----\n");
    u1Array[0] = 0x10;
    u1Array[1] = 0x05;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 2);
    u1Array[0] = 0x11;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
    u1ReadStaus = 1;
    SIF_X_Read(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_R, 0 , 0x0, &u1ReadStaus, 1);
    while ((u1ReadStaus & 0x01) != 0x0)
    {
        Printf("E wait for flash ready\n");
        u1Array[0] = 0x12;
        SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
        u1Array[0] = 0x10;
        u1Array[1] = 0x05;
        SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 2);
        u1Array[0] = 0x11;
        SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
        u1ReadStaus = 1;
        SIF_X_Read(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_R, 0 , 0x0, &u1ReadStaus, 1);
        Printf("e u1ReadStaus(%d) ----\n", u1ReadStaus);
    }

    u1Array[0] = 0x12;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);

    //4.blanking check
    Printf("Enter 4.blanking check----\n");
    u1Array[0] = 0x10;
    u1Array[1] = 0x03;
    u1Array[2] = 0x0;
    u1Array[3] = 0x0;
    u1Array[4] = 0x0;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 5);
    u1Array[0] = 0x11;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);

    pu1Buf = (UINT8*)x_mem_alloc(u4Count);
    if (pu1Buf == NULL)
    {
        Printf("memory allocate fail!\n");
        return -1;
    }
    for (i = 0; i < 64; i++)
    {
        u4ReadCount = SIF_X_Read(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_R, 0 , 0x0, pu1Buf, u4Count);
        Printf("i,sif read cnt(%d,%d).\n", i, u4ReadCount);
        if (u4ReadCount > 0)
        {
            // print sif read data content.
            for (j = 0; j < u4ReadCount; j ++)
            {
                if ((pu1Buf[j] & 0xff) != 0xff)
                {
                    Printf(" flash data not empty and programing terminate(i,pu1Buf[i] u4ReadCount)(%d,%d,%d)", i, pu1Buf[i], u4ReadCount);
                    x_mem_free((VOID*)pu1Buf);
                    return 0;
                }
            }
        }
        else
        {
            // fail.
            Printf("sif read fail(%d).\n", u4ReadCount);
        }
    }
    x_mem_free((VOID*)pu1Buf);
    Printf("Blank checking finish----\n");
    u1Array[0] = 0x12;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);

    //5.programming
    Printf("Enter 5.programming----\n");
    fp = FILE_Open(updatefilename, O_RDONLY, 0);
    if (fp <= 0)
    {
        Printf("File open fail\n");
        return 0;
    }
    u4ReadSize = 2048;
    u4WriteSize = 256;
    u4FlashAddr = 0x0;
    x_memset(_au1TconFwBuf, 0, sizeof(_au1TconFwBuf));
    u4Length = FILE_Read(fp, &_au1TconFwBuf[5], u4ReadSize, &u8Offset);
    while (u4Length != 0)
    {
        if (u4Length <= 0)
        {
            Printf("read error-----\n");
            break;
        }

        if (u4Length > u4ReadSize)
        {
            Printf("error----\n");
            break;
        }
        for (i = 0; i < 8; i++)
        {
            _au1TconFwBuf[u4WriteSize * i + 0] = 0X10;
            _au1TconFwBuf[u4WriteSize * i + 1] = 0X02;
            _au1TconFwBuf[u4WriteSize * i + 2] = (u4FlashAddr & 0xff0000) >> 16;
            _au1TconFwBuf[u4WriteSize * i + 3] = (u4FlashAddr & 0x00ff00) >> 8;
            _au1TconFwBuf[u4WriteSize * i + 4] = u4FlashAddr & 0x0000ff;
            //////
            u1Array[0] = 0x10;
            u1Array[1] = 0x05;
            SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 2);
            u1Array[0] = 0x11;
            SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
            u1ReadStaus = 1;
            SIF_X_Read(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_R, 0 , 0x0, &u1ReadStaus, 1);
            while ((u1ReadStaus & 0x01) != 0x0)
            {
                Printf("wait for flash ready\n");
                u1Array[0] = 0x12;
                SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
                u1Array[0] = 0x10;
                u1Array[1] = 0x05;
                SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 2);
                u1Array[0] = 0x11;
                SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
                u1ReadStaus = 1;
                SIF_X_Read(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_R, 0 , 0x0, &u1ReadStaus, 1);
                Printf("u1ReadStaus(%d) ----\n", u1ReadStaus);
            }
            u1Array[0] = 0x12;
            SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
            //write enable
            u1Array[0] = 0x10;
            u1Array[1] = 0x06;
            SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 2);
            u1Array[0] = 0x12;
            SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
            //write data
            SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, &_au1TconFwBuf[u4WriteSize * i], u4WriteSize + 5);
            u1Array[0] = 0x12;
            SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
            u4FlashAddr += u4WriteSize;
            Printf("i (%d),u4FlashAddr(%0x)-----\n", (UINT32)i, u4FlashAddr);
        }
        x_memset(_au1TconFwBuf, 0, sizeof(_au1TconFwBuf));
        u4Length = FILE_Read(fp, &_au1TconFwBuf[5], u4ReadSize, &u8Offset);

    }

    FILE_Close(fp);
    Printf("Progrmming end----\n");

    //6.verify
    Printf("Enter 6.Verify----\n");
    fp = FILE_Open(updatefilename, O_RDONLY, 0);
    if (fp <= 0)
    {
        Printf("File open fail\n");
        return 0;
    }
    u4ReadSize = 2048;
    u8Offset = 0;
    u1Array[0] = 0x10;
    u1Array[1] = 0x03;
    u1Array[2] = 0x0;
    u1Array[3] = 0x0;
    u1Array[4] = 0x0;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 5);
    u1Array[0] = 0x11;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);

    pu1Buf = (UINT8*)x_mem_alloc(u4ReadSize);
    if (pu1Buf == NULL)
    {
        Printf("memory allocate fail!\n");
        return -1;
    }
    for (i = 0; i < 1024; i++)
    {
        u4ReadCount = SIF_X_Read(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_R, 0 , 0x0, pu1Buf, u4ReadSize);
        u4Length = FILE_Read(fp, _au1TconFwBuf, u4ReadSize, &u8Offset);
        Printf("i,sif read cnt,u4Length(%d,%d,%d).\n", i, u4ReadCount, u4Length);
        if ((u4ReadCount > 0) && (u4Length == u4ReadCount))
        {
            for (j = 0; j < u4ReadCount; j ++)
            {
                if (pu1Buf[j] != _au1TconFwBuf[j])
                {
                    Printf(" Verify not pass terminate(i,j,pu1Buf[j],_au1TconFwBuf[j] u4ReadCount)(%d,%d,%d,%d,%d)", i, j, pu1Buf[j], _au1TconFwBuf[j], u4ReadCount);
                    x_mem_free((VOID*)pu1Buf);
                    return 0;
                }
            }
        }
        else
        {
            // fail.
            Printf("read fail u4ReadCount(%d).\n", u4ReadCount);
            Printf("read fail u4Length(%d).\n", u4Length);
        }
    }
    x_mem_free((VOID*)pu1Buf);
    FILE_Close(fp);
    u1Array[0] = 0x12;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
    Printf("Verify pass----\n");

    //7.write protect
    Printf("write protect----\n");
    u1Array[0] = 0x10;
    u1Array[1] = 0x06;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 2);
    u1Array[0] = 0x12;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
    Printf("write 0x00----\n");
    u1Array[0] = 0x10;
    u1Array[1] = 0x01;
    u1Array[2] = u1StatusValue;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 3);
    u1Array[0] = 0x12;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
    Printf("write disable----\n");
    u1Array[0] = 0x10;
    u1Array[1] = 0x04;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 2);
    u1Array[0] = 0x12;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);

    //8.exit ISP mode
    Printf("exit ISP mode----\n");
    u1Array[0] = 0x24;
    SIF_X_Write(TCON_I2C_CH, TCON_UPDATE_I2C_SPEED, TCON_DEV_ADDR_W, 0, 0x0, u1Array, 1);
    return 0;
}
#endif

#ifdef LINUX_EMU_SIFSW_SUPPORT
static INT32 _SifSWInitCmd(INT32 i4Argc, const CHAR** szArgv)
{
    UINT32 u4sda, u4scl;

    if (i4Argc < 3)
    {
        Printf("Arg: SifSW gpio number: sda_number scl_number\n");
        return 0;
    }

    u4sda = (UINT32)StrToInt(szArgv[1]);
    u4scl = (UINT32)StrToInt(szArgv[2]);

    Printf("gpio 0x%x 0x%x as software I2C\n", u4sda, u4scl);

    SIFSW_Init(u4sda, u4scl);

    Printf("SIFSW_Init OK !\n");

    return 0;
}

static INT32 _SifSWRead_X_Cmd(INT32 i4Argc, const CHAR**  szArgv)
{
#define	ARGC_BASE	0
    UINT8 u1Dev;
    UINT32 u4Idx;
    UINT32 u4ClkDiv;
    UINT32 u4Addr;
    UINT32 u4Count;
    UINT8* pu1Buf;
    UINT8* pu2Buf;
    INT32 i4ReturnValue;
    UINT8 u1AddrNum;
    UINT8 u1ChannelId;

    if (i4Argc < 7)
    {
        Printf("Arg: u1ChannelId, u4ClkDiv u1Dev u1AddrNum u4Addr u4Count\n");
        return 0;
    }

    u1ChannelId = StrToInt(szArgv[ARGC_BASE + 1]);
    u4ClkDiv = StrToInt(szArgv[ARGC_BASE + 2]);
    u1Dev = (UINT8)StrToInt(szArgv[ARGC_BASE + 3]);
    u1AddrNum = StrToInt(szArgv[ARGC_BASE + 4]);
    u4Addr = StrToInt(szArgv[ARGC_BASE + 5]);
    u4Count = StrToInt(szArgv[ARGC_BASE + 6]);
    pu1Buf = (UINT8*)x_mem_alloc(u4Count);
    if (pu1Buf == NULL)
    {
        return -1;
    }
    x_memset((VOID*)pu1Buf, 0, u4Count);

    pu2Buf = pu1Buf;

    Printf("Enter software I2C READ.\n");
    i4ReturnValue = SIFSW_X_Read(u1ChannelId, u4ClkDiv, u1Dev, u1AddrNum , u4Addr, pu1Buf, u4Count);

    Printf("u1ChannelId = %X, u1Dev=0x%X, u4Addr=0x%X, u4Count=%d, i4ReturnValue=%d.\n",
           u1ChannelId,
           u1Dev,
           u4Addr,
           u4Count,
           i4ReturnValue);

    if (i4ReturnValue > 0)
    {
        // print sif read data content.
        for (u4Idx = 0; u4Idx < i4ReturnValue; u4Idx ++)
        {
            if (!(u4Idx % 8))
            {
                Printf("\n0x%08X :", u4Idx);
            }

            Printf(" 0x%02X,", pu1Buf[u4Idx]);
        }
        Printf("\n");
    }
    else
    {
        // fail.
        Printf("sif read fail.\n");
    }

    x_mem_free((VOID*)pu2Buf);

    return 0;
}

static INT32 _SifSWWrite_X_Cmd(INT32 i4Argc, const CHAR**  szArgv)
{
#define	ARGC_BASE	0
    UINT8  u1Dev;
    UINT32 u4ClkDiv;
    UINT32 u4Addr;
    UINT32 u4Count;
    UINT8* pu1Buf;
    UINT8* pu2Buf;
    INT32 i4ReturnValue;
    UINT8 u1AddrNum;
    UINT8 u1ChannelId;
    int i;

    if (i4Argc < 8)
    {
        Printf("Arg: u1ChannelId u4ClkDiv u1Dev u1AddrNum u4Addr u4Count [Data] [Data] [Data]...\n");
        return 0;
    }
    u1ChannelId = StrToInt(szArgv[ARGC_BASE + 1]);
    u4ClkDiv = StrToInt(szArgv[ARGC_BASE + 2]);
    u1Dev = (UINT8)StrToInt(szArgv[ARGC_BASE + 3]);
    u1AddrNum = StrToInt(szArgv[ARGC_BASE + 4]);
    u4Addr = StrToInt(szArgv[ARGC_BASE + 5]);
    u4Count = StrToInt(szArgv[ARGC_BASE + 6]);
    pu1Buf = (UINT8*)x_mem_alloc(u4Count);
    if (pu1Buf == NULL)
    {
        return -1;
    }

    for (  i = 0 ; i < u4Count ; i++)
    {
        pu1Buf[i] = StrToInt( szArgv[i + 7] );
    }

    pu2Buf = pu1Buf ;

    Printf("Enter software I2C WRITE.\n");
    i4ReturnValue = SIFSW_X_Write(u1ChannelId, u4ClkDiv, u1Dev, u1AddrNum , u4Addr, (UINT8*)pu1Buf, u4Count);

    if (i4ReturnValue > 0)
    {
        Printf("write successfully! byte count = %d\n", i4ReturnValue);
    }
    else if (i4ReturnValue == 0)
    {
        Printf("Warning: IOCTL should never returns ZERO.\n");
    }
    else
    {
        Printf("write fail.\n");
    }

    x_mem_free( (VOID*)pu2Buf );
    return 0;
}
#endif	// LINUX_EMU_SIFSW_SUPPORT

#if defined( CC_SUPPORT_4K2K)||defined(CC_SUPPORT_HDMI_4K2K30)
static INT32 _SifWrite_FRC_Cmd(INT32 i4Argc, const CHAR**  szArgv)
{
#define	ARGC_BASE	0
    UINT8  u1Dev;
    UINT32 u4ClkDiv;
    UINT32 u4Addr;
    UINT32 u4Count;
    UINT8* pu1Buf;
    UINT8* pu2Buf;
    INT32 i4ReturnValue;
    UINT8 u1AddrNum;
    UINT8 u1ChannelId;
    UINT8 u1Checksum = 0 ;
    int i;

    if (i4Argc < 8)
    {
        Printf("Arg: sif.frcw Data0 Data2 Data3... Data6\n");
        return 0;
    }
    u1ChannelId = 2;
    u4ClkDiv = 0x100;
    u1Dev = 0x38;
    u1AddrNum = 0 ;
    u4Addr = 0 ;
    u4Count = 7 ;
    pu1Buf = (UINT8*)x_mem_alloc(u4Count);
    if (pu1Buf == NULL)
    {
        return -1;
    }

    for (  i = 0 ; i < u4Count ; i++)
    {
        pu1Buf[i] = StrToInt( szArgv[i + 1] );
        //skip data 0
        if (i >= 1)
        {
            u1Checksum += pu1Buf[i] ;
        }
    }

    pu1Buf[0] = (pu1Buf[0] & 0xF) + ((u1Checksum & 0xF) << 4) ; //upper 4 bit ;
    Printf("Checksum = 0x%x 0x%x\n", u1Checksum, pu1Buf[0]);


    pu2Buf = pu1Buf ;
    i4ReturnValue = SIF_X_Write(u1ChannelId, u4ClkDiv, u1Dev, u1AddrNum , u4Addr, (UINT8*)pu1Buf, u4Count);

    if (i4ReturnValue > 0)
    {
        Printf("write successfully! byte count = %d\n", i4ReturnValue);
    }
    else if (i4ReturnValue == 0)
    {
        Printf("Warning: IOCTL should never returns ZERO.\n");
    }
    else
    {
        Printf("write fail.\n");
    }

    x_mem_free( (VOID*)pu2Buf );
    return 0;
}
#endif

static INT32 _EDIDReadByteCmd(INT32 i4Argc, const CHAR** szArgv)
{
    UINT8 u1EDID_ID;
    UINT8 u1SubAddr;
    INT32 i4Ret;
    UINT8 u1Tmp = 0;

    if (i4Argc < 3)
    {
        Printf("Arg: u1EDID_ID u1SubAddr \n");
        return 0;
    }

    u1EDID_ID = StrToInt(szArgv[1]);
    u1SubAddr = StrToInt(szArgv[2]);

    // initial SIF sda, scl pin.
    i4Ret = SifEDIDReadByte( u1EDID_ID, u1SubAddr, &u1Tmp );
    Printf("u1EDID_ID=0x%X, u1SubAddr=0x%X, u1Tmp=0x%X, i4Ret=%d.\n",
           u1EDID_ID,
           u1SubAddr,
           u1Tmp,
           i4Ret);

    if (!i4Ret)
    {
        Printf("Read error !\n");
    }

    return 0;
}

static INT32 _SifSCLStretchStressCmd(INT32 i4Argc, const CHAR** szArgv)
{
    UINT32 i4Ret;

    UINT32 u4SrcPtr = 0;
    UINT32 u4DstPtr = 0x2000000;
    UINT32 u4MemLen;
    UINT32 u4Offset;
    UINT32 u4EepSize = 254;
    UINT32 i, j;

    UINT32 u4ClkDiv = 0x950;
    UINT32 u4DevAddr = 0x14;
    UINT32 u4Loop = 10000;
    UINT32 u4StretchTimeMin = 67;
    UINT32 u4StretchTimeMax = 540;
    UINT32 u4TestItem = 0;
    UINT8 u1busnum = 0;//bus number
    UINT8 u1StretchTime = 100;

    if (i4Argc < 7)
    {
        Printf("%s [Bus_ID][0:Byte-level|1:Bit-level] [clkdiv] [dev_addr] [num_bytes] [num_loops] | [min_stretch_us] [max_stretch_us] |\n", szArgv);
        return -1024;
    }
    u1busnum = StrToInt(szArgv[1]);
    u4TestItem = StrToInt(szArgv[2]);
    u4ClkDiv = StrToInt(szArgv[3]);
    u4DevAddr = StrToInt(szArgv[4]);
    u4EepSize = (StrToInt(szArgv[5]) > 254) ? 254 : StrToInt(szArgv[5]);
    u4Loop = StrToInt(szArgv[6]);

    if (i4Argc > 8)
    {
        u4StretchTimeMin = StrToInt(szArgv[7]);
        u4StretchTimeMax = StrToInt(szArgv[8]);
    }

    u4SrcPtr = (UINT32)x_mem_alloc(256);
    u4DstPtr = (UINT32)x_mem_alloc(256);

    if (u4SrcPtr != 0)
    {
        x_memcpy((void*)u4SrcPtr, _au1EDID_CEC_192k_DeepColor12B_P1, 255);
    }
    else
    {
        Printf("[SIF]Src Ptr is NULL A\n");
        goto SCL_STRETCH_EXIT;
    }

    for (j = 0; j < u4Loop; j++)
    {

        Printf("SIF SCL stretch stress loop %d.\n", j + 1);
        for (i = u4StretchTimeMin ; i <= u4StretchTimeMax; i++)
        {
            u1StretchTime = (UINT8)i;

            if (u4ClkDiv != 0)
            {
                // write stretch time.
                if (u4TestItem == 0)
                {
                    Printf("Configure slave byte-level SCL stretch time to %d ms.\n", i * 10);
                    i4Ret = SIF_X_Write(u1busnum, u4ClkDiv, u4DevAddr, 1, 0xFF, &u1StretchTime, 1);
                }
                else
                {
                    Printf("Configure slave bit-level SCL stretch time to %d ms.\n", i * 10);
                    i4Ret = SIF_X_Write(u1busnum, u4ClkDiv, u4DevAddr, 1, 0xFE, &u1StretchTime, 1);
                }
                if (i4Ret != 1)
                {
                    Printf("Fail to configure slave SCL stretch time!\n");
                    goto SCL_STRETCH_EXIT;
                }
            }

            for (u4Offset = 0; u4Offset < u4EepSize; u4Offset ++)
            {
                // set length as quasi random value.
                //u4MemLen = (13 * u4Offset + 1) % (u4EepSize - u4Offset);
                u4MemLen = u4EepSize - u4Offset;

                Printf("u4SrcPtr= 0x%08X, u4Offset = %d, len = %d.\n", u4SrcPtr + u4Offset, u4Offset, u4MemLen);

                // write data.
                if (u4ClkDiv != 0)
                {
                    i4Ret = SIF_X_Write(u1busnum, u4ClkDiv, u4DevAddr, 1, u4Offset, (UINT8*)(u4SrcPtr + u4Offset), u4MemLen);
                }
                else
                {
                    i4Ret = SIF_X_Write(u1busnum, i, u4DevAddr, 1, u4Offset, (UINT8*)(u4SrcPtr + u4Offset), u4MemLen);
                }

                if (i4Ret != u4MemLen)
                {
                    Printf("Write fail. Ofst:0x%08x, Len:0x%08x.\n", u4Offset, u4MemLen);
                    goto SCL_STRETCH_EXIT;
                }

                // read data.
                if (u4DstPtr != 0)
                {
                    if (u4ClkDiv != 0)
                    {
                        i4Ret = SIF_X_Read(u1busnum, u4ClkDiv, u4DevAddr, 1, u4Offset, (UINT8*)u4DstPtr, u4MemLen);
                    }
                    else
                    {
                        i4Ret = SIF_X_Read(u1busnum, i, u4DevAddr, 1, u4Offset, (UINT8*)u4DstPtr, u4MemLen);
                    }
                }
                else
                {
                    Printf("[SIF]Dst Ptr is NULL A\n");
                    goto SCL_STRETCH_EXIT;
                }

                if (i4Ret != u4MemLen)
                {
                    Printf("Read fail.\n");
                    goto SCL_STRETCH_EXIT;
                }

                // compare data.
                if (u4DstPtr != 0)
                {
                    if(u4MemLen > 256)
                        goto SCL_STRETCH_EXIT;

                    if (0 != x_memcmp((const VOID*)(u4SrcPtr + u4Offset), (const VOID*)u4DstPtr,
                                      u4MemLen))
                    {
                        UINT32 x;

                        // Signal error
                        BIM_WRITE32(0x200, BIM_READ32(0x200) | 0x10000);

                        Printf("Compare failed!\n");
                        Printf("Src:\n");
                        for (x = 0; x < u4MemLen; x++)
                        {
                            Printf("0x%2x\t", *(UINT8*)(u4SrcPtr + u4Offset + x));
                        }
                        Printf("\nDst:\n");
                        for (x = 0; x < u4MemLen; x++)
                        {
                            Printf("0x%2x\t", *(UINT8*)(u4DstPtr + x));
                        }
                        Printf("\n");
                        goto SCL_STRETCH_EXIT;
                    }
                }
                else
                {
                    Printf("[SIF]Dst Ptr is NULL B\n");
                    goto SCL_STRETCH_EXIT;
                }
            }

        }
    }

SCL_STRETCH_EXIT:

    x_mem_free((void*)u4SrcPtr);
    x_mem_free((void*)u4DstPtr);

    Printf("%s successfully.\n", __FUNCTION__);
    return 0;
}

//-------------------------------------------------------------------------
/** _SifSCLStretchTestCmd
 *  DO SCL strectch while EEPROM read/write (stress test).
 *  @param  i4Argc		user's CLI input length.
 *  @param  szArgv		user's CLI input string.
 *  @retval  0 	SUCCESS.
 *  @retval  1	FAIL.
 */
//-------------------------------------------------------------------------
static INT32 _SifSCLStretchTestCmd(INT32 i4Argc, const CHAR** szArgv)
{
    UINT32 i4Ret;

    UINT32 u4SrcPtr = 0;
    UINT32 u4DstPtr = 0x2000000;
    UINT32 u4MemLen;
    UINT32 u4Offset;
    UINT32 u4EepSize;
    UINT32 u4loop;
    UINT32 j;

    UINT32 u4ClkDiv;
    UINT32 u4MinClockDiv = 270 >> 2;
    UINT32 u4MaxClockDiv = 270 << 2;

    u4EepSize = EEPROM_GetSize();

    if ((i4Argc != 6))
    {
        Printf("%s [min clock div] [max clock div] [num_bytes] [eeprom size] [test loop]\n", szArgv[0]);
        return 1;
    }

    if (i4Argc == 6)
    {
        u4MinClockDiv = StrToInt(szArgv[1]);
        u4MaxClockDiv = StrToInt(szArgv[2]);
        u4MemLen = StrToInt(szArgv[3]);
        u4EepSize = StrToInt(szArgv[4]);
        u4loop = StrToInt(szArgv[5]);
    }


    Printf("eep size = %d bytes.\n", u4EepSize);
    for (j = 0; j < u4loop; j++)
    {
        for (u4ClkDiv = u4MaxClockDiv; u4ClkDiv > u4MinClockDiv; u4ClkDiv--)
        {
            EEPROM_SetClkDiv(u4ClkDiv);

            u4SrcPtr = 0;
            u4DstPtr = 0x2000000;
            for (u4Offset = 0; u4Offset < (u4EepSize - u4MemLen); u4Offset += u4MemLen)
            {

                // set length as quasi random value.
                //u4MemLen = (13 * u4Offset + 1) % (u4EepSize - u4Offset);
                //u4MemLen = u4EepSize - u4Offset;

                u4MemLen = (u4MemLen == 0) ? 1 : u4MemLen;
                u4SrcPtr += u4MemLen;

                Printf("u4SrcPtr= 0x%08X, u4Offset = %d, looptimes = %d,len = %d, clkdiv = %d.\n", u4SrcPtr, u4Offset, j, u4MemLen, u4ClkDiv);

                // write data.
                i4Ret = EEPROM_Write((UINT64)u4Offset, u4SrcPtr, u4MemLen);

                if (i4Ret)
                {
                    Printf("EEPROM_Write fail. Ofst:0x%08x, looptimes:0x%08x, Len:0x%08x. ClkDiv: %d\n", u4Offset, j, u4MemLen, u4ClkDiv);
                    return 1;
                }

                // read data.
                i4Ret = EEPROM_Read((UINT64)u4Offset, u4DstPtr, u4MemLen);

                if (i4Ret)
                {
                    Printf("EepromFlash read fail. clkdiv = %d\n", u4ClkDiv);
                    return 1;
                }

                // compare data.
                if (0 != x_memcmp((const VOID*)u4SrcPtr, (const VOID*)u4DstPtr, u4MemLen))
                {
                    Printf("Compare failed. clkdiv = %d\n", u4ClkDiv);
                    return 1;
                }
            }
        }
    }

    Printf("%s successfully.\n", __FUNCTION__);
    return 0;
}

//-------------------------------------------------------------------------
/** _EEPROMCLI_Diag
 *  EEPROM read/write stress test.
 *  @param  i4Argc		user's CLI input length.
 *  @param  szArgv		user's CLI input string.
 *  @retval  0 	SUCCESS.
 *  @retval  1	FAIL.
 */
//-------------------------------------------------------------------------
static INT32 _SifSCLStretchEepromCmd(INT32 i4Argc, const CHAR** szArgv)
{
    UINT32 i4Ret;

    UINT32 u4SrcPtr = 0;
    UINT32 u4DstPtr = 0x2000000;
    UINT32 u4MemLen;
    UINT32 u4Offset;
    UINT32 u4EepSize;

    UINT32 u4ClkDiv;
    UINT32 u4MinClockDiv = 270 >> 2;
    UINT32 u4MaxClockDiv = 270 << 2;

    u4EepSize = EEPROM_GetSize();

    if ((i4Argc != 1) && (i4Argc != 3) && (i4Argc != 4))
    {
        Printf("%s [min clock div] [max clock div] [test size]\n", szArgv[0]);
        return 1;
    }

    if ((i4Argc == 3) || (i4Argc == 4))
    {
        u4MinClockDiv = StrToInt(szArgv[1]);
        u4MaxClockDiv = StrToInt(szArgv[2]);
        if (i4Argc == 4)
        {
            u4EepSize = StrToInt(szArgv[3]);
        }
    }


    Printf("eep size = %d bytes.\n", u4EepSize);

    for (u4ClkDiv = u4MaxClockDiv; u4ClkDiv > u4MinClockDiv; u4ClkDiv--)
    {
        EEPROM_SetClkDiv(u4ClkDiv);

        u4SrcPtr = 0;
        u4DstPtr = 0x2000000;

        for (u4Offset = 0; u4Offset < u4EepSize; u4Offset ++)
        {

            // set length as quasi random value.
            //u4MemLen = (13 * u4Offset + 1) % (u4EepSize - u4Offset);
            u4MemLen = u4EepSize - u4Offset;

            u4MemLen = (u4MemLen == 0) ? 1 : u4MemLen;
            u4SrcPtr += u4MemLen;

            Printf("u4SrcPtr= 0x%08X, u4Offset = %d, len = %d, clkdiv = %d.\n", u4SrcPtr, u4Offset, u4MemLen, u4ClkDiv);

            // write data.
            i4Ret = EEPROM_Write((UINT64)u4Offset, u4SrcPtr, u4MemLen);

            if (i4Ret)
            {
                Printf("EEPROM_Write fail. Ofst:0x%08x, Len:0x%08x. ClkDiv: %d\n", u4Offset, u4MemLen, u4ClkDiv);
                return 1;
            }

            // read data.
            i4Ret = EEPROM_Read((UINT64)u4Offset, u4DstPtr, u4MemLen);

            if (i4Ret)
            {
                Printf("EepromFlash read fail. clkdiv = %d\n", u4ClkDiv);
                return 1;
            }

            // compare data.
            if (0 != x_memcmp((const VOID*)u4SrcPtr, (const VOID*)u4DstPtr,
                              u4MemLen))
            {
                Printf("Compare failed. clkdiv = %d\n", u4ClkDiv);
                return 1;
            }
        }
    }

    Printf("%s successfully.\n", __FUNCTION__);
    return 0;
}


///////////////////////////////////////////////////////////////////////////////
//////////////////sif scl stretch test use, for xc5000 tuner//////////////////
///////////////////////////////////////////////////////////////////////////////
#if SIF_SCL_STRETCH_VERIFY
#define XC_MAX_I2C_WRITE_LENGTH 8
#define XC5000_I2C_ADDR 0xc2
#define XC5000_GPIO 134
#define cI2C_TIMING 270

static unsigned char XC5000_firmware_SEQUENCE[12386] =
{

    0x00, 0x00,          /* RESET */
    0x00, 0x03,          /* Length = 3 bytes */
    0x00, 0x3D, 0x00,
    0x80, 0x0A,          /* WAIT 010[ms] */
    0x00, 0x03,          /* Length = 3 bytes */
    0x00, 0x02, 0x3D,
    0x00, 0x03,          /* Length = 3 bytes */
    0x00, 0x02, 0x1F,
    0x30, 0x04,          /* Length = 12292 bytes */
    0x00, 0x28, 0x03, 0xD2, 0xD0, 0xF4, 0xF2, 0x08, 0xF2, 0x01,
    0x03, 0xED, 0xB2, 0x22, 0xF2, 0x01, 0x03, 0xF1, 0xB2, 0x22,
    0xF2, 0x01, 0x04, 0x20, 0xB2, 0x22, 0xF2, 0x01, 0x04, 0x39,
    0xB2, 0x22, 0xF2, 0x01, 0x04, 0x6B, 0xB2, 0x22, 0xF2, 0x01,
    0x04, 0x46, 0xB2, 0x22, 0xE0, 0x05, 0x17, 0xE2, 0xF2, 0x01,
    0x04, 0xB0, 0xB2, 0x22, 0xF2, 0x01, 0x04, 0x9F, 0xE0, 0x05,
    0x14, 0x3B, 0xF0, 0x19, 0x05, 0x14, 0xE0, 0x05, 0x0B, 0x29,
    0xA5, 0x55, 0xD6, 0xBE, 0xC6, 0x01, 0xE0, 0x05, 0x0B, 0x00,
    0xD2, 0x01, 0xF0, 0x2C, 0xD1, 0x5A, 0xC1, 0x03, 0xD2, 0x04,
    0xF1, 0x2C, 0xE0, 0x05, 0x14, 0xF5, 0xE0, 0x05, 0x15, 0xD6,
    0xE0, 0x05, 0x14, 0x22, 0xD1, 0xE1, 0xF1, 0x5C, 0xD1, 0x1C,
    0xC1, 0x03, 0xD2, 0x00, 0xF1, 0x2C, 0xD5, 0x14, 0xD6, 0x0C,
    0xE0, 0x05, 0x09, 0xB9, 0xE0, 0x05, 0x0C, 0x82, 0xE0, 0x05,
    0x0E, 0x2C, 0xE0, 0x05, 0x0E, 0xED, 0xE0, 0x05, 0x16, 0x2C,
    0xE0, 0x05, 0x0E, 0x12, 0xD1, 0xA5, 0xC1, 0x01, 0xD2, 0x28,
    0xF1, 0x2C, 0xD2, 0x02, 0xF0, 0x2C, 0xF0, 0x19, 0x05, 0x14,
    0xD5, 0x00, 0xC5, 0x01, 0xE0, 0x05, 0x0C, 0xFD, 0xE0, 0x05,
    0x14, 0xFE, 0xF5, 0x05, 0x05, 0x14, 0xC2, 0x20, 0xF2, 0x09,
    0xE0, 0x05, 0x0B, 0x29, 0xA5, 0x59, 0xD6, 0xBE, 0xC6, 0x01,
    0xE0, 0x05, 0x0B, 0x00, 0xE0, 0x05, 0x0E, 0x12, 0xE0, 0x05,
    0x0B, 0x21, 0xF5, 0x05, 0x04, 0x89, 0xD2, 0x03, 0xF0, 0x2C,
    0xE0, 0x05, 0x09, 0x42, 0xF5, 0x01, 0x04, 0x69, 0xD1, 0xA5,
    0xC1, 0x01, 0xF2, 0x18, 0xF2, 0x01, 0x04, 0x46, 0xB2, 0x22,
    0xF1, 0x2C, 0xF0, 0x19, 0x05, 0x14, 0xD1, 0xEB, 0xF3, 0x18,
    0xA3, 0x33, 0xD1, 0x98, 0xC1, 0x03, 0xF2, 0x18, 0x4E, 0xFE,
    0xF2, 0x01, 0x04, 0x56, 0xD1, 0x78, 0xC1, 0x03, 0xD2, 0x02,
    0xF1, 0x2C, 0xC2, 0x10, 0xF2, 0x09, 0xD2, 0x01, 0x22, 0x32,
    0x13, 0x32, 0xD1, 0xEB, 0xF1, 0x3C, 0xD1, 0x90, 0xC1, 0x03,
    0x01, 0x13, 0xF2, 0x18, 0xD1, 0x86, 0xC1, 0x01, 0xF4, 0x18,
    0x04, 0x42, 0xD1, 0x87, 0xC1, 0x01, 0xF1, 0x4C, 0xC2, 0x01,
    0xF2, 0x09, 0xF0, 0x19, 0x03, 0xF1, 0xD2, 0x04, 0xF0, 0x2C,
    0xE0, 0x05, 0x0D, 0xCD, 0xF5, 0x01, 0x04, 0x77, 0xB5, 0x52,
    0xF5, 0x01, 0x05, 0x14, 0xB5, 0x52, 0xF5, 0x01, 0x03, 0xF1,
    0xF0, 0x19, 0x04, 0x46, 0xD5, 0x20, 0xE0, 0x05, 0x0F, 0x20,
    0xD6, 0x12, 0xD1, 0x90, 0xC1, 0x01, 0xF2, 0x18, 0x82, 0x2E,
    0xF2, 0x01, 0x04, 0x82, 0xD6, 0x16, 0xD5, 0x14, 0xE0, 0x05,
    0x09, 0xB9, 0xD2, 0x06, 0xF0, 0x2C, 0xF0, 0x19, 0x04, 0x90,
    0xD2, 0x00, 0xD1, 0xFA, 0xF1, 0x2C, 0xE0, 0x05, 0x10, 0xA5,
    0xD2, 0x07, 0xF0, 0x2C, 0xD1, 0x00, 0xC1, 0xB0, 0xD2, 0x10,
    0xC2, 0x27, 0xF1, 0x2C, 0xD1, 0x00, 0xC1, 0xB4, 0xD2, 0x02,
    0xF1, 0x2C, 0xD2, 0x01, 0xD1, 0x78, 0xC1, 0x03, 0xF1, 0x2C,
    0xF0, 0x19, 0x05, 0x14, 0xE0, 0x05, 0x15, 0x2A, 0xE0, 0x05,
    0x13, 0xCD, 0xE0, 0x05, 0x10, 0xB7, 0xD0, 0xD5, 0xC0, 0x02,
    0xF1, 0x08, 0xF1, 0x01, 0x05, 0x14, 0xD1, 0x00, 0xF0, 0x1C,
    0xE0, 0x05, 0x15, 0xD6, 0xF0, 0x19, 0x05, 0x14, 0xE0, 0x05,
    0x15, 0x2A, 0xD5, 0x00, 0xE0, 0x05, 0x0B, 0x1B, 0xD0, 0x68,
    0xC0, 0x03, 0x00, 0x05, 0xF2, 0x08, 0xD4, 0xFF, 0xC4, 0x02,
    0xE0, 0x05, 0x09, 0x82, 0xB1, 0x68, 0xF1, 0x01, 0x04, 0xCE,
    0x81, 0x23, 0xA1, 0x1B, 0x11, 0x16, 0xF1, 0x01, 0x04, 0xCE,
    0xB4, 0x42, 0xF4, 0x05, 0x04, 0xBB, 0xE0, 0x05, 0x13, 0xCD,
    0xE0, 0x05, 0x10, 0xA5, 0xF0, 0x19, 0x04, 0xDF, 0xE0, 0x05,
    0x13, 0xCD, 0xD0, 0xD1, 0xC0, 0x02, 0xF2, 0x08, 0xD0, 0x00,
    0xC0, 0xB0, 0xF0, 0x2C, 0xD0, 0x00, 0xC0, 0xB4, 0xD1, 0x01,
    0x2D, 0xDE, 0xF0, 0x1C, 0xE0, 0x05, 0x10, 0xA5, 0xE0, 0x05,
    0x10, 0x3B, 0xE0, 0x05, 0x10, 0x81, 0xE0, 0x05, 0x10, 0xB7,
    0xD0, 0xD5, 0xC0, 0x02, 0xF1, 0x08, 0xF1, 0x01, 0x04, 0xEC,
    0xD1, 0x00, 0xF0, 0x1C, 0xE0, 0x05, 0x15, 0xD6, 0xE0, 0x05,
    0x09, 0x42, 0xF5, 0x05, 0x05, 0x07, 0xE0, 0x05, 0x09, 0x73,
    0xC1, 0x06, 0x5D, 0xD5, 0xF1, 0x05, 0x05, 0x07, 0xC1, 0x09,
    0x5D, 0x5D, 0xD0, 0xE7, 0xF1, 0x05, 0x05, 0x07, 0xD3, 0x14,
    0xF0, 0x3C, 0xE0, 0x05, 0x0D, 0xCD, 0xB5, 0x54, 0xF5, 0x01,
    0x05, 0x11, 0xB5, 0x52, 0xF5, 0x01, 0x05, 0x0F, 0xF0, 0x19,
    0x05, 0x14, 0xD0, 0xE7, 0xF3, 0x08, 0xB3, 0x32, 0xF0, 0x3C,
    0xF3, 0x05, 0x05, 0x14, 0xD3, 0x14, 0xF0, 0x3C, 0xE0, 0x05,
    0x0A, 0x76, 0xD1, 0x01, 0xD0, 0xF4, 0xF0, 0x1C, 0xF0, 0x0E,
    0xE0, 0x00, 0x09, 0xDF, 0xD2, 0x6E, 0xC2, 0x01, 0xD3, 0x01,
    0xF2, 0x3C, 0xE0, 0x02, 0x09, 0xE5, 0xA3, 0x01, 0xF3, 0x01,
    0x05, 0xB4, 0xB3, 0x32, 0xF3, 0x01, 0x05, 0xB0, 0xB3, 0x32,
    0xF3, 0x01, 0x05, 0xAC, 0xB3, 0x32, 0xF3, 0x01, 0x07, 0x62,
    0xB3, 0x32, 0xF3, 0x01, 0x06, 0x3D, 0xB3, 0x32, 0xF3, 0x01,
    0x05, 0xA5, 0xB3, 0x32, 0xF3, 0x01, 0x07, 0x88, 0xB3, 0x32,
    0xF3, 0x01, 0x06, 0x1C, 0xB3, 0x32, 0xF3, 0x01, 0x06, 0x6A,
    0xB3, 0x32, 0xF3, 0x01, 0x06, 0xBC, 0xB3, 0x32, 0xF3, 0x01,
    0x06, 0x18, 0xB3, 0x32, 0xF3, 0x01, 0x06, 0x72, 0xB3, 0x32,
    0xF3, 0x01, 0x06, 0x9D, 0xB3, 0x32, 0xF3, 0x01, 0x06, 0x31,
    0xB3, 0x32, 0xF3, 0x01, 0x06, 0xAE, 0xB3, 0x32, 0xF3, 0x01,
    0x06, 0xB7, 0xB3, 0x32, 0xF3, 0x01, 0x06, 0xCE, 0xB3, 0x32,
    0xF3, 0x01, 0x07, 0x68, 0xB3, 0x32, 0xF3, 0x01, 0x06, 0xCA,
    0xB3, 0x32, 0xF3, 0x01, 0x07, 0x74, 0xB3, 0x32, 0xF3, 0x01,
    0x07, 0x78, 0xB3, 0x32, 0xF3, 0x01, 0x07, 0x70, 0xB3, 0x32,
    0xF3, 0x01, 0x07, 0x6C, 0xB3, 0x32, 0xF3, 0x01, 0x06, 0x39,
    0xD4, 0x00, 0xC4, 0x80, 0x2F, 0xC4, 0xF3, 0x05, 0x05, 0xA0,
    0x84, 0x43, 0x2F, 0xC4, 0xF3, 0x01, 0x06, 0x44, 0x84, 0x4D,
    0x2F, 0xC4, 0xF3, 0x05, 0x05, 0x8C, 0x84, 0x43, 0x2F, 0xC4,
    0xF3, 0x05, 0x05, 0x96, 0x84, 0x47, 0x2F, 0xC4, 0xF3, 0x05,
    0x05, 0x82, 0x84, 0x49, 0x2F, 0xC4, 0xD2, 0xC0, 0xC2, 0x02,
    0x02, 0x23, 0xF2, 0x1C, 0xF0, 0x19, 0x07, 0xAD, 0xA4, 0x11,
    0xD2, 0xC0, 0xC2, 0x02, 0xF6, 0x28, 0xA2, 0x23, 0xF5, 0x28,
    0xE0, 0x04, 0x09, 0x9E, 0xF0, 0x19, 0x07, 0xAD, 0xA4, 0x11,
    0xE0, 0x04, 0x09, 0x90, 0xD2, 0xC0, 0xC2, 0x02, 0xF2, 0x6C,
    0xA2, 0x23, 0xF2, 0x5C, 0xF0, 0x19, 0x07, 0xAD, 0xA4, 0x11,
    0xD2, 0xC0, 0xC2, 0x02, 0xF5, 0x28, 0xA2, 0x23, 0xF6, 0x28,
    0xE0, 0x04, 0x0A, 0x23, 0xF0, 0x19, 0x07, 0xAD, 0x82, 0x06,
    0x82, 0x27, 0xF2, 0x1C, 0xF0, 0x19, 0x07, 0xAD, 0xD2, 0x93,
    0xC2, 0x01, 0xF2, 0x1C, 0xE0, 0x04, 0x0F, 0x55, 0xF0, 0x19,
    0x07, 0xAD, 0xD2, 0x7A, 0xC2, 0x01, 0xF0, 0x19, 0x06, 0xB0,
    0xD2, 0x79, 0xC2, 0x01, 0xF0, 0x19, 0x06, 0xB0, 0xF0, 0x1F,
    0xE0, 0x04, 0x0A, 0x34, 0xB3, 0x46, 0xF3, 0x05, 0x07, 0xA0,
    0xD4, 0x29, 0xD5, 0x07, 0xE0, 0x04, 0x09, 0xB9, 0xD2, 0x21,
    0xC2, 0x01, 0xD5, 0x00, 0xC5, 0x01, 0xD6, 0x21, 0xF3, 0x28,
    0xF5, 0x3C, 0xA2, 0x23, 0xA5, 0x53, 0xB6, 0x62, 0xF6, 0x05,
    0x05, 0xC3, 0xD4, 0x1A, 0xE0, 0x04, 0x0A, 0x23, 0xD3, 0x80,
    0xD2, 0xFF, 0xF2, 0x3C, 0xE0, 0x00, 0x0F, 0x31, 0xE0, 0x00,
    0x0D, 0x17, 0xE0, 0x00, 0x17, 0x61, 0xD4, 0x01, 0xD5, 0x00,
    0xE0, 0x04, 0x09, 0xB9, 0xD6, 0x00, 0xD4, 0x03, 0xD5, 0x66,
    0xE0, 0x04, 0x0A, 0x23, 0xE0, 0x04, 0x15, 0xE7, 0xE0, 0x04,
    0x17, 0xA6, 0xD6, 0x01, 0xD4, 0x03, 0xD5, 0x66, 0xE0, 0x04,
    0x0A, 0x23, 0xE0, 0x04, 0x16, 0xB4, 0xE0, 0x04, 0x10, 0xA5,
    0xD4, 0x2B, 0xE0, 0x04, 0x09, 0xB9, 0xD4, 0x00, 0xD5, 0xAF,
    0xC5, 0x01, 0xE0, 0x04, 0x0B, 0x00, 0xD5, 0xB4, 0xC5, 0x01,
    0xE0, 0x04, 0x0B, 0x00, 0xD5, 0xBB, 0xC5, 0x01, 0xE0, 0x04,
    0x0B, 0x00, 0xD5, 0xC6, 0xC5, 0x01, 0xE0, 0x04, 0x0B, 0x00,
    0xD5, 0xD0, 0xC5, 0x01, 0xE0, 0x04, 0x0B, 0x00, 0xD5, 0xD4,
    0xC5, 0x01, 0xE0, 0x04, 0x0B, 0x00, 0xD5, 0xFF, 0xD4, 0x2D,
    0xE0, 0x04, 0x09, 0xB9, 0xD5, 0x15, 0xD4, 0x0E, 0xE0, 0x04,
    0x09, 0xB9, 0xD4, 0x10, 0xD5, 0x41, 0xE0, 0x04, 0x09, 0xB9,
    0xE0, 0x04, 0x14, 0xF5, 0xF0, 0x19, 0x07, 0xA0, 0xE0, 0x00,
    0x0E, 0x1C, 0xF0, 0x19, 0x07, 0xAD, 0xD3, 0x07, 0x2C, 0xFD,
    0x91, 0x18, 0xF0, 0x01, 0x06, 0x27, 0xD2, 0x90, 0xC2, 0x03,
    0x02, 0x20, 0xF2, 0x1C, 0xF0, 0x19, 0x07, 0xAD, 0xD0, 0x06,
    0x93, 0x1F, 0xF3, 0x05, 0x06, 0x2C, 0xA0, 0x11, 0xD2, 0x98,
    0xC2, 0x03, 0xF2, 0x0C, 0xF0, 0x19, 0x07, 0xAD, 0xD2, 0x85,
    0xC2, 0x01, 0x91, 0x11, 0xF2, 0x1C, 0xE0, 0x04, 0x10, 0xC6,
    0xF0, 0x19, 0x07, 0xAD, 0xD2, 0xE4, 0xF2, 0x1C, 0xF0, 0x19,
    0x07, 0xAD, 0xD2, 0x7B, 0xC2, 0x01, 0xD3, 0x0F, 0x2F, 0xFD,
    0xF2, 0x3C, 0xF0, 0x19, 0x07, 0xAD, 0xD3, 0x0F, 0x2F, 0xCF,
    0xF3, 0x01, 0x06, 0x56, 0xB3, 0x32, 0xF3, 0x01, 0x06, 0x61,
    0xB3, 0x32, 0xF3, 0x01, 0x06, 0x5A, 0xB3, 0x32, 0xF3, 0x01,
    0x07, 0x48, 0xB3, 0x32, 0xF3, 0x01, 0x06, 0x66, 0xF0, 0x19,
    0x07, 0xAD, 0xE0, 0x00, 0x12, 0xEB, 0xF0, 0x19, 0x07, 0xA0,
    0xA9, 0x11, 0xD7, 0x0D, 0xD8, 0x20, 0xE0, 0x07, 0x0A, 0x23,
    0xF0, 0x19, 0x07, 0xAD, 0xA7, 0x11, 0xE0, 0x07, 0x11, 0xDD,
    0xF0, 0x19, 0x07, 0xAD, 0xE0, 0x07, 0x12, 0x1C, 0xF0, 0x19,
    0x07, 0xAD, 0xF0, 0x1F, 0xF1, 0x01, 0x07, 0xA0, 0xE0, 0x04,
    0x0B, 0x21, 0xA0, 0x4D, 0xF0, 0x19, 0x07, 0xA1, 0x86, 0x17,
    0xD3, 0x80, 0x2F, 0xFD, 0x93, 0x31, 0xD2, 0xAB, 0xC2, 0x01,
    0x02, 0x23, 0xF2, 0x1C, 0xF3, 0x05, 0x06, 0x8D, 0xD3, 0x01,
    0x3E, 0xE3, 0xD3, 0xCC, 0x73, 0x36, 0xD2, 0x0E, 0xC2, 0x03,
    0xF2, 0x3C, 0xD2, 0xF4, 0xC2, 0x02, 0xD3, 0x04, 0x13, 0x36,
    0xF2, 0x3C, 0xA2, 0x23, 0xB3, 0x36, 0xF2, 0x3C, 0xF0, 0x19,
    0x06, 0xB1, 0xD3, 0x01, 0x2E, 0xE3, 0x3E, 0xE3, 0xD3, 0x4A,
    0x73, 0x36, 0xD2, 0x0F, 0xC2, 0x03, 0xF2, 0x3C, 0x83, 0x33,
    0xA2, 0x23, 0xF2, 0x3C, 0x83, 0x33, 0xA2, 0x23, 0xF2, 0x3C,
    0xF0, 0x19, 0x06, 0xB1, 0xD2, 0x5A, 0xC2, 0x03, 0xD3, 0x03,
    0x24, 0xFD, 0x42, 0x34, 0xD3, 0x04, 0x2F, 0xFD, 0x81, 0x19,
    0xF2, 0x1C, 0xE0, 0x04, 0x14, 0xF5, 0xF3, 0x01, 0x07, 0xAD,
    0xE0, 0x04, 0x16, 0x3B, 0xF0, 0x19, 0x07, 0xAD, 0xD2, 0xAD,
    0xC2, 0x01, 0xF2, 0x1C, 0xE0, 0x04, 0x0B, 0xE4, 0xE0, 0x04,
    0x0B, 0x2D, 0xF0, 0x19, 0x07, 0xAD, 0xD2, 0xD0, 0xC2, 0x02,
    0xF2, 0x1C, 0xF0, 0x19, 0x07, 0xAD, 0xD2, 0x4B, 0xC2, 0x03,
    0xD3, 0x03, 0x24, 0xFD, 0x42, 0x34, 0x81, 0x17, 0xD3, 0x01,
    0x2F, 0xFD, 0x02, 0x23, 0xA2, 0x23, 0x81, 0x13, 0xF2, 0x1C,
    0xF0, 0x19, 0x07, 0xAD, 0xE0, 0x01, 0x16, 0xB4, 0xF0, 0x19,
    0x07, 0xAD, 0xD7, 0x86, 0xC7, 0x01, 0xF7, 0x1C, 0xE0, 0x04,
    0x12, 0xEB, 0xD4, 0x00, 0xE0, 0x04, 0x16, 0x16, 0xD4, 0x00,
    0xE0, 0x04, 0x0A, 0x4E, 0xE0, 0x04, 0x0A, 0x3D, 0xE0, 0x04,
    0x0A, 0x5B, 0xD4, 0x0D, 0xC4, 0xDD, 0xD7, 0xF5, 0xF3, 0x78,
    0xF3, 0x01, 0x06, 0xF1, 0xD4, 0x04, 0xB3, 0x32, 0xF3, 0x01,
    0x06, 0xED, 0xD7, 0xA3, 0xC7, 0x01, 0xF3, 0x78, 0xF3, 0x01,
    0x06, 0xED, 0xD4, 0x00, 0xE0, 0x04, 0x13, 0x36, 0xF0, 0x19,
    0x06, 0xF3, 0xE0, 0x04, 0x12, 0xC8, 0xE0, 0x04, 0x0B, 0x25,
    0x82, 0x44, 0xD4, 0x00, 0xD5, 0x01, 0xD6, 0x02, 0xD7, 0xC4,
    0xC7, 0x03, 0x07, 0x72, 0xD8, 0x20, 0xD9, 0x00, 0xE0, 0x04,
    0x12, 0x6F, 0xD4, 0x20, 0xE0, 0x04, 0x12, 0x8F, 0xA0, 0x41,
    0xE0, 0x04, 0x0A, 0x4E, 0xE0, 0x04, 0x12, 0xB0, 0xD7, 0xC5,
    0xC7, 0x02, 0xF7, 0x4C, 0xE0, 0x04, 0x0A, 0x5B, 0xD4, 0x01,
    0xD5, 0x02, 0xD6, 0x01, 0xD7, 0xC6, 0xC7, 0x03, 0x07, 0x72,
    0xD8, 0x20, 0xD9, 0x00, 0xE0, 0x04, 0x12, 0x6F, 0xD4, 0x20,
    0xE0, 0x04, 0x12, 0x8F, 0xA3, 0x41, 0xE0, 0x04, 0x0A, 0x3D,
    0xD5, 0x02, 0xD4, 0x1D, 0xE0, 0x04, 0x09, 0xB9, 0xD4, 0x00,
    0xD5, 0x02, 0xD6, 0x01, 0xD7, 0xC4, 0xC7, 0x03, 0x07, 0x72,
    0xD8, 0x08, 0xA9, 0x01, 0xE0, 0x04, 0x12, 0x6F, 0xD4, 0x08,
    0xE0, 0x04, 0x12, 0x8F, 0x00, 0x04, 0xA4, 0x01, 0xE0, 0x04,
    0x0A, 0x4E, 0xD4, 0x01, 0xD5, 0x02, 0xD6, 0x01, 0xD7, 0xC6,
    0xC7, 0x03, 0x07, 0x72, 0xD8, 0x08, 0xA9, 0x31, 0xE0, 0x04,
    0x12, 0x6F, 0xD4, 0x08, 0xE0, 0x04, 0x12, 0x8F, 0x03, 0x34,
    0xA4, 0x31, 0xE0, 0x04, 0x0A, 0x3D, 0xD7, 0xC3, 0xC7, 0x02,
    0xF7, 0x0C, 0xA7, 0x73, 0xF7, 0x3C, 0xE0, 0x04, 0x12, 0x0C,
    0xD5, 0xC6, 0xC5, 0x02, 0xD7, 0x79, 0xC7, 0x01, 0xF3, 0x58,
    0xF7, 0x3C, 0xA5, 0x53, 0xA7, 0x73, 0xF3, 0x58, 0xF7, 0x3C,
    0xA5, 0x53, 0xD7, 0x7B, 0xC7, 0x01, 0xF3, 0x58, 0xF7, 0x3C,
    0xE0, 0x04, 0x0B, 0xE4, 0xE0, 0x04, 0x0B, 0x2D, 0xD6, 0x01,
    0xD4, 0x0F, 0xD5, 0xEE, 0xE0, 0x04, 0x09, 0xFD, 0xF0, 0x1F,
    0xE0, 0x01, 0x0C, 0x2B, 0xD0, 0x01, 0xF0, 0x19, 0x07, 0xA1,
    0xE0, 0x01, 0x17, 0xB8, 0xF0, 0x19, 0x07, 0xAD, 0xE0, 0x01,
    0x0A, 0x3D, 0xF0, 0x19, 0x07, 0xAD, 0xE0, 0x01, 0x0A, 0x4E,
    0xF0, 0x19, 0x07, 0xAD, 0xE0, 0x01, 0x0A, 0x5B, 0xF0, 0x19,
    0x07, 0xAD, 0xD7, 0xAE, 0xC7, 0x01, 0xF7, 0x1C, 0xF0, 0x19,
    0x07, 0xAD, 0xE0, 0x04, 0x14, 0xF5, 0xE0, 0x04, 0x15, 0xD6,
    0xC3, 0x20, 0xF3, 0x09, 0xE0, 0x04, 0x14, 0xFE, 0xF4, 0x05,
    0x07, 0x81, 0xF0, 0x02, 0xF0, 0x1F, 0xD7, 0x5A, 0xC7, 0x03,
    0xF0, 0x78, 0xB1, 0x02, 0xA3, 0x10, 0xF3, 0x01, 0x07, 0x97,
    0xF7, 0x1C, 0xE0, 0x04, 0x07, 0x7D, 0xF1, 0x78, 0x13, 0x10,
    0xF3, 0x05, 0x07, 0x9E, 0xA1, 0x03, 0xA3, 0x18, 0xF3, 0x05,
    0x07, 0x9E, 0xF7, 0x1C, 0xE0, 0x04, 0x07, 0x7D, 0xF0, 0x19,
    0x07, 0xA3, 0xD0, 0x00, 0xD7, 0xF4, 0xF7, 0x0C, 0xD7, 0x00,
    0xC7, 0xB0, 0xD3, 0x40, 0xC3, 0x42, 0xF7, 0x3C, 0xD7, 0x00,
    0xC7, 0xB4, 0xD3, 0x0F, 0xF7, 0x3C, 0xF0, 0x1B, 0xD7, 0x6E,
    0xC7, 0x01, 0xD3, 0x00, 0xF7, 0x3C, 0xF0, 0x0E, 0xE0, 0x00,
    0x09, 0xDF, 0xA3, 0x01, 0xF3, 0x01, 0x08, 0x95, 0xB3, 0x32,
    0xF3, 0x01, 0x08, 0x82, 0xB3, 0x32, 0xF3, 0x01, 0x08, 0x7B,
    0xB3, 0x32, 0xF3, 0x01, 0x08, 0x77, 0xB3, 0x32, 0xF3, 0x01,
    0x08, 0x73, 0xB3, 0x32, 0xF3, 0x01, 0x08, 0x5A, 0xB3, 0x32,
    0xF3, 0x01, 0x08, 0x7F, 0xB3, 0x32, 0xF3, 0x01, 0x08, 0x50,
    0xB3, 0x32, 0xF3, 0x01, 0x08, 0x48, 0xB3, 0x32, 0xF3, 0x01,
    0x08, 0x4C, 0xB3, 0x32, 0xF3, 0x01, 0x08, 0x5F, 0xB3, 0x32,
    0xF3, 0x01, 0x08, 0x63, 0xB3, 0x32, 0xF3, 0x01, 0x08, 0x6F,
    0xB3, 0x32, 0xF3, 0x01, 0x08, 0x45, 0xB3, 0x32, 0xF3, 0x01,
    0x08, 0x8A, 0xB3, 0x32, 0xF3, 0x01, 0x08, 0x8E, 0xB3, 0x32,
    0xF3, 0x01, 0x08, 0x91, 0xD4, 0x00, 0xC4, 0x80, 0x2F, 0xC4,
    0xF3, 0x05, 0x08, 0x18, 0x84, 0x43, 0x2F, 0xC4, 0xF3, 0x05,
    0x08, 0x06, 0x84, 0x43, 0x2F, 0xC4, 0xF3, 0x05, 0x08, 0x0C,
    0x84, 0x45, 0x2F, 0xC4, 0xF3, 0x05, 0x08, 0x12, 0x84, 0x43,
    0x2F, 0xC4, 0xF3, 0x05, 0x08, 0x26, 0x84, 0x43, 0x2F, 0xC4,
    0xF3, 0x05, 0x08, 0x2C, 0x84, 0x43, 0x2F, 0xC4, 0xF3, 0x05,
    0x08, 0x32, 0xF0, 0x19, 0x08, 0x48, 0x13, 0x04, 0xD2, 0xC0,
    0xC2, 0x02, 0x02, 0x23, 0xF0, 0x19, 0x08, 0x92, 0x13, 0x04,
    0xD2, 0xAE, 0xC2, 0x01, 0x02, 0x23, 0xF0, 0x19, 0x08, 0x92,
    0x13, 0x04, 0xD2, 0x01, 0xC2, 0x01, 0x02, 0x23, 0xF0, 0x19,
    0x08, 0x92, 0x82, 0x06, 0x82, 0x27, 0xD3, 0xFF, 0xC3, 0x07,
    0x4F, 0xEF, 0xF3, 0x01, 0x08, 0x24, 0xD3, 0x34, 0x12, 0x23,
    0xF0, 0x20, 0xF0, 0x19, 0x08, 0x97, 0xF0, 0x19, 0x08, 0x92,
    0x13, 0x04, 0xD2, 0x4B, 0xC2, 0x03, 0x02, 0x23, 0xF0, 0x19,
    0x08, 0x92, 0x13, 0x04, 0xD2, 0x5A, 0xC2, 0x03, 0x02, 0x23,
    0xF0, 0x19, 0x08, 0x92, 0x10, 0x04, 0xB3, 0x08, 0xF3, 0x01,
    0x08, 0x3D, 0xB3, 0x06, 0xF3, 0x01, 0x08, 0x41, 0xD2, 0xE8,
    0x02, 0x20, 0xF0, 0x19, 0x08, 0x92, 0xD2, 0x43, 0xC2, 0x01,
    0xF0, 0x19, 0x08, 0x92, 0xD2, 0x42, 0xC2, 0x01, 0xF0, 0x19,
    0x08, 0x92, 0xD2, 0xEE, 0xF0, 0x19, 0x08, 0x92, 0xD0, 0x88,
    0xC0, 0x13, 0xF0, 0x19, 0x08, 0x97, 0xD2, 0x6E, 0xC2, 0x01,
    0xF0, 0x19, 0x08, 0x92, 0xD0, 0x14, 0xE0, 0x04, 0x0A, 0x34,
    0x84, 0x48, 0x1C, 0xC9, 0x84, 0x48, 0x84, 0x48, 0x1C, 0xC4,
    0xF0, 0x19, 0x08, 0x97, 0xE0, 0x00, 0x09, 0x54, 0xF0, 0x0D,
    0xF0, 0x19, 0x08, 0x97, 0xE0, 0x00, 0x09, 0x4F, 0xF0, 0x19,
    0x08, 0x97, 0xD2, 0xC3, 0xC2, 0x02, 0xF3, 0x28, 0x80, 0x38,
    0x80, 0x08, 0xA2, 0x23, 0xF3, 0x28, 0xD2, 0xFF, 0x2F, 0xFE,
    0x1C, 0xCF, 0xF0, 0x19, 0x08, 0x97, 0xD2, 0xC5, 0xC2, 0x02,
    0xF0, 0x19, 0x08, 0x92, 0xD2, 0x78, 0xC2, 0x03, 0xF0, 0x19,
    0x08, 0x92, 0xE0, 0x00, 0x09, 0x73, 0xF0, 0x19, 0x08, 0x97,
    0xE0, 0x00, 0x09, 0x82, 0xF0, 0x19, 0x08, 0x97, 0xD2, 0xF3,
    0xF0, 0x19, 0x08, 0x92, 0xE0, 0x00, 0x10, 0x3B, 0xD2, 0xF2,
    0xF0, 0x28, 0x80, 0x0D, 0x80, 0x0B, 0xF0, 0x19, 0x08, 0x97,
    0xD2, 0xD6, 0xC2, 0x02, 0xF0, 0x19, 0x08, 0x92, 0xD2, 0xE1,
    0xF0, 0x19, 0x08, 0x92, 0xD2, 0xFF, 0xF0, 0x28, 0xF0, 0x19,
    0x08, 0x97, 0xE0, 0x00, 0x09, 0x34, 0xE0, 0x00, 0x09, 0xE5,
    0xF0, 0x0E, 0xF0, 0x19, 0x08, 0xC7, 0xF0, 0x0A, 0xFB, 0x08,
    0xFB, 0x01, 0x08, 0xF0, 0xF7, 0x18, 0xF7, 0x01, 0x08, 0xAD,
    0xD8, 0x00, 0xD8, 0x0D, 0x08, 0x87, 0xF6, 0x80, 0xA8, 0x67,
    0xF9, 0x28, 0xF8, 0x94, 0x19, 0x7B, 0xF9, 0x01, 0x08, 0xF0,
    0xD8, 0x1D, 0xF8, 0x88, 0x78, 0x8B, 0xD9, 0x01, 0x2C, 0x89,
    0xF8, 0x05, 0x09, 0x29, 0xBB, 0xB2, 0xD9, 0x00, 0xC9, 0x04,
    0x28, 0xB9, 0x08, 0x58, 0xF9, 0x88, 0xF9, 0x05, 0x09, 0x0E,
    0xD9, 0x00, 0xC9, 0x04, 0x27, 0xB9, 0xD9, 0x00, 0xC9, 0xD0,
    0x07, 0x97, 0xF9, 0x78, 0xF9, 0x01, 0x08, 0xF3, 0xF9, 0x05,
    0x09, 0x1D, 0xF0, 0x0A, 0xD8, 0x15, 0xD7, 0x00, 0xC7, 0xB0,
    0xD9, 0x08, 0xDB, 0x00, 0xCB, 0x04, 0xF9, 0x01, 0x08, 0xD7,
    0xFA, 0x80, 0xF7, 0xAC, 0xB9, 0x92, 0xA8, 0x83, 0x07, 0x7B,
    0xF0, 0x19, 0x08, 0xCE, 0xD7, 0x00, 0xC7, 0xAC, 0xD8, 0x0C,
    0xF9, 0x80, 0xF7, 0x9C, 0xA8, 0x83, 0xF9, 0x80, 0xF2, 0x9C,
    0x89, 0x9D, 0x89, 0x9F, 0xD7, 0x00, 0xC7, 0x34, 0x17, 0x7B,
    0xF9, 0x01, 0x08, 0xF0, 0xA8, 0x83, 0x07, 0x7B, 0xFA, 0x80,
    0xFA, 0x01, 0x08, 0xE4, 0xFA, 0xA0, 0xF7, 0xAC, 0xB9, 0x92,
    0xF0, 0x19, 0x08, 0xE4, 0xF0, 0x06, 0xF0, 0x19, 0x08, 0xF1,
    0xDA, 0x00, 0xCA, 0x1C, 0x17, 0x8A, 0xF7, 0x9C, 0xA9, 0x93,
    0xF8, 0x9C, 0xD9, 0x0E, 0x09, 0x9B, 0xF6, 0x90, 0xA9, 0x63,
    0xFA, 0x90, 0xF4, 0xAC, 0xA9, 0x93, 0xFA, 0x90, 0xF2, 0xAC,
    0xAA, 0xA3, 0xD7, 0x00, 0xFA, 0x7C, 0xAA, 0xA3, 0xF7, 0x60,
    0xFA, 0x7C, 0xD8, 0x00, 0xC8, 0x8C, 0xAB, 0xB3, 0xF8, 0xBC,
    0xF0, 0x06, 0xF0, 0x02, 0xD9, 0x0E, 0x09, 0x9B, 0xF6, 0x90,
    0xA9, 0x63, 0xFA, 0x90, 0xF4, 0xAC, 0xA9, 0x95, 0xFA, 0x90,
    0xF2, 0xAC, 0xD8, 0x00, 0xC8, 0x8C, 0xAB, 0xB3, 0xF8, 0xBC,
    0xF0, 0x06, 0xF0, 0x02, 0xF8, 0x9C, 0xDA, 0x00, 0xCA, 0x64,
    0x07, 0x8A, 0xD9, 0x00, 0xF7, 0x9C, 0xDA, 0x00, 0xCA, 0x1C,
    0x17, 0x8A, 0xF7, 0x9C, 0xF0, 0x19, 0x09, 0x0E, 0xBB, 0xB2,
    0xD8, 0x00, 0xC8, 0x50, 0xD9, 0x00, 0xC9, 0x04, 0x48, 0x9B,
    0xD9, 0x00, 0xF8, 0x9C, 0xF0, 0x06, 0xF0, 0x02, 0xF0, 0x0E,
    0xD2, 0x09, 0xE0, 0x02, 0x09, 0xC1, 0xD0, 0x08, 0x0D, 0xFC,
    0x62, 0x30, 0x0E, 0xEC, 0x10, 0x12, 0x80, 0x04, 0xD1, 0xD3,
    0xC1, 0x02, 0xF2, 0x18, 0x60, 0x02, 0xF0, 0x02, 0xD0, 0x02,
    0xE0, 0x00, 0x09, 0xC1, 0x81, 0x1D, 0x83, 0x13, 0x82, 0x15,
    0x84, 0x17, 0x1F, 0xF4, 0x1D, 0xDE, 0xD0, 0x01, 0x2C, 0xCF,
    0x2C, 0xCD, 0xF0, 0x02, 0xD0, 0x02, 0xE0, 0x00, 0x09, 0xC1,
    0x80, 0x1D, 0xF0, 0x02, 0xD2, 0x01, 0xC2, 0x60, 0xE0, 0x02,
    0x09, 0x90, 0x92, 0x48, 0xD4, 0x1C, 0xC4, 0x03, 0xF1, 0x48,
    0x81, 0x1E, 0x11, 0x21, 0xA4, 0x10, 0xF4, 0x01, 0x09, 0x65,
    0xD4, 0x08, 0x01, 0x14, 0xF0, 0x19, 0x09, 0x68, 0xD4, 0xF8,
    0xC4, 0xFF, 0x01, 0x14, 0x91, 0x18, 0xE0, 0x03, 0x0A, 0x6D,
    0xE0, 0x04, 0x0A, 0x68, 0x10, 0x34, 0xD4, 0xFD, 0xF3, 0x48,
    0xF3, 0x0D, 0x40, 0x13, 0xF0, 0x02, 0xD2, 0x0B, 0xE0, 0x02,
    0x09, 0xC1, 0x93, 0x38, 0xD0, 0x08, 0xC0, 0x08, 0x00, 0x03,
    0x80, 0x04, 0xD2, 0xFF, 0xF1, 0x28, 0x81, 0x1E, 0x30, 0x01,
    0xA0, 0x03, 0x90, 0x02, 0xF0, 0x02, 0xD2, 0x03, 0xC2, 0x60,
    0xE0, 0x02, 0x09, 0x90, 0x80, 0x3A, 0x80, 0x0B, 0xB0, 0x02,
    0xD2, 0x0B, 0x73, 0x32, 0xD2, 0x3F, 0x2C, 0xC2, 0x84, 0x4A,
    0x1D, 0x4F, 0xF0, 0x02, 0xF0, 0x0A, 0xD2, 0x00, 0xC2, 0xA4,
    0xF2, 0x0C, 0xC2, 0xA8, 0xF1, 0x28, 0xF1, 0x01, 0x09, 0x95,
    0xC2, 0x9C, 0xF1, 0x28, 0xC2, 0xA0, 0xF2, 0x28, 0xF0, 0x06,
    0xF0, 0x02, 0xD5, 0xFF, 0xC5, 0x10, 0x2D, 0xD0, 0xD3, 0xAE,
    0xC3, 0x01, 0xF4, 0x38, 0x14, 0x45, 0xF4, 0x05, 0x09, 0xAB,
    0xA3, 0x33, 0xF3, 0x2C, 0xA3, 0x33, 0xF3, 0x1C, 0xF0, 0x0A,
    0xD3, 0x00, 0xC3, 0x9C, 0xF3, 0x1C, 0xC3, 0xA0, 0xF3, 0x2C,
    0xC3, 0xA4, 0xF3, 0x0C, 0xC3, 0xA8, 0xF4, 0x38, 0xF4, 0x01,
    0x09, 0xB4, 0xF0, 0x06, 0xF0, 0x02, 0xC0, 0x80, 0xE0, 0x00,
    0x09, 0x9E, 0xF0, 0x02, 0xC0, 0xA0, 0xE0, 0x00, 0x09, 0x9E,
    0xF0, 0x02, 0xC0, 0x20, 0xE0, 0x00, 0x09, 0x90, 0xF0, 0x02,
    0xC0, 0x70, 0xE0, 0x00, 0x09, 0x90, 0xF0, 0x02, 0xD0, 0x13,
    0xE0, 0x00, 0x09, 0xB9, 0xF0, 0x02, 0xD2, 0x91, 0xC2, 0x01,
    0xF2, 0x1C, 0xE0, 0x00, 0x09, 0xC9, 0xF0, 0x02, 0xF0, 0x0A,
    0xD1, 0x0D, 0xC1, 0x78, 0xD0, 0x00, 0xC0, 0xA4, 0xF0, 0x1C,
    0xC0, 0xA8, 0xF1, 0x08, 0xF1, 0x01, 0x09, 0xDA, 0xF0, 0x06,
    0xF0, 0x02, 0xD1, 0x00, 0xC1, 0x94, 0xF0, 0x18, 0xC1, 0x98,
    0xF1, 0x18, 0xF0, 0x02, 0xD1, 0x00, 0xC1, 0x98, 0xF1, 0x0C,
    0xF0, 0x02, 0xA2, 0x23, 0xF2, 0x0D, 0xD3, 0x0F, 0x2F, 0xDF,
    0x81, 0x19, 0xD4, 0x01, 0x2D, 0x2C, 0x64, 0x43, 0x65, 0x53,
    0x1C, 0xC4, 0x3C, 0xC5, 0x14, 0x13, 0x55, 0xDF, 0x85, 0x52,
    0xB5, 0x52, 0x03, 0x35, 0x82, 0x23, 0xF4, 0x05, 0x09, 0xEE,
    0xF0, 0x02, 0xD3, 0x00, 0xC3, 0x01, 0xF4, 0x38, 0x87, 0x03,
    0xD5, 0x01, 0x65, 0x57, 0x1C, 0xC9, 0xF3, 0x4C, 0xA3, 0x33,
    0x03, 0x30, 0xF4, 0x38, 0xA5, 0x11, 0xA6, 0x21, 0xE0, 0x04,
    0x09, 0xE9, 0xF3, 0x4C, 0xF0, 0x02, 0xD0, 0x00, 0xC0, 0x01,
    0xF1, 0x08, 0xD2, 0x00, 0xF0, 0x2C, 0xC2, 0x74, 0xA0, 0x03,
    0xF3, 0x08, 0xA0, 0x03, 0xD5, 0x01, 0x2D, 0x1D, 0xF5, 0x01,
    0x0A, 0x1E, 0xF4, 0x08, 0xE0, 0x02, 0x09, 0x9E, 0xA2, 0x23,
    0x81, 0x13, 0xF1, 0x05, 0x0A, 0x14, 0xF0, 0x02, 0xE0, 0x00,
    0x09, 0xFD, 0xE0, 0x03, 0x0A, 0x0E, 0xE0, 0x03, 0x09, 0xD3,
    0xF0, 0x02, 0x83, 0x02, 0xD4, 0xF0, 0xA5, 0x11, 0xE0, 0x03,
    0x09, 0xFD, 0xA3, 0x33, 0xA5, 0x21, 0xE0, 0x03, 0x0A, 0x23,
    0xF0, 0x02, 0xD0, 0x00, 0xC0, 0x70, 0xE0, 0x00, 0x09, 0x90,
    0xD3, 0x0F, 0x2C, 0xEF, 0x82, 0x29, 0x2D, 0xEF, 0xF0, 0x02,
    0xA2, 0x00, 0x24, 0x20, 0x11, 0x40, 0xD2, 0x0A, 0xD3, 0x50,
    0xE0, 0x02, 0x09, 0xFD, 0xD3, 0xFC, 0xA4, 0x11, 0xE0, 0x02,
    0x09, 0xFD, 0xD2, 0x0B, 0xD3, 0x10, 0x84, 0x19, 0xE0, 0x02,
    0x0A, 0x23, 0xF0, 0x02, 0xA2, 0x00, 0x24, 0x20, 0x11, 0x40,
    0xD2, 0x0A, 0xD3, 0xB6, 0xE0, 0x02, 0x09, 0xFD, 0xD2, 0x0B,
    0xD3, 0x72, 0xA4, 0x11, 0xE0, 0x02, 0x0A, 0x23, 0xF0, 0x02,
    0xA2, 0x00, 0x24, 0x20, 0x11, 0x40, 0xD2, 0x11, 0xD3, 0x20,
    0xE0, 0x02, 0x09, 0xFD, 0xD2, 0x10, 0xD3, 0xFD, 0xA4, 0x11,
    0xE0, 0x02, 0x0A, 0x23, 0xF0, 0x02, 0xD1, 0x87, 0xC1, 0x01,
    0xF0, 0x19, 0x0A, 0x6F, 0xF0, 0x02, 0xD1, 0x86, 0xC1, 0x01,
    0xF0, 0x18, 0xD1, 0xD0, 0xC1, 0x02, 0xF1, 0x18, 0xE0, 0x00,
    0x0A, 0xB0, 0xF0, 0x02, 0xD1, 0x86, 0xC1, 0x01, 0xF0, 0x18,
    0xD1, 0x87, 0xC1, 0x01, 0xF1, 0x0C, 0xF0, 0x02, 0x44, 0xDC,
    0xF4, 0x05, 0x0A, 0x94, 0xD4, 0x01, 0x7F, 0xC4, 0x7C, 0x1C,
    0x13, 0x43, 0x61, 0x13, 0xA2, 0x31, 0x6C, 0xCD, 0xB2, 0x22,
    0xA4, 0x20, 0xF4, 0x05, 0x0A, 0x86, 0xA1, 0x01, 0xD4, 0x0F,
    0x14, 0x43, 0x60, 0x04, 0x70, 0x04, 0xA4, 0x33, 0x71, 0x14,
    0xF0, 0x19, 0x0A, 0x96, 0xA1, 0x01, 0xD0, 0x00, 0xF0, 0x02,
    0xA2, 0x01, 0xA3, 0x11, 0xE0, 0x02, 0x0A, 0x7D, 0xD6, 0x08,
    0x60, 0x26, 0xD4, 0x01, 0x7D, 0x3C, 0xB5, 0x52, 0x4C, 0xE9,
    0xF4, 0x05, 0x0A, 0xA4, 0xD5, 0x08, 0x16, 0x65, 0x62, 0x35,
    0x73, 0x16, 0xE0, 0x02, 0x0A, 0x7D, 0xD4, 0xFF, 0x4C, 0x2C,
    0xF4, 0x01, 0x0A, 0xAE, 0xD2, 0xFF, 0x1C, 0xCE, 0xF0, 0x02,
    0xD6, 0xFF, 0x2E, 0xC6, 0x2C, 0x1E, 0x27, 0x24, 0xD6, 0x08,
    0x75, 0x76, 0x73, 0x06, 0x27, 0x34, 0x05, 0x57, 0x74, 0x16,
    0x27, 0x24, 0x05, 0x57, 0x85, 0x5F, 0x27, 0x34, 0x87, 0x72,
    0x00, 0x57, 0xF0, 0x02, 0x94, 0x01, 0xF4, 0x05, 0x0A, 0xC7,
    0xD0, 0x00, 0xF0, 0x19, 0x0A, 0xFA, 0xD7, 0xFF, 0xC7, 0x1F,
    0x4C, 0x0F, 0xF4, 0x01, 0x0A, 0xCD, 0xA0, 0x71, 0xD4, 0x01,
    0x7D, 0x0C, 0xD8, 0x10, 0x18, 0x85, 0xD7, 0x6B, 0xC7, 0x03,
    0xF4, 0x78, 0x28, 0x84, 0xB5, 0x56, 0x60, 0x05, 0xD5, 0x00,
    0xC5, 0x20, 0xD6, 0x0C, 0xD4, 0x00, 0xC4, 0x20, 0x04, 0x45,
    0xD1, 0x00, 0xC1, 0x20, 0x2D, 0xDC, 0xF1, 0x05, 0x0A, 0xEE,
    0x81, 0x04, 0x31, 0x14, 0xD4, 0x00, 0xC4, 0x20, 0x4C, 0x1C,
    0xF4, 0x05, 0x0A, 0xEE, 0xA0, 0x11, 0xF4, 0x78, 0x18, 0x84,
    0xF0, 0x19, 0x0A, 0xDA, 0xA7, 0x73, 0x85, 0x53, 0xB6, 0x62,
    0xF6, 0x05, 0x0A, 0xDA, 0xD4, 0x00, 0xC4, 0x20, 0x14, 0x40,
    0x84, 0x47, 0x18, 0x84, 0xA8, 0x83, 0x80, 0x83, 0xF0, 0x02,
    0x4E, 0xCD, 0xF1, 0x0D, 0x4F, 0xDC, 0x10, 0x23, 0xF0, 0x02,
    0xF3, 0x18, 0xA1, 0x13, 0xF2, 0x18, 0x41, 0x20, 0xA1, 0x13,
    0xF4, 0x18, 0xE0, 0x03, 0x09, 0x9E, 0xB2, 0x22, 0xF2, 0x05,
    0x0B, 0x04, 0xF0, 0x02, 0xD2, 0x0F, 0x83, 0x09, 0x13, 0x23,
    0x61, 0x13, 0x71, 0x13, 0x2F, 0xCE, 0x71, 0x13, 0xA0, 0x11,
    0xF0, 0x02, 0xD1, 0x7A, 0xC1, 0x01, 0xF1, 0x18, 0xE0, 0x00,
    0x0B, 0x0C, 0xF0, 0x02, 0xD1, 0x79, 0xC1, 0x01, 0xF1, 0x18,
    0xE0, 0x00, 0x0B, 0x0C, 0xF0, 0x02, 0xD0, 0x11, 0xE0, 0x00,
    0x0B, 0x1B, 0xF0, 0x02, 0xD0, 0x32, 0xE0, 0x00, 0x0B, 0x1B,
    0xF0, 0x02, 0xD0, 0xFF, 0xE0, 0x00, 0x0B, 0x1B, 0xF0, 0x02,
    0xD6, 0x10, 0xE0, 0x06, 0x0B, 0x1B, 0xD5, 0x16, 0xE0, 0x05,
    0x09, 0xB9, 0xD5, 0x65, 0xE0, 0x05, 0x0B, 0x1B, 0xD6, 0xD7,
    0xC6, 0x02, 0xE0, 0x05, 0x0B, 0x00, 0xE0, 0x05, 0x0B, 0x25,
    0x95, 0x51, 0xD6, 0x25, 0xC6, 0x03, 0xE0, 0x05, 0x0B, 0x00,
    0xE0, 0x05, 0x0B, 0x21, 0xA0, 0x51, 0xA7, 0x01, 0xD5, 0x12,
    0xD6, 0x66, 0xE0, 0x05, 0x09, 0xFD, 0xD7, 0x07, 0xF0, 0x05,
    0x0B, 0x4D, 0xD7, 0x04, 0xD6, 0xCA, 0xE0, 0x05, 0x09, 0xFD,
    0xA5, 0x01, 0xE0, 0x05, 0x16, 0xD7, 0xD7, 0x01, 0xD3, 0x04,
    0x47, 0x30, 0xD5, 0x12, 0xD6, 0x41, 0xE0, 0x05, 0x09, 0xFD,
    0xD5, 0xCC, 0xE0, 0x05, 0x0B, 0x1B, 0x3F, 0xD0, 0xD5, 0x13,
    0xD6, 0xFF, 0xE0, 0x05, 0x09, 0xFD, 0xD2, 0xAD, 0xC2, 0x01,
    0xF2, 0x28, 0xD3, 0x01, 0x3F, 0xFC, 0x2E, 0xEF, 0xA7, 0x05,
    0x17, 0x72, 0xD6, 0x20, 0xE0, 0x05, 0x09, 0xFD, 0xA7, 0x03,
    0xD6, 0x44, 0xE0, 0x05, 0x09, 0xFD, 0xA7, 0x21, 0xD5, 0x12,
    0xD6, 0x55, 0xE0, 0x05, 0x09, 0xFD, 0xD2, 0xAB, 0xC2, 0x01,
    0x02, 0x20, 0xF7, 0x28, 0xD5, 0x13, 0xD6, 0xB9, 0xE0, 0x05,
    0x09, 0xFD, 0xF0, 0x05, 0x0B, 0x81, 0xD7, 0x05, 0xD6, 0x86,
    0xE0, 0x05, 0x09, 0xFD, 0xE0, 0x05, 0x0B, 0x29, 0xD6, 0xDB,
    0xC6, 0x01, 0xE0, 0x05, 0x0B, 0x00, 0xD6, 0xFE, 0xC6, 0x02,
    0xE0, 0x05, 0x0B, 0x00, 0xD6, 0xF6, 0xC6, 0x02, 0xE0, 0x05,
    0x0B, 0x00, 0xD6, 0x00, 0xC6, 0x81, 0xF5, 0x05, 0x0B, 0x98,
    0xD6, 0x00, 0xC6, 0x01, 0xD5, 0x08, 0xE0, 0x05, 0x09, 0xBD,
    0xD5, 0x88, 0xE0, 0x05, 0x0B, 0x1B, 0xD6, 0xE3, 0xC6, 0x01,
    0xE0, 0x05, 0x0B, 0x00, 0xE0, 0x05, 0x0B, 0x21, 0xD2, 0xF1,
    0xC2, 0x02, 0xF2, 0x5C, 0xD5, 0xEE, 0xE0, 0x05, 0x0B, 0x1B,
    0x83, 0x52, 0xF3, 0x0D, 0xA3, 0x33, 0xD2, 0xFD, 0xF2, 0x3C,
    0xA7, 0x53, 0xF7, 0x0D, 0xD5, 0x08, 0xD6, 0x44, 0xE0, 0x05,
    0x09, 0xFD, 0xD5, 0xDD, 0xE0, 0x05, 0x0B, 0x1B, 0xD2, 0xFE,
    0xF2, 0x5C, 0xE0, 0x05, 0x0B, 0x25, 0xD3, 0x0E, 0x03, 0x35,
    0x03, 0x35, 0xD2, 0x88, 0xC2, 0x01, 0xF2, 0x3C, 0xE0, 0x05,
    0x17, 0x32, 0xE0, 0x05, 0x17, 0x16, 0xE0, 0x05, 0x16, 0xF3,
    0xD6, 0xFD, 0xC6, 0x01, 0xE0, 0x05, 0x0B, 0x00, 0xD6, 0xE9,
    0xC6, 0x01, 0xE0, 0x05, 0x0B, 0x00, 0xD5, 0xBB, 0xE0, 0x05,
    0x0B, 0x1B, 0xD7, 0x01, 0x67, 0x75, 0xD5, 0x00, 0xD6, 0x87,
    0xE0, 0x05, 0x0A, 0x23, 0xD5, 0xAA, 0xE0, 0x05, 0x0B, 0x1B,
    0xA7, 0x51, 0xD5, 0x03, 0xD6, 0xCC, 0xE0, 0x05, 0x0A, 0x23,
    0xE0, 0x05, 0x0E, 0x12, 0xF0, 0x02, 0xD4, 0x32, 0xE0, 0x04,
    0x0B, 0x15, 0xA5, 0x41, 0xD4, 0x1E, 0xE0, 0x04, 0x09, 0xB9,
    0xD4, 0xDD, 0xE0, 0x04, 0x0B, 0x15, 0xD5, 0xF2, 0xC5, 0x02,
    0xE0, 0x04, 0x0B, 0x00, 0xD4, 0xEE, 0xE0, 0x04, 0x0B, 0x15,
    0xD5, 0xFA, 0xC5, 0x02, 0xE0, 0x04, 0x0B, 0x00, 0xD4, 0x54,
    0xE0, 0x04, 0x0B, 0x15, 0xD2, 0xE3, 0xF2, 0x4C, 0xA5, 0x41,
    0xD4, 0x25, 0xE0, 0x04, 0x09, 0xB9, 0xD4, 0x86, 0xE0, 0x04,
    0x0B, 0x15, 0xD2, 0x12, 0xC2, 0x03, 0x02, 0x24, 0xF5, 0x28,
    0x80, 0x53, 0xD4, 0x27, 0xE0, 0x04, 0x09, 0xB9, 0xD3, 0x01,
    0x2D, 0xCF, 0x80, 0x03, 0x24, 0xCF, 0xD5, 0x0C, 0xC5, 0x03,
    0xE0, 0x04, 0x0B, 0x00, 0x80, 0x07, 0xD3, 0x02, 0x2F, 0xCF,
    0x1D, 0xDF, 0xD2, 0xE2, 0xF2, 0x1C, 0xD4, 0xFD, 0xC4, 0xFF,
    0xE0, 0x04, 0x10, 0xF8, 0xD4, 0xFF, 0xE0, 0x04, 0x0B, 0x15,
    0xD5, 0x21, 0xC5, 0x03, 0xE0, 0x04, 0x0B, 0x00, 0xE0, 0x04,
    0x10, 0xC6, 0xE0, 0x04, 0x0E, 0x12, 0xF0, 0x02, 0xD2, 0x86,
    0xC2, 0x01, 0xF2, 0x0C, 0xE0, 0x04, 0x0A, 0x76, 0x80, 0x03,
    0xD3, 0x00, 0xD2, 0xEB, 0xF2, 0x3C, 0xD2, 0x78, 0xC2, 0x03,
    0xF2, 0x3C, 0xD2, 0xF3, 0xF2, 0x3C, 0xE0, 0x04, 0x0B, 0x29,
    0xF4, 0x05, 0x0C, 0x3E, 0xD3, 0x04, 0xD2, 0xEC, 0xF2, 0x3C,
    0xE0, 0x04, 0x10, 0x28, 0xD4, 0x44, 0xE0, 0x04, 0x0B, 0x1B,
    0xF4, 0x01, 0x0C, 0x56, 0xD3, 0x80, 0xC3, 0x25, 0x4F, 0xCF,
    0xA6, 0x33, 0xD2, 0x79, 0xC2, 0x01, 0xF4, 0x28, 0xD5, 0x32,
    0xE0, 0x04, 0x09, 0xE9, 0xF2, 0x4C, 0xE0, 0x04, 0x0B, 0xE4,
    0xE0, 0x04, 0x0B, 0x2D, 0xD3, 0x80, 0xC3, 0x57, 0x4C, 0xCF,
    0xD2, 0x85, 0xC2, 0x01, 0xF3, 0x28, 0x27, 0xFC, 0xD4, 0x02,
    0xD6, 0xAA, 0xE0, 0x04, 0x09, 0xFD, 0xE0, 0x04, 0x10, 0xC6,
    0xD2, 0x6F, 0xC2, 0x01, 0xD3, 0x00, 0xF2, 0x3C, 0xF0, 0x02,
    0xD3, 0x01, 0x3F, 0xFC, 0xD1, 0x18, 0xD2, 0x88, 0xE0, 0x01,
    0x09, 0xFD, 0xF0, 0x02, 0xA3, 0x01, 0xD1, 0x15, 0xD2, 0xFE,
    0xE0, 0x01, 0x09, 0xFD, 0xD1, 0x14, 0xD2, 0x21, 0xE0, 0x01,
    0x09, 0xFD, 0x83, 0x03, 0xD1, 0x10, 0xD2, 0x00, 0xE0, 0x01,
    0x09, 0xFD, 0xD1, 0x18, 0xD2, 0x66, 0xE0, 0x01, 0x09, 0xFD,
    0xF0, 0x02, 0xE0, 0x00, 0x0A, 0x68, 0xD6, 0x88, 0xC6, 0x01,
    0xF1, 0x68, 0xD6, 0xFD, 0xF3, 0x68, 0xF3, 0x0D, 0xD7, 0x08,
    0x02, 0x07, 0x82, 0x29, 0xA6, 0x21, 0xE0, 0x06, 0x11, 0x26,
    0x42, 0x13, 0xD6, 0xFB, 0xF6, 0x2C, 0xD4, 0x00, 0xD3, 0x00,
    0xD5, 0x01, 0xD6, 0x71, 0xC6, 0x01, 0x06, 0x63, 0xF0, 0x68,
    0xD6, 0x73, 0xC6, 0x01, 0x06, 0x63, 0xF1, 0x68, 0x56, 0xEC,
    0x57, 0xDE, 0x2F, 0xFA, 0xF7, 0x05, 0x0C, 0xC4, 0xD5, 0x02,
    0xD6, 0x75, 0xC6, 0x01, 0x06, 0x63, 0xF0, 0x68, 0xD6, 0x77,
    0xC6, 0x01, 0x06, 0x63, 0xF1, 0x68, 0x56, 0xEC, 0x57, 0xDE,
    0x2F, 0xFA, 0xF7, 0x05, 0x0C, 0xC4, 0xA4, 0x43, 0x82, 0x22,
    0xD7, 0x88, 0xC7, 0x13, 0x4F, 0x2F, 0xF7, 0x05, 0x0C, 0xBB,
    0x97, 0x49, 0xF7, 0x01, 0x0C, 0x95, 0x72, 0x24, 0xD4, 0x00,
    0xA3, 0x33, 0x97, 0x33, 0xF7, 0x01, 0x0C, 0x95, 0xD3, 0x00,
    0xF0, 0x19, 0x0C, 0xDB, 0xA6, 0x51, 0xE0, 0x06, 0x0C, 0x6F,
    0xA8, 0x21, 0xD6, 0x16, 0xD7, 0xC0, 0xE0, 0x06, 0x09, 0xFD,
    0xD6, 0xF5, 0xF6, 0x4C, 0xA8, 0x41, 0xD6, 0x10, 0xD7, 0x31,
    0xE0, 0x06, 0x09, 0xFD, 0xA6, 0x31, 0xE0, 0x06, 0x0C, 0x68,
    0xE0, 0x06, 0x0C, 0xDC, 0xD6, 0x12, 0xE0, 0x06, 0x0C, 0xFD,
    0xF0, 0x02, 0xD1, 0x20, 0xD0, 0x00, 0x1C, 0xCD, 0xA4, 0x01,
    0xE0, 0x04, 0x0C, 0xF1, 0xD5, 0x20, 0xF5, 0x09, 0xE0, 0x04,
    0x11, 0x17, 0x93, 0x4F, 0xF3, 0x01, 0x0C, 0xEA, 0x3C, 0xCD,
    0x81, 0x13, 0xF1, 0x05, 0x0C, 0xDE, 0xD2, 0x70, 0xC2, 0x01,
    0xF2, 0x0C, 0xF0, 0x02, 0xA3, 0x01, 0xD1, 0x17, 0xD2, 0x83,
    0xE0, 0x01, 0x0A, 0x23, 0xD2, 0x10, 0x4F, 0xEC, 0xD2, 0x77,
    0xD1, 0x18, 0xE0, 0x01, 0x0A, 0x23, 0xF0, 0x02, 0xD2, 0x70,
    0xC2, 0x01, 0xF1, 0x28, 0xC3, 0x01, 0xF3, 0x09, 0xE0, 0x04,
    0x11, 0x17, 0x93, 0x43, 0xF3, 0x05, 0x0D, 0x0A, 0xA1, 0x13,
    0xF0, 0x19, 0x0D, 0x0F, 0xD3, 0x0E, 0x4F, 0x4F, 0xF3, 0x01,
    0x0D, 0x16, 0xB1, 0x12, 0xF2, 0x1C, 0xA4, 0x11, 0xE0, 0x04,
    0x0C, 0xF1, 0xB0, 0x02, 0xF0, 0x05, 0x0D, 0x00, 0xF0, 0x02,
    0xD0, 0x01, 0xE0, 0x00, 0x0C, 0x6F, 0xD1, 0xB9, 0xC1, 0x07,
    0xD0, 0x71, 0xC0, 0x01, 0xD2, 0x08, 0xD3, 0x3B, 0xE0, 0x00,
    0x0D, 0x3E, 0xD1, 0x96, 0xC1, 0x0B, 0xD0, 0x73, 0xC0, 0x01,
    0xD2, 0x08, 0xD3, 0x03, 0xE0, 0x00, 0x0D, 0x3E, 0xD0, 0x02,
    0xE0, 0x00, 0x0C, 0x6F, 0xD1, 0xFE, 0xC1, 0x0A, 0xD0, 0x75,
    0xC0, 0x01, 0xD2, 0x08, 0xD3, 0x3B, 0xE0, 0x00, 0x0D, 0x3E,
    0xD1, 0x82, 0xC1, 0x10, 0xD0, 0x77, 0xC0, 0x01, 0xD2, 0x08,
    0xD3, 0x03, 0xE0, 0x00, 0x0D, 0x3E, 0xF0, 0x02, 0xA5, 0x31,
    0xE0, 0x05, 0x0C, 0xF1, 0xD3, 0x00, 0xA5, 0x31, 0xE0, 0x05,
    0x0C, 0x68, 0xA5, 0x11, 0xA6, 0x21, 0xE0, 0x05, 0x0D, 0x54,
    0xF5, 0x01, 0x0D, 0x53, 0xF0, 0x5C, 0xA0, 0x03, 0xD4, 0x0A,
    0x01, 0x54, 0xA3, 0x33, 0x94, 0x33, 0xF4, 0x01, 0x0D, 0x42,
    0xF0, 0x02, 0xD3, 0x08, 0xD2, 0x00, 0xA7, 0x01, 0xD5, 0x16,
    0xD6, 0xC0, 0xE0, 0x05, 0x0A, 0x23, 0xC4, 0x01, 0xF4, 0x09,
    0xE0, 0x05, 0x11, 0x17, 0x4E, 0xD1, 0xF6, 0x05, 0x0D, 0x72,
    0x5C, 0xD1, 0xF4, 0x05, 0x0D, 0x7E, 0xF2, 0x01, 0x0D, 0x69,
    0x94, 0x33, 0x73, 0x34, 0xA2, 0x61, 0x00, 0x03, 0xD4, 0x88,
    0xC4, 0x13, 0x5C, 0x0C, 0xF4, 0x01, 0x0D, 0x56, 0xF0, 0x19,
    0x0D, 0x7D, 0xF2, 0x05, 0x0D, 0x76, 0x94, 0x33, 0x73, 0x34,
    0xA2, 0x61, 0x10, 0x03, 0xD4, 0xE8, 0xC4, 0x03, 0x5C, 0x0C,
    0xF4, 0x05, 0x0D, 0x56, 0xD0, 0x00, 0xF0, 0x02, 0xD2, 0xE2,
    0xF0, 0x28, 0xF0, 0x01, 0x0D, 0xBA, 0xB0, 0x02, 0xF0, 0x05,
    0x0D, 0xCC, 0xD2, 0xA4, 0xC2, 0x01, 0xF3, 0x28, 0xF3, 0x01,
    0x0D, 0x91, 0xD5, 0x00, 0xD4, 0x30, 0xE0, 0x04, 0x09, 0xB9,
    0xF0, 0x19, 0x0D, 0xCC, 0xD4, 0x0A, 0xE0, 0x04, 0x09, 0xC1,
    0xF5, 0x01, 0x0D, 0xCC, 0x85, 0x53, 0xD3, 0x00, 0xC3, 0x04,
    0x4D, 0xF5, 0xD3, 0x00, 0xC3, 0x40, 0x4F, 0x5F, 0x11, 0x31,
    0xF1, 0x01, 0x0D, 0xCC, 0xD2, 0xE3, 0xF0, 0x28, 0x00, 0x01,
    0xA3, 0x00, 0x20, 0x03, 0x93, 0x05, 0xF3, 0x01, 0x0D, 0xA9,
    0xD0, 0x02, 0xD2, 0xE3, 0xF3, 0x28, 0x13, 0x30, 0xF3, 0x01,
    0x0D, 0xCC, 0xF2, 0x0C, 0xA5, 0x01, 0xD4, 0x25, 0xE0, 0x04,
    0x09, 0xB9, 0xA4, 0x03, 0xD5, 0x0C, 0xC5, 0x03, 0xE0, 0x04,
    0x0B, 0x00, 0xF0, 0x19, 0x0D, 0xCC, 0xD4, 0x0A, 0xE0, 0x04,
    0x09, 0xC1, 0xF5, 0x01, 0x0D, 0xCC, 0x85, 0x53, 0xD3, 0x80,
    0xC3, 0x01, 0x4D, 0xF5, 0xD3, 0x00, 0xC3, 0x20, 0x4F, 0x5F,
    0x11, 0x31, 0xF1, 0x01, 0x0D, 0xCC, 0xA4, 0x11, 0xE0, 0x04,
    0x10, 0xF8, 0xF0, 0x02, 0xE0, 0x00, 0x09, 0x54, 0xA6, 0x01,
    0xD7, 0xC0, 0xE0, 0x06, 0x0A, 0xFB, 0xF6, 0x05, 0x0E, 0x0D,
    0xA6, 0x21, 0xD7, 0x47, 0xE0, 0x06, 0x0A, 0xFB, 0xF6, 0x01,
    0x0E, 0x10, 0xD4, 0x1C, 0xC4, 0x03, 0xF3, 0x48, 0x13, 0x36,
    0xF4, 0x3C, 0xD4, 0xFD, 0xF1, 0x48, 0x21, 0x16, 0xA6, 0x31,
    0xD7, 0x01, 0xE0, 0x06, 0x0A, 0xFB, 0xF6, 0x01, 0x0D, 0xF6,
    0xD4, 0x1C, 0xC4, 0x03, 0xD5, 0x00, 0xF4, 0x5C, 0xD4, 0x87,
    0xC4, 0x01, 0xF2, 0x48, 0xD5, 0x10, 0x42, 0x51, 0xF4, 0x2C,
    0xD0, 0x02, 0xF0, 0x19, 0x0E, 0x11, 0xD4, 0xFC, 0xF5, 0x48,
    0xF5, 0x05, 0x0E, 0x03, 0xD4, 0x91, 0xC4, 0x01, 0xF7, 0x48,
    0x07, 0x73, 0xE0, 0x06, 0x09, 0xC9, 0xD0, 0x01, 0xF0, 0x19,
    0x0E, 0x11, 0xD4, 0x92, 0xC4, 0x01, 0xF7, 0x48, 0x07, 0x73,
    0xD6, 0x15, 0xE0, 0x06, 0x09, 0xB9, 0xD0, 0x01, 0xF0, 0x19,
    0x0E, 0x11, 0xD0, 0x03, 0xF0, 0x19, 0x0E, 0x11, 0xD0, 0x00,
    0xF0, 0x02, 0xD1, 0x3D, 0xD0, 0x02, 0xE0, 0x00, 0x09, 0xB9,
    0xC1, 0x01, 0xF1, 0x09, 0xD1, 0x1F, 0xE0, 0x00, 0x09, 0xB9,
    0xF0, 0x02, 0xD4, 0x00, 0xD2, 0x00, 0xD3, 0x00, 0xE0, 0x02,
    0x0A, 0x2A, 0xA2, 0x23, 0xD1, 0x0D, 0x5D, 0xED, 0xF1, 0x01,
    0x0E, 0x1E, 0xD2, 0x0E, 0xD3, 0x10, 0xD4, 0x00, 0xE0, 0x02,
    0x0A, 0x2A, 0xF0, 0x02, 0xD1, 0x7B, 0xC1, 0x01, 0xF0, 0x18,
    0xF0, 0x05, 0x0E, 0x46, 0xD4, 0x00, 0xC4, 0x02, 0xA3, 0x41,
    0xD5, 0x03, 0x03, 0x34, 0xE0, 0x07, 0x0E, 0xD0, 0x52, 0x3C,
    0x51, 0xD3, 0x2E, 0xED, 0xF2, 0x05, 0x0E, 0x52, 0xB5, 0x52,
    0xF5, 0x05, 0x0E, 0x35, 0xE0, 0x07, 0x0B, 0x21, 0xF7, 0x01,
    0x0E, 0x98, 0xF0, 0x19, 0x0E, 0x52, 0xD1, 0x08, 0x12, 0x01,
    0xF2, 0x01, 0x0E, 0x84, 0xD1, 0x07, 0x12, 0x01, 0xF2, 0x01,
    0x0E, 0x98, 0xD1, 0x09, 0x12, 0x01, 0xF2, 0x05, 0x0E, 0x85,
    0xE0, 0x07, 0x0E, 0xD0, 0x8A, 0xA9, 0xAA, 0xA9, 0x8A, 0xA7,
    0xD7, 0x01, 0xD3, 0x80, 0xD5, 0x00, 0xD4, 0xFF, 0xC4, 0xFF,
    0xD6, 0xF0, 0xC6, 0xFF, 0x02, 0xA6, 0x91, 0x21, 0x22, 0x21,
    0x22, 0x32, 0x51, 0x2C, 0x52, 0xD2, 0x2E, 0xED, 0xF2, 0x05,
    0x0E, 0x6E, 0x06, 0x67, 0xD2, 0x10, 0x4E, 0xE6, 0xF2, 0x05,
    0x0E, 0x5E, 0xF0, 0x19, 0x0E, 0x80, 0xA5, 0x53, 0xF4, 0x0D,
    0x43, 0x54, 0xD2, 0x0C, 0x4E, 0xE5, 0xF2, 0x05, 0x0E, 0x5C,
    0x7A, 0xA7, 0x6A, 0xA7, 0xFA, 0x01, 0x0E, 0x7D, 0x87, 0x72,
    0x92, 0x79, 0xF2, 0x01, 0x0E, 0x58, 0xD0, 0xFF, 0xF0, 0x19,
    0x0E, 0x98, 0xD1, 0xFF, 0xF1, 0x3C, 0xF0, 0x19, 0x0E, 0x90,
    0xD0, 0x00, 0x92, 0x0F, 0xF2, 0x01, 0x0E, 0x8A, 0xD2, 0xF0,
    0x1C, 0xCE, 0xD2, 0x80, 0x00, 0x02, 0xD2, 0xFF, 0x2C, 0xCE,
    0xD1, 0xFF, 0xF1, 0x0C, 0xD2, 0x00, 0xD1, 0x84, 0xC1, 0x01,
    0xF1, 0x2C, 0xD1, 0xFC, 0xF1, 0x2C, 0xF0, 0x19, 0x0E, 0xCF,
    0xD2, 0x80, 0xD1, 0xFF, 0xF1, 0x2C, 0xE0, 0x07, 0x0E, 0xD0,
    0xD2, 0x40, 0x02, 0xA2, 0xD3, 0x80, 0xC3, 0xFF, 0x2F, 0xEF,
    0x52, 0x3C, 0x51, 0xD3, 0x2E, 0xED, 0xF2, 0x05, 0x0E, 0xAC,
    0xD2, 0x20, 0x02, 0xA2, 0xD3, 0xC0, 0xC3, 0xFF, 0x2F, 0xEF,
    0xD1, 0x90, 0xC1, 0x01, 0xF1, 0x3C, 0xD1, 0xFB, 0xF2, 0x18,
    0x82, 0x24, 0x13, 0x32, 0xD1, 0xFD, 0xF2, 0x18, 0x23, 0x32,
    0xD2, 0x80, 0x13, 0x23, 0xA3, 0x33, 0x93, 0x32, 0xD1, 0x84,
    0xC1, 0x01, 0xF1, 0x3C, 0xD1, 0x88, 0xC1, 0x01, 0xF2, 0x18,
    0x82, 0x22, 0x03, 0x23, 0xD2, 0x40, 0x12, 0x23, 0xF2, 0x05,
    0x0E, 0xCC, 0xD2, 0xFF, 0x12, 0x20, 0xF2, 0x05, 0x0E, 0x52,
    0xF0, 0x19, 0x0E, 0x84, 0xD2, 0x01, 0xD1, 0xFC, 0xF1, 0x2C,
    0xF0, 0x02, 0xD5, 0x31, 0xE0, 0x05, 0x0B, 0x1B, 0xD4, 0x7C,
    0xC4, 0x01, 0x04, 0x45, 0xF1, 0x48, 0x82, 0x19, 0x82, 0x29,
    0xD5, 0xFF, 0x2D, 0xD5, 0xE0, 0x05, 0x0A, 0x68, 0xA0, 0x55,
    0x80, 0x05, 0xD4, 0xFD, 0xF5, 0x48, 0xB5, 0x52, 0xF5, 0x01,
    0x0E, 0xE7, 0xA5, 0x11, 0xA1, 0x21, 0xA2, 0x51, 0x11, 0x01,
    0x02, 0x02, 0x05, 0x12, 0xA5, 0x53, 0x83, 0x53, 0xF0, 0x02,
    0xD5, 0xCC, 0xE0, 0x05, 0x0B, 0x1B, 0xF5, 0x01, 0x0E, 0xFF,
    0xD3, 0xF1, 0xC3, 0x02, 0xF6, 0x38, 0xD5, 0x1B, 0xE0, 0x05,
    0x09, 0xB9, 0xD3, 0xFF, 0xD4, 0x80, 0xF3, 0x4C, 0xE0, 0x05,
    0x0F, 0x89, 0xF0, 0x19, 0x0F, 0x11, 0xD3, 0xFC, 0xF0, 0x38,
    0xD3, 0xF1, 0xC3, 0x02, 0xF1, 0x38, 0x80, 0x06, 0x16, 0xDC,
    0xD5, 0x1B, 0xE0, 0x05, 0x09, 0xB9, 0xF0, 0x01, 0x0F, 0x0F,
    0xE0, 0x05, 0x0F, 0x9D, 0xF0, 0x19, 0x0F, 0x11, 0xE0, 0x05,
    0x0F, 0xD1, 0xD5, 0x00, 0xC5, 0x20, 0xE0, 0x05, 0x0F, 0x20,
    0xE0, 0x05, 0x0B, 0x21, 0xD6, 0x41, 0xC6, 0x03, 0xE0, 0x05,
    0x0B, 0x00, 0xE0, 0x05, 0x0F, 0x31, 0xE0, 0x05, 0x0F, 0x55,
    0xF0, 0x02, 0xD2, 0x11, 0xE0, 0x02, 0x0B, 0x1B, 0xD1, 0x19,
    0xC1, 0x03, 0x01, 0x12, 0xF4, 0x18, 0x1C, 0xC0, 0xD1, 0xF8,
    0xF3, 0x18, 0x83, 0x34, 0x83, 0x33, 0xD2, 0x2A, 0xC2, 0xE0,
    0xE0, 0x02, 0x09, 0x9E, 0xF0, 0x02, 0xD2, 0xFF, 0xF0, 0x28,
    0xD5, 0x00, 0xD3, 0x1C, 0xD4, 0x88, 0xE0, 0x03, 0x0A, 0x23,
    0xD1, 0x00, 0xB5, 0x02, 0xD4, 0xE8, 0xD3, 0x1D, 0xE0, 0x03,
    0x0A, 0x23, 0xD5, 0x0C, 0xD2, 0xA4, 0xC2, 0x01, 0xF2, 0x28,
    0xF2, 0x05, 0x0F, 0x48, 0xD2, 0x80, 0x12, 0x02, 0xF2, 0x01,
    0x0F, 0x4A, 0xD1, 0x01, 0xD5, 0x09, 0xD4, 0x30, 0xE0, 0x03,
    0x0A, 0x23, 0xC2, 0x02, 0xF2, 0x09, 0xA5, 0x11, 0xD3, 0x1C,
    0xD4, 0x88, 0xE0, 0x03, 0x0A, 0x23, 0xF0, 0x02, 0xD3, 0xFF,
    0xF0, 0x38, 0xD2, 0xC9, 0xE0, 0x02, 0x0B, 0x15, 0xD3, 0x93,
    0xC3, 0x01, 0x03, 0x32, 0xF1, 0x38, 0xD2, 0x00, 0xC2, 0x20,
    0xA3, 0x01, 0xE0, 0x02, 0x0A, 0x97, 0x81, 0x12, 0x31, 0x12,
    0xA1, 0x13, 0x81, 0x13, 0xD2, 0xCC, 0xE0, 0x02, 0x0B, 0x1B,
    0xF2, 0x01, 0x0F, 0x6F, 0xD3, 0x00, 0xF0, 0x19, 0x0F, 0x71,
    0x83, 0x12, 0xF3, 0x0D, 0xD2, 0x1C, 0xE0, 0x02, 0x09, 0xBD,
    0xD2, 0x34, 0xA3, 0x11, 0xE0, 0x02, 0x09, 0xBD, 0xE0, 0x02,
    0x0B, 0x25, 0xF2, 0x01, 0x0F, 0x80, 0xD3, 0x6A, 0xC3, 0x02,
    0xF0, 0x19, 0x0F, 0x82, 0xD3, 0x14, 0xC3, 0x02, 0xD2, 0x81,
    0x12, 0x02, 0xA4, 0x20, 0x22, 0x24, 0xE0, 0x02, 0x0B, 0x00,
    0xF0, 0x02, 0xE0, 0x00, 0x0A, 0x68, 0xD4, 0xFB, 0xF1, 0x48,
    0x81, 0x18, 0x10, 0x01, 0xA5, 0x00, 0xF5, 0x01, 0x0F, 0x93,
    0xF0, 0x0D, 0xA3, 0x09, 0x93, 0x36, 0x85, 0x36, 0x10, 0x50,
    0x85, 0x08, 0xD4, 0xF8, 0xF4, 0x5C, 0xE0, 0x02, 0x09, 0xCD,
    0xF0, 0x02, 0xE0, 0x00, 0x0A, 0x68, 0xD4, 0xFB, 0xF1, 0x48,
    0xD4, 0x84, 0xC4, 0x01, 0xF3, 0x48, 0x81, 0x18, 0x10, 0x01,
    0xD4, 0xFD, 0xF5, 0x48, 0x20, 0x05, 0x85, 0x36, 0x00, 0x05,
    0xD4, 0xFE, 0xF1, 0x48, 0xE0, 0x06, 0x0B, 0x21, 0xF6, 0x01,
    0x0F, 0xB4, 0xE0, 0x06, 0x0B, 0x25, 0xA6, 0x63, 0xD4, 0x8C,
    0xC4, 0x01, 0x04, 0x46, 0xF4, 0x48, 0xF1, 0x01, 0x0F, 0xC0,
    0xD5, 0x00, 0xC5, 0x08, 0x14, 0x54, 0x14, 0x04, 0xF0, 0x19,
    0x0F, 0xC1, 0x14, 0x40, 0xA5, 0x49, 0x87, 0x57, 0x85, 0x76,
    0x15, 0x54, 0x85, 0x58, 0xD4, 0xF8, 0xF4, 0x5C, 0xD4, 0x92,
    0xC4, 0x01, 0xF4, 0x7C, 0xD6, 0x15, 0xE0, 0x06, 0x09, 0xB9,
    0xE0, 0x02, 0x09, 0xCD, 0xF0, 0x02, 0xE0, 0x00, 0x0A, 0x68,
    0xD4, 0xFB, 0xF1, 0x48, 0x81, 0x18, 0x10, 0x01, 0xA5, 0x00,
    0xF5, 0x05, 0x0F, 0xDB, 0xF0, 0x0D, 0x80, 0x08, 0xE0, 0x06,
    0x0B, 0x25, 0xA5, 0x61, 0xE0, 0x06, 0x0B, 0x21, 0xF6, 0x05,
    0x0F, 0xFC, 0xD4, 0x99, 0xC4, 0x03, 0x04, 0x45, 0xF2, 0x48,
    0xA6, 0x01, 0xE0, 0x06, 0x10, 0x1C, 0xD4, 0xF8, 0xF4, 0x7C,
    0xA0, 0x61, 0xD4, 0xFE, 0xF1, 0x48, 0xF1, 0x01, 0x0F, 0xF6,
    0x82, 0x29, 0x82, 0x29, 0x02, 0x20, 0xF0, 0x19, 0x10, 0x19,
    0xD5, 0xFF, 0x2E, 0xE5, 0x02, 0x20, 0xF2, 0x0D, 0xF0, 0x19,
    0x10, 0x19, 0xD4, 0x9C, 0xC4, 0x03, 0x04, 0x45, 0xF2, 0x48,
    0xD4, 0xFE, 0xF1, 0x48, 0xF1, 0x01, 0x10, 0x10, 0x82, 0x23,
    0xD5, 0x80, 0xC5, 0x7F, 0x2E, 0xE5, 0x06, 0x20, 0xE0, 0x06,
    0x10, 0x1C, 0xD4, 0xF8, 0xF4, 0x7C, 0xA2, 0x61, 0xF0, 0x19,
    0x10, 0x19, 0x82, 0x28, 0x82, 0x26, 0x06, 0x20, 0xE0, 0x06,
    0x10, 0x1C, 0xD4, 0xF8, 0xF4, 0x7C, 0xA2, 0x61, 0xF2, 0x0D,
    0xE0, 0x01, 0x09, 0xCD, 0xF0, 0x02, 0xD1, 0xFF, 0xF2, 0x18,
    0xA5, 0x21, 0xA4, 0x01, 0xE0, 0x04, 0x0A, 0x7D, 0x83, 0x23,
    0x4F, 0x5F, 0x22, 0x23, 0x11, 0x52, 0x00, 0x43, 0xF0, 0x02,
    0xD0, 0xEC, 0xF1, 0x08, 0xD3, 0xED, 0xF0, 0x38, 0x10, 0x01,
    0xF0, 0x01, 0x10, 0x3A, 0xF3, 0x1C, 0xA2, 0x11, 0xD3, 0x35,
    0xC3, 0x03, 0xE0, 0x02, 0x0B, 0x00, 0x82, 0x23, 0xD3, 0xBE,
    0xC3, 0x01, 0xE0, 0x02, 0x0B, 0x00, 0xF0, 0x02, 0xD0, 0x05,
    0xC0, 0x60, 0xE0, 0x00, 0x09, 0x90, 0xA3, 0x01, 0xE0, 0x03,
    0x09, 0x90, 0xD0, 0xF8, 0xC0, 0x3F, 0x2C, 0xEC, 0xF0, 0x05,
    0x10, 0x4D, 0x82, 0x2A, 0x82, 0x2A, 0x81, 0x1D, 0x1D, 0xDE,
    0xF0, 0x19, 0x10, 0x4F, 0xD1, 0xFF, 0xC1, 0x1F, 0x82, 0x44,
    0x82, 0x25, 0xE0, 0x02, 0x0A, 0xC1, 0xD0, 0x00, 0xC0, 0x06,
    0x00, 0x02, 0xE0, 0x01, 0x0A, 0xC1, 0x81, 0x13, 0x11, 0x01,
    0x90, 0x11, 0x21, 0x10, 0xD3, 0xF2, 0xF3, 0x1C, 0xD3, 0xF3,
    0xF2, 0x38, 0x84, 0x29, 0xD0, 0x0F, 0x24, 0x40, 0x85, 0x19,
    0x04, 0x45, 0x2D, 0xDC, 0x2E, 0xEC, 0x22, 0x20, 0x02, 0x21,
    0x82, 0x29, 0x01, 0x24, 0xF3, 0x1C, 0xE0, 0x03, 0x0B, 0x29,
    0xF3, 0x01, 0x10, 0x80, 0xD2, 0x00, 0xD3, 0x9F, 0xC3, 0x03,
    0xF0, 0x38, 0x4C, 0xDC, 0xF0, 0x05, 0x10, 0x7C, 0xA2, 0x23,
    0xA3, 0x33, 0xA0, 0x26, 0xF0, 0x01, 0x10, 0x73, 0xD3, 0xEC,
    0xF3, 0x2C, 0xE0, 0x03, 0x10, 0x28, 0xF0, 0x02, 0xD1, 0xE4,
    0xF2, 0x18, 0xF2, 0x05, 0x10, 0x9C, 0xE0, 0x03, 0x0B, 0x29,
    0xF3, 0x01, 0x10, 0x9C, 0xE0, 0x00, 0x09, 0x34, 0xD2, 0xDC,
    0xC2, 0x03, 0x5E, 0xCE, 0xF2, 0x05, 0x10, 0x9C, 0xD1, 0xD4,
    0xC1, 0x02, 0xF2, 0x18, 0xF2, 0x01, 0x10, 0x99, 0xB2, 0x22,
    0xF1, 0x2C, 0xF0, 0x19, 0x10, 0xA4, 0xD3, 0x00, 0xF0, 0x19,
    0x10, 0xA2, 0xD1, 0xD4, 0xC1, 0x02, 0xD2, 0xE0, 0xC2, 0x01,
    0xF1, 0x2C, 0xD3, 0x01, 0xD1, 0xFA, 0xF1, 0x3C, 0xF0, 0x02,
    0xD1, 0xFA, 0xF0, 0x18, 0xD1, 0xD3, 0xC1, 0x02, 0xF2, 0x18,
    0x12, 0x20, 0xF2, 0x01, 0x10, 0xB6, 0xF1, 0x0C, 0xD1, 0x1D,
    0xC1, 0x03, 0xE0, 0x00, 0x0B, 0x00, 0x80, 0x02, 0xB0, 0x02,
    0xE0, 0x00, 0x10, 0xF8, 0xF0, 0x02, 0xD0, 0xD2, 0xC0, 0x02,
    0xF1, 0x08, 0xA1, 0x13, 0xD2, 0x3F, 0x2D, 0xDE, 0xF0, 0x1C,
    0xF1, 0x05, 0x10, 0xC5, 0xD2, 0x01, 0xE0, 0x02, 0x0C, 0xFD,
    0xE0, 0x02, 0x0D, 0x7F, 0xF0, 0x02, 0xD1, 0x85, 0xC1, 0x01,
    0xF2, 0x18, 0xD3, 0x03, 0x22, 0x23, 0xE0, 0x03, 0x0B, 0x21,
    0xF3, 0x01, 0x10, 0xD8, 0xA2, 0x23, 0xD3, 0x00, 0xE0, 0x03,
    0x0B, 0x1B, 0x02, 0x23, 0x93, 0x29, 0xF3, 0x01, 0x10, 0xD8,
    0xD2, 0x04, 0xD3, 0x05, 0xD0, 0xAB, 0xC0, 0x03, 0x40, 0x23,
    0xD1, 0x4C, 0xC1, 0x03, 0xD2, 0x03, 0xF5, 0x08, 0xD3, 0xFF,
    0x2F, 0x5F, 0xF1, 0x3C, 0xA1, 0x13, 0x85, 0x59, 0x85, 0x59,
    0xF1, 0x5C, 0xA0, 0x03, 0xA1, 0x15, 0xB2, 0x22, 0xF2, 0x05,
    0x10, 0xDF, 0xF5, 0x08, 0xF1, 0x5C, 0xA1, 0x13, 0xA0, 0x03,
    0xF5, 0x08, 0x83, 0x53, 0xF1, 0x3C, 0xD3, 0x02, 0xD4, 0x33,
    0xE0, 0x03, 0x09, 0xFD, 0xF0, 0x02, 0xD3, 0x7A, 0xC3, 0x01,
    0xF3, 0x38, 0xD4, 0x08, 0xC4, 0x02, 0x14, 0x43, 0xF4, 0x05,
    0x11, 0x05, 0xD2, 0x01, 0xD3, 0x6A, 0xC3, 0x03, 0xF0, 0x19,
    0x11, 0x12, 0xD3, 0x6A, 0xC3, 0x03, 0xF1, 0x38, 0x02, 0x10,
    0x94, 0x21, 0xF4, 0x05, 0x11, 0x0D, 0xD2, 0x01, 0x94, 0x27,
    0x12, 0x24, 0x14, 0x21, 0xF4, 0x01, 0x11, 0x16, 0xF3, 0x2C,
    0xD1, 0x1D, 0xE0, 0x01, 0x09, 0xB9, 0xF0, 0x02, 0xD0, 0x0B,
    0xE0, 0x00, 0x09, 0xC5, 0x82, 0x2D, 0x80, 0x2D, 0xF0, 0x02,
    0xD3, 0x20, 0x91, 0x03, 0x10, 0x01, 0x73, 0x30, 0xD2, 0x72,
    0xD1, 0x06, 0xE0, 0x01, 0x0A, 0x23, 0xF0, 0x02, 0xE0, 0x00,
    0x11, 0x89, 0xD4, 0x85, 0xC4, 0x01, 0xF5, 0x48, 0xF5, 0x01,
    0x11, 0x31, 0xE0, 0x00, 0x11, 0xA3, 0xF0, 0x19, 0x11, 0x33,
    0xE0, 0x00, 0x11, 0x96, 0xD4, 0x42, 0xC4, 0x01, 0xF4, 0x1C,
    0xD4, 0x42, 0xC4, 0x01, 0x85, 0x12, 0x04, 0x45, 0xF2, 0x48,
    0xA4, 0x43, 0xF3, 0x48, 0xA6, 0x31, 0xA7, 0x21, 0xE0, 0x06,
    0x0A, 0x97, 0x82, 0x66, 0x86, 0x68, 0x32, 0x26, 0xD6, 0x00,
    0xC6, 0x01, 0x12, 0x26, 0xA6, 0x31, 0xA7, 0x01, 0xE0, 0x06,
    0x0A, 0x97, 0xA3, 0x61, 0x83, 0x66, 0x86, 0x68, 0x33, 0x36,
    0xD6, 0x00, 0xC6, 0x01, 0x13, 0x36, 0xA6, 0x31, 0xA7, 0x21,
    0xE0, 0x06, 0x0A, 0x97, 0xD2, 0x3F, 0x22, 0x26, 0x82, 0x2D,
    0xA2, 0x25, 0x82, 0x25, 0xA8, 0x11, 0xD6, 0x02, 0xD7, 0x20,
    0xE0, 0x06, 0x0A, 0x23, 0xA6, 0x11, 0xE0, 0x06, 0x11, 0x1D,
    0xD4, 0x43, 0xC4, 0x01, 0xF4, 0x2C, 0xA8, 0x21, 0xD6, 0x02,
    0xD7, 0xFC, 0xE0, 0x06, 0x0A, 0x23, 0x88, 0x29, 0xD6, 0x03,
    0xD7, 0x10, 0xE0, 0x06, 0x0A, 0x23, 0xD8, 0x11, 0x95, 0x13,
    0xF5, 0x05, 0x11, 0x84, 0xD8, 0x07, 0xD4, 0x89, 0xC4, 0x03,
    0xF5, 0x48, 0x4D, 0x2D, 0xF5, 0x05, 0x11, 0x7F, 0xA4, 0x43,
    0xB8, 0x82, 0xF8, 0x05, 0x11, 0x77, 0x88, 0x88, 0x88, 0x88,
    0xD5, 0x8C, 0xC5, 0x08, 0x1C, 0x85, 0xD6, 0x11, 0xD7, 0xF4,
    0xE0, 0x06, 0x0A, 0x23, 0xF0, 0x02, 0xD3, 0x44, 0xC3, 0x01,
    0xF2, 0x38, 0x55, 0xEC, 0x12, 0x20, 0x40, 0x52, 0xD5, 0x0B,
    0x03, 0x35, 0xF2, 0x38, 0x55, 0xCE, 0x12, 0x20, 0x40, 0x52,
    0xF0, 0x02, 0xD1, 0x01, 0xD3, 0x45, 0xC3, 0x01, 0xF2, 0x38,
    0x45, 0xEC, 0xF5, 0x05, 0x11, 0xA2, 0xA3, 0x35, 0xA1, 0x13,
    0xA5, 0x1C, 0xF5, 0x01, 0x11, 0x99, 0xF0, 0x02, 0xD1, 0x06,
    0xD3, 0x4E, 0xC3, 0x01, 0xD4, 0x6D, 0xC4, 0x01, 0xF2, 0x38,
    0x4E, 0xCE, 0xF5, 0x48, 0x4D, 0x0D, 0x2D, 0xD2, 0xF5, 0x05,
    0x11, 0xBA, 0xB3, 0x32, 0xF5, 0x38, 0x4D, 0x0D, 0xF5, 0x05,
    0x11, 0xBA, 0xB3, 0x32, 0xB4, 0x42, 0xB1, 0x12, 0x95, 0x13,
    0xF5, 0x05, 0x11, 0xA8, 0xF0, 0x02, 0xD1, 0xF7, 0xF2, 0x18,
    0xC1, 0x11, 0xF1, 0x09, 0xD5, 0x06, 0xE0, 0x05, 0x09, 0xC5,
    0x83, 0x73, 0x84, 0x75, 0xD1, 0x01, 0x2F, 0xFD, 0x2C, 0xC1,
    0x12, 0x23, 0x02, 0x24, 0xD1, 0x0F, 0x57, 0xED, 0x11, 0x12,
    0x42, 0x71, 0x97, 0x21, 0x22, 0x27, 0xA7, 0x21, 0xD5, 0x0D,
    0xD6, 0xFC, 0xE0, 0x05, 0x0A, 0x23, 0x1D, 0x4F, 0xB0, 0x02,
    0x20, 0x01, 0xF0, 0x05, 0x11, 0xBD, 0xA0, 0x11, 0xD1, 0xF7,
    0xF1, 0x2C, 0xF0, 0x02, 0xD4, 0x1C, 0x81, 0x02, 0x14, 0x14,
    0xE0, 0x03, 0x09, 0xC9, 0xD2, 0xFB, 0xF1, 0x28, 0xA1, 0x1F,
    0xA1, 0x1F, 0x10, 0x10, 0xB5, 0x04, 0xD3, 0x0C, 0xD4, 0xB0,
    0xE0, 0x03, 0x09, 0xFD, 0xD4, 0xFC, 0xD5, 0x02, 0xE0, 0x03,
    0x09, 0xFD, 0xD5, 0x10, 0xD3, 0x19, 0xD4, 0x40, 0xE0, 0x03,
    0x09, 0xFD, 0xD5, 0x03, 0xD3, 0x00, 0xD4, 0xCB, 0xE0, 0x03,
    0x09, 0xFD, 0xC1, 0x05, 0x35, 0x01, 0xD3, 0x0D, 0xD4, 0xB4,
    0xE0, 0x03, 0x09, 0xFD, 0xD1, 0x68, 0x35, 0x01, 0xD2, 0xF7,
    0xF2, 0x5C, 0xD3, 0x0D, 0xD4, 0xFC, 0xE0, 0x03, 0x0A, 0x23,
    0xD3, 0x0F, 0xE0, 0x03, 0x11, 0xBB, 0xF0, 0x02, 0xD5, 0x00,
    0xD3, 0x19, 0xD4, 0x40, 0xE0, 0x03, 0x09, 0xFD, 0xD3, 0x0C,
    0xD4, 0xFC, 0xD5, 0x00, 0xE0, 0x03, 0x0A, 0x23, 0xD5, 0x00,
    0xD3, 0x00, 0xD4, 0xCB, 0xE0, 0x03, 0x0A, 0x23, 0xF0, 0x02,
    0xD0, 0x01, 0xE0, 0x05, 0x0E, 0x12, 0xC3, 0x02, 0xF3, 0x09,
    0xD5, 0x01, 0xC5, 0x60, 0xE0, 0x05, 0x09, 0x90, 0xD3, 0x01,
    0x7C, 0xE3, 0x66, 0x34, 0xD3, 0x35, 0x26, 0x63, 0xD5, 0x33,
    0xE0, 0x05, 0x09, 0xBD, 0xD2, 0x06, 0xC3, 0x08, 0xF3, 0x09,
    0xD5, 0x0A, 0xE0, 0x05, 0x09, 0xC1, 0xA1, 0x01, 0xA0, 0x61,
    0xB2, 0x22, 0xF2, 0x01, 0x12, 0x49, 0xF0, 0x01, 0x12, 0x2E,
    0x11, 0x01, 0xF1, 0x01, 0x12, 0x49, 0x93, 0x11, 0xF3, 0x05,
    0x12, 0x41, 0xF1, 0x0D, 0xA5, 0x01, 0xA6, 0x11, 0xE0, 0x05,
    0x0A, 0x7D, 0xD3, 0xC8, 0x4F, 0xF5, 0xF3, 0x05, 0x12, 0x2E,
    0xD4, 0xD6, 0xC4, 0x02, 0xF4, 0x0C, 0xF0, 0x02, 0xD4, 0x89,
    0xC4, 0x01, 0x12, 0x21, 0xD3, 0x03, 0xA6, 0x21, 0xF0, 0x05,
    0x12, 0x58, 0xE0, 0x06, 0x0A, 0x4E, 0xF0, 0x19, 0x12, 0x5A,
    0xE0, 0x06, 0x0A, 0x3D, 0xE0, 0x06, 0x12, 0x1C, 0x87, 0x63,
    0xA7, 0x61, 0xD6, 0xFF, 0xC6, 0x7F, 0xE0, 0x06, 0x0A, 0x97,
    0xA7, 0x61, 0x36, 0x76, 0xA6, 0x65, 0x86, 0x65, 0xF7, 0x48,
    0x07, 0x76, 0xF4, 0x7C, 0xA4, 0x43, 0x02, 0x21, 0xB3, 0x32,
    0xF3, 0x05, 0x12, 0x51, 0xF0, 0x02, 0xD8, 0x89, 0xC8, 0x01,
    0xD9, 0x00, 0xF8, 0x9C, 0xA8, 0x83, 0xF8, 0x9C, 0xA8, 0x83,
    0xF8, 0x9C, 0xA6, 0x11, 0xF7, 0x38, 0xE0, 0x07, 0x11, 0xDD,
    0xA7, 0x01, 0xA8, 0x41, 0xA9, 0x51, 0xE0, 0x07, 0x12, 0x4D,
    0xA3, 0x33, 0xB6, 0x62, 0xF6, 0x05, 0x12, 0x78, 0xD8, 0x89,
    0xC8, 0x01, 0xD6, 0x03, 0xF9, 0x88, 0x29, 0x92, 0xF8, 0x9C,
    0xA8, 0x83, 0xB6, 0x62, 0xF6, 0x05, 0x12, 0x87, 0xF0, 0x02,
    0xD7, 0x89, 0xC7, 0x01, 0xF1, 0x78, 0xA7, 0x73, 0xF3, 0x78,
    0x11, 0x13, 0xA7, 0x73, 0xF2, 0x78, 0x12, 0x23, 0xD3, 0x01,
    0x14, 0x12, 0xA6, 0x40, 0xF6, 0x05, 0x12, 0x9F, 0xF4, 0x0D,
    0xF3, 0x0D, 0x84, 0x42, 0x05, 0x12, 0xA6, 0x50, 0xA7, 0x40,
    0x2E, 0xEB, 0xF6, 0x05, 0x12, 0xA8, 0x85, 0x53, 0x84, 0x43,
    0xE0, 0x04, 0x0A, 0x97, 0x20, 0x40, 0x80, 0x0F, 0xA0, 0x09,
    0x80, 0x07, 0x20, 0x03, 0xF0, 0x02, 0xD0, 0x00, 0xD2, 0xF9,
    0xC2, 0xFF, 0xD1, 0x00, 0xD4, 0x0F, 0xA6, 0x21, 0xE0, 0x06,
    0x0A, 0x5B, 0xE0, 0x06, 0x12, 0x1C, 0x86, 0x63, 0x4F, 0x1E,
    0xF7, 0x05, 0x12, 0xC0, 0xA1, 0x61, 0xA0, 0x21, 0xA2, 0x23,
    0xB4, 0x42, 0xF4, 0x05, 0x12, 0xB5, 0xA6, 0x01, 0xE0, 0x06,
    0x0A, 0x5B, 0xF0, 0x02, 0xD4, 0x20, 0xE0, 0x04, 0x11, 0xDD,
    0xD3, 0x00, 0xD2, 0x00, 0xD4, 0x00, 0xE0, 0x04, 0x13, 0x36,
    0xE0, 0x04, 0x12, 0x1C, 0x81, 0x43, 0xA2, 0x23, 0x80, 0x02,
    0xD5, 0x00, 0xC5, 0x80, 0x2D, 0xD0, 0xF5, 0x01, 0x12, 0xE5,
    0xA4, 0x21, 0xE0, 0x04, 0x13, 0x36, 0xE0, 0x04, 0x12, 0x1C,
    0x84, 0x43, 0x4D, 0x1C, 0xF5, 0x05, 0x12, 0xE5, 0xA1, 0x41,
    0xA3, 0x21, 0xF0, 0x05, 0x12, 0xD3, 0xA4, 0x31, 0xE0, 0x04,
    0x13, 0x36, 0xF0, 0x02, 0xF0, 0x1F, 0xE0, 0x03, 0x0B, 0x25,
    0x93, 0x31, 0x83, 0x34, 0xD2, 0xC6, 0xC2, 0x02, 0xD0, 0x79,
    0xC0, 0x01, 0xF1, 0x08, 0xF2, 0x1C, 0xD1, 0x02, 0xC1, 0x90,
    0x1D, 0xDF, 0xF0, 0x1C, 0xA2, 0x23, 0xA0, 0x03, 0xF1, 0x08,
    0xF2, 0x1C, 0xD1, 0xBC, 0xC1, 0x55, 0xF0, 0x1C, 0xA2, 0x23,
    0xD0, 0x7B, 0xC0, 0x01, 0xF1, 0x08, 0xF2, 0x1C, 0xD1, 0x08,
    0xF0, 0x1C, 0xE0, 0x03, 0x0B, 0xE4, 0xE0, 0x03, 0x0B, 0x2D,
    0xE0, 0x03, 0x0A, 0x76, 0xE0, 0x03, 0x0C, 0x82, 0xE0, 0x03,
    0x0E, 0x2C, 0xE0, 0x03, 0x0E, 0xED, 0xD5, 0x00, 0xD3, 0x0F,
    0xD4, 0xEE, 0xE0, 0x03, 0x09, 0xFD, 0xD5, 0x00, 0xD3, 0x0D,
    0xD4, 0x20, 0xE0, 0x03, 0x0A, 0x23, 0xD3, 0x00, 0xE0, 0x03,
    0x11, 0x1D, 0xD3, 0x02, 0xD4, 0xFE, 0xC4, 0x02, 0xE0, 0x03,
    0x0B, 0x00, 0xD3, 0x00, 0xC3, 0x02, 0xE0, 0x03, 0x0C, 0xFD,
    0xD1, 0x00, 0xD0, 0xFA, 0xF0, 0x1C, 0xD0, 0xF8, 0xF0, 0x1C,
    0xE0, 0x03, 0x10, 0xA5, 0xD3, 0x00, 0xC3, 0x20, 0xE0, 0x03,
    0x0F, 0x20, 0xF0, 0x02, 0xA3, 0x01, 0xD1, 0x10, 0xD2, 0x74,
    0xE0, 0x01, 0x0A, 0x23, 0xF0, 0x02, 0xD1, 0xA6, 0xC1, 0x01,
    0x01, 0x10, 0xF4, 0x18, 0x81, 0x49, 0xD2, 0x02, 0xD3, 0x74,
    0xE0, 0x02, 0x09, 0xFD, 0xA4, 0x11, 0xD2, 0x03, 0xD3, 0xAA,
    0xE0, 0x02, 0x09, 0xFD, 0x84, 0x19, 0xD3, 0xFD, 0xE0, 0x02,
    0x09, 0xFD, 0xF0, 0x02, 0xA1, 0x01, 0xD2, 0x00, 0xD3, 0x01,
    0xD5, 0x7A, 0xC5, 0x03, 0xF6, 0x58, 0x4C, 0xE0, 0xF4, 0x05,
    0x13, 0x64, 0xD2, 0x01, 0x10, 0x06, 0xD5, 0x7B, 0xC5, 0x03,
    0xF6, 0x58, 0xD4, 0x30, 0x04, 0x64, 0x4C, 0xC0, 0xF4, 0x05,
    0x13, 0x64, 0xD3, 0x00, 0x10, 0x06, 0xD5, 0x85, 0xC5, 0x01,
    0xF4, 0x58, 0xF4, 0x01, 0x13, 0x82, 0xD5, 0x43, 0xC5, 0x01,
    0xF4, 0x58, 0xD6, 0xB3, 0x24, 0x46, 0xD6, 0x00, 0xC6, 0x08,
    0x06, 0x64, 0x66, 0x62, 0x86, 0x6B, 0x86, 0x6B, 0xD2, 0x08,
    0xD5, 0x42, 0xC5, 0x01, 0xF4, 0x58, 0xB4, 0x42, 0xF4, 0x01,
    0x13, 0x7C, 0xD2, 0x0F, 0x4C, 0xE2, 0xF4, 0x01, 0x13, 0x8E,
    0xA6, 0x21, 0xF0, 0x19, 0x13, 0x8E, 0xD5, 0x42, 0xC5, 0x01,
    0xF4, 0x58, 0x94, 0x43, 0x84, 0x42, 0x02, 0x24, 0x82, 0x24,
    0xD4, 0x84, 0xC4, 0xF8, 0x76, 0x42, 0xD5, 0x0F, 0x2E, 0xE9,
    0xD5, 0xE8, 0xF5, 0x6C, 0xD4, 0x03, 0xD5, 0x52, 0xE0, 0x04,
    0x09, 0xFD, 0xA6, 0x31, 0xD5, 0xE9, 0xF5, 0x6C, 0xD4, 0x03,
    0xD5, 0x77, 0xE0, 0x04, 0x09, 0xFD, 0xD6, 0x80, 0x4C, 0xE0,
    0xF4, 0x05, 0x13, 0xA4, 0x10, 0x06, 0xD5, 0x7C, 0xC5, 0x03,
    0xF6, 0x58, 0x00, 0x06, 0xD5, 0xEA, 0xF5, 0x0C, 0xA6, 0x01,
    0xD5, 0xF8, 0xD4, 0x06, 0xE0, 0x04, 0x09, 0xFD, 0xF0, 0x02,
    0xA2, 0x01, 0xD0, 0x0E, 0xD1, 0xB9, 0xE0, 0x00, 0x09, 0xFD,
    0xF0, 0x02, 0x82, 0x09, 0xF2, 0x05, 0x13, 0xBA, 0x81, 0x05,
    0xD2, 0x03, 0x25, 0xCE, 0xF0, 0x19, 0x13, 0xC4, 0xD1, 0x0C,
    0x15, 0x01, 0x82, 0x59, 0xF2, 0x01, 0x13, 0xC3, 0xB5, 0x58,
    0xA1, 0x19, 0xF0, 0x19, 0x13, 0xBC, 0x81, 0x15, 0xD3, 0x0E,
    0xD4, 0xFC, 0xE0, 0x03, 0x09, 0xFD, 0xA5, 0x11, 0xD4, 0x75,
    0xE0, 0x03, 0x09, 0xFD, 0xF0, 0x02, 0xE0, 0x00, 0x14, 0x22,
    0xD5, 0xE1, 0xF4, 0x58, 0xF5, 0x0C, 0x4E, 0x0C, 0xF6, 0x05,
    0x13, 0xE4, 0x4E, 0xC0, 0xF6, 0x01, 0x14, 0x04, 0x14, 0x40,
    0xD3, 0x01, 0xE0, 0x03, 0x14, 0x05, 0xA1, 0x31, 0xD3, 0x08,
    0xE0, 0x03, 0x09, 0xC1, 0x31, 0x14, 0x81, 0x14, 0xF0, 0x19,
    0x13, 0xEE, 0xD3, 0x00, 0x14, 0x04, 0xE0, 0x03, 0x14, 0x05,
    0xA1, 0x31, 0xD3, 0x08, 0xE0, 0x03, 0x09, 0xC1, 0x31, 0x14,
    0x81, 0x14, 0xD2, 0x40, 0xD3, 0x00, 0xE0, 0x03, 0x09, 0x90,
    0xB2, 0x22, 0xF2, 0x01, 0x13, 0xFC, 0xD3, 0x00, 0xE0, 0x03,
    0x09, 0x90, 0xD6, 0x04, 0x2C, 0xCA, 0xF4, 0x01, 0x13, 0xF2,
    0xA4, 0x11, 0xD3, 0x0F, 0xE0, 0x03, 0x09, 0xBD, 0xE0, 0x03,
    0x09, 0xD3, 0xE0, 0x03, 0x16, 0x3B, 0xF0, 0x02, 0xD3, 0x00,
    0xC3, 0x20, 0xF0, 0x05, 0x14, 0x10, 0xD3, 0x5B, 0xC3, 0x0B,
    0xD4, 0x00, 0xC4, 0x09, 0x11, 0x41, 0xA4, 0x10, 0x21, 0x14,
    0xA5, 0x11, 0xD6, 0xC0, 0xE0, 0x05, 0x0A, 0x7D, 0xD4, 0x60,
    0x4C, 0xE8, 0x05, 0x54, 0xD2, 0xE3, 0xC2, 0x22, 0xF5, 0x01,
    0x14, 0x20, 0x33, 0x32, 0x83, 0x34, 0xB5, 0x52, 0xF0, 0x19,
    0x14, 0x19, 0xA0, 0x31, 0xF0, 0x02, 0xD4, 0x5A, 0xC4, 0x03,
    0xF2, 0x48, 0x95, 0x25, 0xB2, 0x24, 0x22, 0x25, 0xD0, 0x80,
    0xC0, 0xFB, 0x20, 0x02, 0xD1, 0x04, 0xF2, 0x48, 0xA4, 0x45,
    0xF3, 0x48, 0xA4, 0x43, 0x40, 0x23, 0xB1, 0x12, 0xF1, 0x05,
    0x14, 0x2C, 0xF0, 0x02, 0xA2, 0x01, 0xE0, 0x02, 0x15, 0x97,
    0xE0, 0x01, 0x0A, 0x7D, 0xF0, 0x02, 0xD6, 0x0F, 0xE0, 0x06,
    0x09, 0xC5, 0xD4, 0xFF, 0x20, 0xC4, 0x81, 0x79, 0x81, 0x19,
    0x22, 0xFC, 0xD3, 0x57, 0xC3, 0x03, 0xF5, 0x38, 0x10, 0x05,
    0x94, 0x01, 0x20, 0x04, 0xA3, 0x33, 0xF5, 0x38, 0x11, 0x15,
    0x94, 0x11, 0x21, 0x14, 0xA3, 0x33, 0xF5, 0x38, 0x12, 0x25,
    0x94, 0x21, 0x22, 0x24, 0xD3, 0x4B, 0xC3, 0x03, 0xF3, 0x0C,
    0xA3, 0x37, 0xF3, 0x1C, 0xA3, 0x37, 0xF3, 0x2C, 0xA3, 0x37,
    0xE0, 0x06, 0x09, 0x34, 0xF3, 0x6C, 0xF0, 0x02, 0xD6, 0xFF,
    0xC6, 0x7F, 0xF0, 0x05, 0x14, 0x6B, 0xD4, 0x5A, 0xC4, 0x03,
    0xF5, 0x48, 0x95, 0x55, 0xF5, 0x01, 0x14, 0x6B, 0xD6, 0xCC,
    0xC6, 0x4C, 0xD4, 0x4B, 0xC4, 0x03, 0xD5, 0x03, 0x44, 0x05,
    0xF2, 0x48, 0xA4, 0x43, 0xF1, 0x48, 0xA4, 0x43, 0xF3, 0x48,
    0x33, 0x36, 0x4D, 0xED, 0x45, 0xFE, 0x11, 0x51, 0xF0, 0x02,
    0xD3, 0x4B, 0xC3, 0x03, 0xD4, 0x03, 0x43, 0x04, 0xF1, 0x38,
    0xA3, 0x33, 0xF2, 0x38, 0x44, 0xDE, 0xF4, 0x05, 0x14, 0x9B,
    0xA5, 0x11, 0xE0, 0x05, 0x0A, 0xC1, 0xA1, 0x51, 0xA5, 0x21,
    0xE0, 0x05, 0x0A, 0xC1, 0x16, 0x51, 0xD4, 0x00, 0xC4, 0x03,
    0x4C, 0xE8, 0xF4, 0x01, 0x14, 0x92, 0xD6, 0x00, 0xC6, 0x03,
    0xA5, 0x01, 0xE0, 0x05, 0x14, 0x35, 0xA1, 0x61, 0xF1, 0x05,
    0x14, 0xBF, 0xA1, 0x13, 0xF0, 0x19, 0x14, 0xBF, 0xA3, 0x33,
    0xF2, 0x38, 0x44, 0xED, 0xF4, 0x05, 0x14, 0xBD, 0xA5, 0x11,
    0xE0, 0x05, 0x0A, 0xC1, 0xA1, 0x51, 0xA5, 0x21, 0xE0, 0x05,
    0x0A, 0xC1, 0x16, 0x15, 0xD4, 0x00, 0xC4, 0x03, 0x4C, 0xE8,
    0xF4, 0x01, 0x14, 0xB3, 0xD3, 0xD5, 0xC3, 0x02, 0xD4, 0x01,
    0xF3, 0x4C, 0xD6, 0x00, 0xC6, 0x03, 0xA5, 0x01, 0xE0, 0x05,
    0x14, 0x35, 0xA1, 0x61, 0xF1, 0x0D, 0xF1, 0x05, 0x14, 0xBF,
    0xB1, 0x12, 0xF0, 0x19, 0x14, 0xBF, 0xD1, 0x00, 0xD6, 0x00,
    0xF0, 0x02, 0xD4, 0x5A, 0xC4, 0x03, 0xD5, 0x03, 0x44, 0x05,
    0xF3, 0x48, 0x02, 0x31, 0xA5, 0x20, 0xF5, 0x05, 0x14, 0xCF,
    0xF3, 0x01, 0x14, 0xDF, 0xD2, 0x00, 0xA4, 0x43, 0xF0, 0x19,
    0x14, 0xD8, 0xA4, 0x43, 0xF5, 0x48, 0x13, 0x35, 0x4D, 0x2D,
    0xF5, 0x01, 0x14, 0xD8, 0xF3, 0x01, 0x14, 0xDF, 0xF2, 0x48,
    0xB4, 0x42, 0xF4, 0x2C, 0xE0, 0x00, 0x15, 0xAA, 0xD0, 0x01,
    0xF0, 0x19, 0x14, 0xE0, 0xD0, 0x00, 0xF0, 0x02, 0xD0, 0x5A,
    0xC0, 0x03, 0xF1, 0x08, 0xE0, 0x01, 0x13, 0x3C, 0xA0, 0x07,
    0xF1, 0x08, 0xE0, 0x01, 0x13, 0x4F, 0xA0, 0x07, 0xF1, 0x08,
    0xE0, 0x01, 0x13, 0xAC, 0xA0, 0x07, 0xF1, 0x08, 0xE0, 0x01,
    0x13, 0xB2, 0xE0, 0x01, 0x0A, 0x0E, 0xF0, 0x02, 0xE0, 0x00,
    0x14, 0xE1, 0xE0, 0x00, 0x09, 0xD3, 0xE0, 0x00, 0x15, 0xD6,
    0xE0, 0x00, 0x15, 0xE1, 0xF0, 0x02, 0xD0, 0x00, 0xE0, 0x03,
    0x14, 0x3B, 0xD3, 0x00, 0xE0, 0x03, 0x14, 0x5F, 0xF4, 0x01,
    0x15, 0x0A, 0xE0, 0x03, 0x14, 0xC0, 0xF3, 0x05, 0x15, 0x26,
    0xD3, 0x01, 0xE0, 0x03, 0x14, 0x79, 0xF4, 0x01, 0x15, 0x13,
    0xE0, 0x03, 0x14, 0xC0, 0xF3, 0x05, 0x15, 0x26, 0xD3, 0x02,
    0xE0, 0x03, 0x14, 0x5F, 0xF4, 0x01, 0x15, 0x1C, 0xE0, 0x03,
    0x14, 0xC0, 0xF3, 0x05, 0x15, 0x26, 0xD3, 0x03, 0xE0, 0x03,
    0x14, 0x5F, 0xF4, 0x01, 0x15, 0x25, 0xE0, 0x03, 0x14, 0xC0,
    0xF3, 0x05, 0x15, 0x26, 0xD3, 0x00, 0xA0, 0x31, 0xE0, 0x03,
    0x14, 0xF5, 0xF0, 0x02, 0xD0, 0x00, 0xE0, 0x03, 0x14, 0x3B,
    0xD3, 0x00, 0xE0, 0x03, 0x14, 0x5F, 0xF4, 0x01, 0x15, 0x48,
    0xD1, 0xCD, 0xC1, 0x02, 0xF2, 0x18, 0xF2, 0x05, 0x15, 0x3B,
    0xD2, 0x01, 0xF1, 0x2C, 0xF0, 0x19, 0x15, 0x77, 0xD2, 0x00,
    0xF1, 0x2C, 0xE0, 0x03, 0x14, 0xC0, 0xF3, 0x01, 0x15, 0x4C,
    0xD1, 0xD5, 0xC1, 0x02, 0xD2, 0x01, 0xF1, 0x2C, 0xD3, 0x01,
    0xF0, 0x19, 0x15, 0x74, 0xD1, 0xCD, 0xC1, 0x02, 0xD2, 0x00,
    0xF1, 0x2C, 0xD3, 0x01, 0xE0, 0x03, 0x14, 0x79, 0xF4, 0x01,
    0x15, 0x58, 0xE0, 0x03, 0x14, 0xC0, 0xF3, 0x01, 0x15, 0x58,
    0xD3, 0x01, 0xF0, 0x19, 0x15, 0x74, 0xD3, 0x02, 0xE0, 0x03,
    0x14, 0x5F, 0xF4, 0x01, 0x15, 0x68, 0xE0, 0x03, 0x14, 0xC0,
    0xF3, 0x01, 0x15, 0x68, 0xD1, 0xD5, 0xC1, 0x02, 0xD2, 0x01,
    0xF1, 0x2C, 0xD3, 0x01, 0xF0, 0x19, 0x15, 0x74, 0xD3, 0x03,
    0xE0, 0x03, 0x14, 0x79, 0xF4, 0x01, 0x15, 0x71, 0xE0, 0x03,
    0x14, 0xC0, 0xF3, 0x05, 0x15, 0x74, 0xD0, 0x00, 0xF0, 0x19,
    0x15, 0x77, 0xA0, 0x31, 0xE0, 0x03, 0x14, 0xE1, 0xF0, 0x02,
    0xD6, 0x5A, 0xC6, 0x03, 0xD5, 0x03, 0x46, 0x25, 0xF2, 0x68,
    0xA6, 0x63, 0xF3, 0x68, 0xA6, 0x63, 0xF4, 0x68, 0x4D, 0xC0,
    0xF5, 0x05, 0x15, 0x94, 0xB5, 0x12, 0xF5, 0x01, 0x15, 0x8E,
    0x55, 0xEF, 0xF5, 0x05, 0x15, 0x94, 0x10, 0x04, 0xA2, 0x23,
    0xF0, 0x19, 0x15, 0x81, 0xF2, 0x01, 0x15, 0x94, 0x10, 0x04,
    0xB2, 0x22, 0xF0, 0x19, 0x15, 0x81, 0xB6, 0x64, 0xF6, 0x2C,
    0xF0, 0x02, 0xD2, 0x5C, 0xC2, 0x03, 0xD1, 0x03, 0x42, 0x01,
    0xF0, 0x28, 0xF0, 0x02, 0xD2, 0x5A, 0xC2, 0x03, 0xF1, 0x28,
    0xA2, 0x25, 0xF0, 0x28, 0xA1, 0x14, 0xF1, 0x01, 0x15, 0xA9,
    0xB0, 0x02, 0xF0, 0x01, 0x15, 0xA9, 0x80, 0x03, 0xF0, 0x02,
    0xF0, 0x01, 0x15, 0xB4, 0xB0, 0x02, 0xF0, 0x01, 0x15, 0xC0,
    0xB0, 0x02, 0xF0, 0x01, 0x15, 0xCE, 0xF0, 0x19, 0x15, 0xD5,
    0xA5, 0x11, 0xE0, 0x05, 0x15, 0x9D, 0xD3, 0x00, 0xC3, 0x03,
    0x15, 0x53, 0xA6, 0x11, 0xD7, 0x01, 0xE0, 0x05, 0x15, 0x78,
    0xF0, 0x19, 0x15, 0xD5, 0xF0, 0x19, 0x15, 0xD5, 0xD5, 0x01,
    0xE0, 0x05, 0x15, 0x97, 0xA6, 0x11, 0xD7, 0x03, 0xE0, 0x05,
    0x15, 0x78, 0xD7, 0x02, 0xE0, 0x05, 0x15, 0x78, 0xF0, 0x19,
    0x15, 0xD5, 0xD5, 0x02, 0xE0, 0x05, 0x15, 0x97, 0xA6, 0x11,
    0xD7, 0x03, 0xE0, 0x05, 0x15, 0x78, 0xF0, 0x02, 0xD0, 0x1F,
    0xD2, 0x00, 0xD1, 0xFF, 0xE0, 0x00, 0x0A, 0x23, 0xC3, 0x16,
    0xF3, 0x09, 0xD2, 0x01, 0xE0, 0x00, 0x0A, 0x23, 0xF0, 0x02,
    0xD0, 0x2B, 0xE0, 0x00, 0x09, 0xB9, 0xD3, 0xFF, 0xF3, 0x09,
    0xF0, 0x02, 0xD7, 0x0F, 0xD8, 0x02, 0xC8, 0x02, 0xD9, 0x70,
    0xC9, 0xC0, 0xE0, 0x07, 0x0A, 0x2A, 0xE0, 0x07, 0x15, 0xD6,
    0xD3, 0x10, 0xD0, 0x00, 0xD1, 0x00, 0xD2, 0x00, 0xD7, 0x0F,
    0xE0, 0x07, 0x09, 0xC5, 0xD5, 0xFF, 0x24, 0xD5, 0x00, 0x04,
    0x84, 0x89, 0x84, 0x49, 0x01, 0x14, 0x24, 0xC5, 0x02, 0x24,
    0xD5, 0xFF, 0xF5, 0x09, 0xB3, 0x32, 0xF3, 0x05, 0x15, 0xF4,
    0xD6, 0x57, 0xC6, 0x03, 0x80, 0x09, 0xF6, 0x0C, 0xA6, 0x63,
    0x81, 0x19, 0xF6, 0x1C, 0xA6, 0x63, 0x82, 0x29, 0xF6, 0x2C,
    0xD7, 0x0F, 0xD8, 0xFE, 0xC8, 0xFE, 0xD9, 0x7F, 0xC9, 0xC0,
    0xE0, 0x07, 0x0A, 0x2A, 0xF0, 0x02, 0xD1, 0xA3, 0xC1, 0x03,
    0xD2, 0x04, 0x41, 0x20, 0xF4, 0x18, 0xD3, 0x1D, 0xE0, 0x03,
    0x09, 0xB9, 0xD3, 0x00, 0xD4, 0x5A, 0xC4, 0x03, 0xF4, 0x3C,
    0xA5, 0x31, 0xA4, 0x47, 0xA1, 0x13, 0xF3, 0x18, 0xB2, 0x22,
    0xF2, 0x05, 0x16, 0x21, 0xE0, 0x03, 0x14, 0xF5, 0xF0, 0x02,
    0xD4, 0x00, 0xE0, 0x04, 0x0B, 0x1B, 0xD1, 0xFC, 0xF2, 0x18,
    0x82, 0x22, 0x02, 0x24, 0xD1, 0xC9, 0xC1, 0x02, 0x01, 0x12,
    0xF4, 0x18, 0xD1, 0xD1, 0xC1, 0x02, 0xF1, 0x4C, 0xF0, 0x02,
    0xD1, 0xEA, 0xF0, 0x18, 0xD6, 0x80, 0x5F, 0x0E, 0x16, 0x60,
    0x40, 0x76, 0xD6, 0x40, 0x10, 0x06, 0xE0, 0x01, 0x0A, 0x6D,
    0x81, 0x13, 0xD6, 0x80, 0xC6, 0x25, 0x15, 0x16, 0xD6, 0x80,
    0xC6, 0x3E, 0xE0, 0x05, 0x0A, 0x97, 0x22, 0x50, 0x92, 0x2E,
    0x92, 0x28, 0xA2, 0x23, 0x92, 0x22, 0xD6, 0x40, 0xC6, 0x38,
    0x5F, 0x1E, 0xF7, 0x05, 0x16, 0x63, 0xD6, 0xC0, 0xC6, 0x2B,
    0x15, 0x16, 0xD6, 0x80, 0xC6, 0x0C, 0xE0, 0x05, 0x0A, 0x97,
    0x23, 0x50, 0x93, 0x3E, 0x93, 0x3A, 0xF0, 0x19, 0x16, 0x72,
    0xD6, 0x40, 0xC6, 0x51, 0x15, 0x16, 0xD6, 0x40, 0xC6, 0x1F,
    0xE0, 0x05, 0x0A, 0x97, 0xD3, 0x09, 0x23, 0x53, 0xD6, 0x00,
    0xC6, 0x04, 0x13, 0x63, 0x93, 0x3E, 0x23, 0x30, 0x93, 0x3E,
    0xA3, 0x33, 0x93, 0x32, 0xD1, 0xC3, 0xC1, 0x02, 0xF5, 0x18,
    0x05, 0x35, 0xE0, 0x05, 0x0A, 0x4E, 0xA1, 0x15, 0xF5, 0x18,
    0x94, 0x22, 0x15, 0x54, 0x96, 0x5F, 0xF6, 0x05, 0x16, 0x8A,
    0xD6, 0xF9, 0xC6, 0xFF, 0x5F, 0xDA, 0xF7, 0x05, 0x16, 0x8C,
    0xA4, 0x5F, 0xA5, 0x61, 0xF0, 0x19, 0x16, 0x8C, 0xB4, 0x5E,
    0xD5, 0x07, 0xE0, 0x05, 0x0A, 0x5B, 0x12, 0x24, 0xB1, 0x12,
    0xF5, 0x18, 0x05, 0x52, 0xE0, 0x05, 0x0A, 0x3D, 0xF0, 0x02,
    0xA2, 0x01, 0xD1, 0xDD, 0xD0, 0x07, 0xE0, 0x00, 0x0A, 0x23,
    0xF0, 0x02, 0xD2, 0x01, 0xD3, 0xF8, 0xA4, 0x01, 0xE0, 0x02,
    0x0A, 0x23, 0xC4, 0x30, 0xF4, 0x09, 0xD2, 0x01, 0xD3, 0xFF,
    0xD4, 0x01, 0xE0, 0x02, 0x0A, 0x23, 0xC4, 0x28, 0xF4, 0x09,
    0xD2, 0x00, 0xE0, 0x02, 0x09, 0xC5, 0x80, 0x3C, 0x80, 0x0D,
    0xD2, 0x01, 0xD3, 0xFF, 0xD4, 0x00, 0xE0, 0x02, 0x0A, 0x23,
    0xF0, 0x02, 0xD0, 0x00, 0xD1, 0xFE, 0xD2, 0x03, 0xE0, 0x00,
    0x0A, 0x23, 0xD0, 0x01, 0xE0, 0x00, 0x16, 0x95, 0xD0, 0x18,
    0xE0, 0x00, 0x16, 0x9B, 0xD1, 0x14, 0xE0, 0x01, 0x16, 0x9B,
    0xD3, 0xF0, 0xF3, 0x0C, 0xA3, 0x33, 0xF3, 0x1C, 0xD0, 0x00,
    0xC0, 0x7D, 0xE0, 0x00, 0x0A, 0x97, 0xD3, 0xEF, 0xF3, 0x0C,
    0xD1, 0xFF, 0xC1, 0x66, 0xD2, 0xAB, 0xC2, 0x10, 0xD0, 0x00,
    0xE0, 0x00, 0x0A, 0x2A, 0xD0, 0x00, 0xE0, 0x00, 0x16, 0x95,
    0xF0, 0x02, 0xD4, 0xF0, 0xF3, 0x48, 0xB4, 0x42, 0xF1, 0x48,
    0xD4, 0xCE, 0xC4, 0x02, 0x04, 0x40, 0xF2, 0x48, 0xE0, 0x02,
    0x0A, 0x97, 0x32, 0x12, 0xD4, 0x6E, 0xC4, 0x01, 0x12, 0x24,
    0x82, 0x2D, 0xA2, 0x23, 0x82, 0x23, 0xD4, 0x0F, 0x5F, 0xE4,
    0x14, 0x42, 0x42, 0x34, 0xA3, 0x20, 0x24, 0x23, 0xD2, 0x0B,
    0xD3, 0xB8, 0xE0, 0x02, 0x09, 0xFD, 0xF0, 0x02, 0xD5, 0xF0,
    0xF4, 0x58, 0xB5, 0x52, 0xF1, 0x58, 0xD5, 0x45, 0xC5, 0x03,
    0x05, 0x50, 0xF3, 0x58, 0xA5, 0x57, 0xF2, 0x58, 0xE0, 0x03,
    0x0A, 0x97, 0x33, 0x13, 0x13, 0x23, 0x83, 0x3D, 0xA1, 0x33,
    0xE0, 0x03, 0x0B, 0x21, 0xD5, 0x85, 0xC5, 0x01, 0xF5, 0x58,
    0x2F, 0xF5, 0x13, 0x13, 0x83, 0x33, 0xD5, 0x0F, 0x5C, 0x3D,
    0x15, 0x53, 0x43, 0x45, 0xA4, 0x30, 0x25, 0x34, 0xD3, 0x0F,
    0xD4, 0x30, 0xE0, 0x03, 0x09, 0xFD, 0xF0, 0x02, 0xD4, 0xF0,
    0xF3, 0x48, 0xB4, 0x42, 0xF1, 0x48, 0xD4, 0xCC, 0xC4, 0x03,
    0x04, 0x40, 0xF2, 0x48, 0xE0, 0x02, 0x0A, 0x97, 0x32, 0x12,
    0xD4, 0x80, 0xC4, 0x08, 0x12, 0x24, 0x82, 0x2D, 0xA2, 0x23,
    0x82, 0x23, 0xD4, 0x0F, 0x5F, 0xE4, 0x14, 0x42, 0x42, 0x34,
    0xA3, 0x20, 0x24, 0x23, 0xD2, 0x08, 0xD3, 0xB8, 0xE0, 0x02,
    0x09, 0xFD, 0xF0, 0x02, 0xE0, 0x03, 0x0B, 0x21, 0xD5, 0x85,
    0xC5, 0x01, 0xF6, 0x58, 0xA6, 0x63, 0xF6, 0x0D, 0x2E, 0xF6,
    0x01, 0x22, 0x02, 0x12, 0xD5, 0xF0, 0xF4, 0x58, 0xB5, 0x52,
    0xF1, 0x58, 0xD5, 0x7D, 0xC5, 0x03, 0x05, 0x50, 0x05, 0x52,
    0xF3, 0x58, 0xA5, 0x5D, 0xF2, 0x58, 0xE0, 0x03, 0x0A, 0x97,
    0x33, 0x13, 0x13, 0x23, 0xA6, 0x30, 0x23, 0x36, 0x83, 0x3D,
    0xA3, 0x33, 0x81, 0x33, 0xE0, 0x03, 0x0B, 0x21, 0xD5, 0x85,
    0xC5, 0x01, 0xF6, 0x58, 0x2F, 0xF6, 0x05, 0x31, 0xD6, 0x0F,
    0x4E, 0xDA, 0xF6, 0x01, 0x17, 0x5C, 0xD5, 0x1F, 0xD3, 0x0E,
    0xD4, 0x40, 0xE0, 0x03, 0x0A, 0x23, 0xF0, 0x02, 0xD6, 0x01,
    0xE0, 0x06, 0x16, 0x95, 0xD0, 0x50, 0xC0, 0x01, 0xD1, 0x44,
    0xC1, 0x01, 0xD3, 0x0C, 0xF8, 0x08, 0xA0, 0x03, 0xF7, 0x08,
    0xA0, 0x03, 0xD2, 0x00, 0xD4, 0x08, 0x85, 0x8D, 0xD6, 0x01,
    0xC8, 0x19, 0xE0, 0x06, 0x0A, 0x2A, 0xD9, 0x14, 0xF9, 0x09,
    0xC8, 0x99, 0xE0, 0x06, 0x0A, 0x2A, 0xD9, 0x14, 0xF9, 0x09,
    0xD9, 0x01, 0xE0, 0x09, 0x09, 0xC5, 0xD9, 0xFF, 0xC9, 0x03,
    0x2E, 0xA9, 0x02, 0x2A, 0xB4, 0x42, 0xF4, 0x05, 0x17, 0x70,
    0xD9, 0xEB, 0xC9, 0x41, 0x05, 0x59, 0x32, 0x25, 0xF9, 0x18,
    0xD7, 0x00, 0xC7, 0x13, 0x37, 0x97, 0x08, 0x97, 0x17, 0x97,
    0x5C, 0x82, 0x5F, 0x2F, 0x2C, 0x87, 0xF8, 0x05, 0x17, 0x95,
    0xA2, 0x91, 0xF1, 0x2C, 0xA1, 0x13, 0xB3, 0x32, 0xF3, 0x05,
    0x17, 0x69, 0xD6, 0x00, 0xE0, 0x06, 0x16, 0x95, 0xD6, 0x24,
    0xC6, 0x01, 0xF7, 0x68, 0xA6, 0x63, 0xF8, 0x68, 0xD6, 0x01,
    0xE0, 0x06, 0x0A, 0x2A, 0xF0, 0x02, 0xD1, 0x7A, 0xC1, 0x03,
    0xF2, 0x18, 0xD1, 0x7B, 0xC1, 0x03, 0xF0, 0x18, 0x02, 0x20,
    0xD1, 0x7C, 0xC1, 0x03, 0xF0, 0x18, 0x12, 0x20, 0xD0, 0x7F,
    0xC0, 0x01, 0x02, 0x20, 0xD1, 0x5E, 0xC1, 0x03, 0xF1, 0x2C,
    0xF0, 0x02, 0xA1, 0x03, 0xF1, 0x01, 0x17, 0xBC, 0xD1, 0x01,
    0xD2, 0xA4, 0xC2, 0x01, 0xF2, 0x1C, 0xE0, 0x03, 0x0F, 0x31,
    0xA5, 0x11, 0xD3, 0x01, 0xD4, 0x44, 0xE0, 0x03, 0x09, 0xFD,
    0xD3, 0x1C, 0xD4, 0x11, 0xE0, 0x03, 0x09, 0xFD, 0xA5, 0x13,
    0xD4, 0xCC, 0xE0, 0x03, 0x0A, 0x23, 0xA4, 0x01, 0xD3, 0x2F,
    0xE0, 0x03, 0x09, 0xB9, 0x84, 0x09, 0x84, 0x49, 0xD3, 0x31,
    0xE0, 0x03, 0x09, 0xB9, 0xF1, 0x01, 0x17, 0xDD, 0xD4, 0x20,
    0xD3, 0x24, 0xE0, 0x03, 0x09, 0xB9, 0xD4, 0x00, 0xD3, 0x30,
    0xE0, 0x03, 0x09, 0xB9, 0xF0, 0x02, 0xD0, 0xA3, 0xC0, 0x01,
    0xF1, 0x08, 0xF1, 0x01, 0x17, 0xFD, 0xB1, 0x12, 0xF0, 0x1C,
    0xF1, 0x05, 0x17, 0xFD, 0xD0, 0xF5, 0xF1, 0x08, 0xB1, 0x14,
    0xF1, 0x05, 0x17, 0xFD, 0xD1, 0x04, 0xE0, 0x01, 0x13, 0x36,
    0xD0, 0xC3, 0xC0, 0x02, 0xD1, 0x00, 0xF0, 0x1C, 0xA0, 0x03,
    0xF0, 0x1C, 0xA0, 0x03, 0xF0, 0x1C, 0xE0, 0x01, 0x16, 0x3B,
    0xF0, 0x02, 0xF0, 0x19, 0x08, 0x9A, 0x90, 0x00, 0x88, 0x00,
    0x30, 0x00, 0x34, 0x00, 0x24, 0x00, 0x6C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x9C, 0x60, 0x2F, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x1E, 0x00, 0x22, 0x00, 0x00, 0x62, 0x4D,
    0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0xB2, 0x00, 0x30,
    0x00, 0x47, 0x00, 0x00, 0xC5, 0x15, 0x00, 0x4A, 0x00, 0x7F,
    0x00, 0x00, 0xA3, 0xD2, 0x00, 0x82, 0x00, 0xB6, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x90, 0x00, 0x90, 0x11, 0x90, 0x22, 0x90, 0x33,
    0x90, 0x44, 0x90, 0x55, 0x90, 0x66, 0x90, 0x77, 0x90, 0x88,
    0x90, 0x99, 0x91, 0x00, 0x91, 0x11, 0x91, 0x22, 0x91, 0x33,
    0x91, 0x44, 0x91, 0x55, 0x91, 0x66, 0x91, 0x77, 0x91, 0x88,
    0x91, 0x99, 0x92, 0x00, 0x92, 0x11, 0x92, 0x22, 0x92, 0x33,
    0x92, 0x44, 0x92, 0x55, 0x80, 0x00, 0x80, 0x11, 0x80, 0x22,
    0x80, 0x33, 0x80, 0x44, 0x80, 0x55, 0x80, 0x66, 0x80, 0x77,
    0x80, 0x88, 0x80, 0x99, 0x81, 0x00, 0x81, 0x11, 0x81, 0x22,
    0x81, 0x33, 0x81, 0x44, 0x81, 0x55, 0x81, 0x66, 0x81, 0x77,
    0x81, 0x88, 0x81, 0x99, 0x82, 0x00, 0x82, 0x11, 0x82, 0x22,
    0x82, 0x33, 0x82, 0x44, 0x82, 0x55, 0x82, 0x66, 0x82, 0x77,
    0x82, 0x88, 0x82, 0x99, 0x83, 0x00, 0x83, 0x11, 0x83, 0x22,
    0x83, 0x33, 0x83, 0x44, 0x83, 0x55, 0x83, 0x66, 0x83, 0x77,
    0x83, 0x88, 0x83, 0x99, 0x84, 0x00, 0x84, 0x11, 0x84, 0x22,
    0x84, 0x33, 0x84, 0x44, 0x84, 0x55, 0x84, 0x66, 0x84, 0x77,
    0x84, 0x88, 0x84, 0x99, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x11,
    0x10, 0x22, 0x10, 0x33, 0x10, 0x44, 0x10, 0x55, 0x10, 0x66,
    0x10, 0x77, 0x10, 0x88, 0x10, 0x99, 0x11, 0x00, 0x11, 0x11,
    0x11, 0x22, 0x11, 0x33, 0x11, 0x44, 0x11, 0x55, 0x11, 0x66,
    0x11, 0x77, 0x11, 0x88, 0x11, 0x99, 0x12, 0x00, 0x12, 0x11,
    0x12, 0x22, 0x12, 0x33, 0x12, 0x44, 0x12, 0x55, 0x12, 0x66,
    0x12, 0x77, 0x12, 0x88, 0x12, 0x99, 0x13, 0x00, 0x13, 0x11,
    0x13, 0x22, 0x13, 0x33, 0x13, 0x44, 0x13, 0x55, 0x13, 0x66,
    0x13, 0x77, 0x13, 0x88, 0x13, 0x99, 0x14, 0x00, 0x14, 0x11,
    0x14, 0x22, 0x14, 0x33, 0x14, 0x44, 0x14, 0x55, 0x14, 0x66,
    0x14, 0x77, 0x14, 0x88, 0x14, 0x99, 0x15, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFA, 0xBC, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x46, 0xFF, 0x10, 0x86, 0x15, 0xA3, 0x06, 0x7D, 0x00, 0x00,
    0x00, 0x00, 0x84, 0x43, 0x80, 0x00, 0x76, 0x17, 0x00, 0x00,
    0x67, 0xC0, 0x07, 0x00, 0x03, 0x3D, 0x00, 0xD0, 0xF6, 0x4B,
    0x80, 0x01, 0xF1, 0xA5, 0x00, 0x07, 0x01, 0x80, 0x03, 0x12,
    0x65, 0x05, 0x86, 0x45, 0x2C, 0xFC, 0x02, 0xF8, 0x00, 0x42,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x7F, 0x78,
    0xFE, 0xFE, 0xC0, 0x7F, 0x9F, 0xFB, 0x66, 0xFF, 0x10, 0xAB,
    0x13, 0xCB, 0x06, 0x7D, 0x00, 0x00, 0x00, 0x00, 0x84, 0x43,
    0x80, 0x08, 0x76, 0xD7, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
    0x03, 0x3D, 0x00, 0xD0, 0x37, 0x4B, 0xC0, 0x04, 0x13, 0x45,
    0x00, 0x00, 0x3D, 0x8A, 0x03, 0x12, 0xD5, 0x83, 0x40, 0xD9,
    0xAC, 0x77, 0x03, 0x78, 0x00, 0x83, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x80, 0xFF, 0x79, 0xFE, 0xFE, 0xC0, 0x7F,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x01, 0x76, 0x01, 0x38,
    0x02, 0xC0, 0x02, 0x30, 0x04, 0x20, 0x03, 0x60, 0x06, 0x5C,
    0x04, 0xBC, 0x09, 0x60, 0x07, 0x9C, 0x0D, 0x70, 0x52, 0x03,
    0xF0, 0x01, 0xCD, 0x20, 0x00, 0x01, 0x29, 0x23, 0xF0, 0x02,
    0x52, 0x20, 0x00, 0x02, 0x00, 0x23, 0xF0, 0x03, 0x00, 0x20,
    0x00, 0x03, 0x00, 0x23, 0xF0, 0x04, 0x00, 0x20, 0x00, 0x04,
    0x00, 0x23, 0xF0, 0x05, 0x00, 0x20, 0x00, 0x05, 0x00, 0x23,
    0xF0, 0x06, 0x00, 0x20, 0x00, 0x06, 0x02, 0x58, 0x02, 0x58,
    0x02, 0x58, 0x03, 0xE8, 0x05, 0xDC, 0x08, 0xFC, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x0C, 0x4C, 0x14,
    0x5C, 0x0C, 0x5C, 0x14, 0x70, 0x0C, 0x6C, 0x14, 0x50, 0x0C,
    0x4C, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0E, 0x36, 0x94, 0x09, 0xF8, 0x5F, 0x28, 0xF7, 0x00,
    0xFF, 0x90, 0xFF, 0x70, 0xFF, 0x50, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x12, 0x00, 0x2A, 0xCC, 0x12, 0x00, 0x12, 0x66,
    0x16, 0x00, 0x16, 0x8F, 0x16, 0xF5, 0x18, 0x66, 0x19, 0xC2,
    0x19, 0x5C, 0x1A, 0x00, 0x19, 0x84, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0E, 0x28, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x10, 0x03, 0x00, 0x01, 0x00, 0x05, 0x09, 0x00, 0x0C,
    0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x05,
    0x00, 0x03, 0x0A, 0xAC, 0xAA, 0x53, 0x4A, 0x4A, 0xA0, 0x06,
    0x00, 0x05, 0x00, 0x0A, 0x6D, 0x8C, 0xF2, 0xD8, 0xCF, 0x2A,
    0x39, 0x04, 0xA0, 0x07, 0x00, 0x01, 0x08, 0x0A, 0xA0, 0x08,
    0x00, 0x01, 0xCC, 0x35, 0xCC, 0x35, 0x3F, 0x00, 0xBF, 0x00,
    0x01, 0x00, 0x81, 0x00, 0xA0, 0x09, 0x00, 0x08, 0x00, 0x01,
    0x6D, 0x18, 0xFA, 0x08, 0xC1, 0x12, 0x18, 0x64, 0x3C, 0xFA,
    0xF7, 0xE1, 0x0C, 0x2C, 0xA0, 0x0A, 0x00, 0x02, 0x00, 0x0E,
    0x56, 0x8A, 0xA0, 0x0B, 0x00, 0x05, 0x80, 0xF9, 0xD7, 0x3E,
    0x75, 0xC1, 0x8A, 0xE4, 0x02, 0x00, 0xA0, 0x0C, 0x00, 0x03,
    0x67, 0x65, 0xF4, 0xAA, 0x40, 0x40, 0x57, 0x40, 0xF2, 0xAA,
    0xD4, 0xD4, 0xA0, 0x0D, 0x00, 0x02, 0x19, 0x20, 0x8B, 0x3C,
    0x18, 0xCE, 0x76, 0x3C, 0xA0, 0x11, 0x00, 0x06, 0x00, 0x20,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x14, 0x08, 0x00, 0x00, 0x0C, 0x08, 0xDA, 0xB4, 0xDA,
    0x0B, 0x2D, 0x00, 0x14, 0x08, 0x00, 0x00, 0x0C, 0x08, 0xDA,
    0xB4, 0xDA, 0x0B, 0x2D, 0xA0, 0x12, 0x00, 0x07, 0x00, 0x06,
    0xD8, 0xAB, 0x64, 0xD3, 0x08, 0x01, 0x49, 0x24, 0xD5, 0x52,
    0x20, 0x09, 0x00, 0x5A, 0xDB, 0x2D, 0x11, 0x23, 0x46, 0x8A,
    0xAB, 0x48, 0xAB, 0x1B, 0x20, 0x03, 0x00, 0x08, 0xD9, 0x2D,
    0x11, 0xA5, 0x51, 0x4C, 0x2D, 0xB5, 0x2D, 0x3B, 0x88, 0x06,
    0xA0, 0x17, 0x00, 0x0E, 0x00, 0x5A, 0x05, 0x72, 0x13, 0x86,
    0xAD, 0xC5, 0x4E, 0x16, 0x85, 0x0A, 0x38, 0x48, 0xDA, 0x4C,
    0xEB, 0x6C, 0x52, 0xCB, 0xB6, 0xCD, 0xCA, 0xCE, 0xD4, 0x66,
    0xB1, 0x2F, 0x00, 0x6D, 0x85, 0x75, 0x13, 0xB6, 0xB2, 0x2A,
    0xA8, 0x16, 0x84, 0x14, 0x3A, 0xC6, 0xDC, 0xD4, 0xEB, 0x6D,
    0x55, 0x2B, 0x64, 0x92, 0x2A, 0xAE, 0xDB, 0x66, 0xD5, 0x31,
    0x00, 0x6D, 0x45, 0x6D, 0x13, 0x80, 0x16, 0x40, 0x2E, 0x1A,
    0xD4, 0x93, 0x20, 0x69, 0x20, 0x32, 0x8D, 0x6D, 0x45, 0x4B,
    0x85, 0xB6, 0x22, 0xAE, 0x1A, 0xD6, 0x8B, 0x2B, 0x00, 0x6D,
    0x85, 0x75, 0x13, 0x45, 0x1A, 0x44, 0x2D, 0xA3, 0x55, 0x43,
    0x3A, 0xD1, 0x63, 0x42, 0x81, 0x46, 0x40, 0x8B, 0x68, 0xB6,
    0x31, 0x2E, 0xDB, 0x66, 0xD5, 0x31, 0x00, 0x0A, 0x24, 0x64,
    0x33, 0xA8, 0xB6, 0x48, 0xCD, 0x03, 0x44, 0x85, 0x3B, 0x50,
    0x22, 0xC0, 0xD0, 0x36, 0x48, 0x4B, 0xAD, 0xA2, 0x33, 0x0D,
    0x1B, 0x66, 0x8D, 0x2C, 0x00, 0x09, 0x24, 0x62, 0xB3, 0x24,
    0x92, 0x2A, 0xC8, 0xD4, 0x44, 0x29, 0x3A, 0xDB, 0x62, 0xCC,
    0xED, 0xA8, 0x4D, 0x23, 0x6D, 0x16, 0x4A, 0x4D, 0xB4, 0x67,
    0x51, 0x2D, 0xA0, 0x17, 0x00, 0x0E, 0x00, 0x60, 0x2D, 0x70,
    0x52, 0x2D, 0xB5, 0x13, 0x2E, 0xDA, 0x92, 0xB5, 0x3B, 0x56,
    0xD2, 0xD2, 0xEB, 0x51, 0x33, 0x33, 0x68, 0xB1, 0x31, 0x2E,
    0xDB, 0x57, 0x2D, 0x32, 0x00, 0x50, 0x35, 0x68, 0x53, 0xA8,
    0xD9, 0x50, 0xCB, 0x69, 0x13, 0x2D, 0x34, 0x69, 0x12, 0x32,
    0xD8, 0xD9, 0x2D, 0x33, 0x46, 0xD9, 0x22, 0xAE, 0xD6, 0xD7,
    0x53, 0x30, 0x00, 0x0D, 0x6D, 0x63, 0x53, 0x6D, 0x91, 0x52,
    0xCC, 0x24, 0x92, 0xAD, 0x23, 0x6D, 0x90, 0xCA, 0xEB, 0x21,
    0x35, 0x53, 0xA8, 0xD9, 0x31, 0x4E, 0xD6, 0xD6, 0xCD, 0x34,
    0x00, 0x50, 0x35, 0x68, 0x53, 0x24, 0x91, 0x33, 0x4E, 0xA8,
    0x93, 0x4D, 0x20, 0x6D, 0x90, 0x34, 0x86, 0x91, 0x22, 0xD3,
    0x64, 0x91, 0x52, 0xCE, 0xD6, 0xD7, 0x53, 0x34, 0x00, 0x6D,
    0x45, 0x6D, 0x13, 0x6C, 0x6D, 0x4C, 0xCC, 0x90, 0x93, 0x55,
    0x22, 0x49, 0x11, 0x2C, 0xEB, 0x11, 0x33, 0x53, 0x46, 0xD1,
    0x43, 0x4E, 0x1A, 0xD6, 0x8B, 0x35, 0x00, 0x5B, 0x6D, 0x6C,
    0xD3, 0x40, 0xCD, 0x20, 0xCD, 0x84, 0x93, 0x55, 0x22, 0xD1,
    0x11, 0x44, 0xE8, 0x49, 0x34, 0xD3, 0x68, 0x6D, 0x30, 0xCE,
    0xA0, 0x56, 0xA1, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x14, 0x01, 0xE8, 0x00, 0x06, 0x01, 0xD8, 0xC0,
    0x00, 0x00, 0x19, 0x64, 0x28, 0xA0, 0x80, 0x00, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xA0, 0x19, 0x00, 0x06, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x86, 0x51,
    0xD2, 0x35, 0xA4, 0x92, 0xA5, 0xB5, 0x25, 0x65, 0x00, 0x01,
    0xB6, 0x15, 0x16, 0xB1, 0xA6, 0xD2, 0xA9, 0x12, 0x41, 0x66,
    0x00, 0x00, 0x2D, 0x09, 0x6D, 0xB5, 0xA6, 0xD2, 0x59, 0x16,
    0x41, 0x65, 0x00, 0x00, 0x80, 0x1F, 0x00, 0x01, 0x00, 0x04,
    0x00, 0x00, 0x80, 0x20, 0x00, 0x01, 0x00, 0x51, 0x00, 0x4C,
    0x80, 0x21, 0x00, 0x01, 0x00, 0x06, 0x00, 0x00, 0xA0, 0x23,
    0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x65, 0x14,
    0x00, 0x00, 0x00, 0x06, 0x98, 0x00, 0x01, 0xA6, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x88, 0x82, 0x66, 0x80, 0x24, 0x00, 0x01,
    0x00, 0xCC, 0x00, 0x4A, 0x00, 0x25, 0x00, 0x12, 0x00, 0x00,
    0x00, 0x40, 0x00, 0x01, 0x00, 0x06, 0x00, 0x44, 0x00, 0x50,
    0x00, 0x04, 0xC0, 0xC7, 0xA0, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0xA0, 0x2C, 0x00, 0x01, 0x00, 0x00, 0x7B, 0x73, 0x80, 0x35,
    0x00, 0x01, 0x00, 0x08, 0x00, 0x31, 0xA0, 0x2E, 0x00, 0x07,
    0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0xDC, 0xC8, 0x01, 0x01,
    0x41, 0x0A, 0x49, 0x24, 0xD5, 0x19, 0xE8, 0x08, 0xA0, 0x3A,
    0x00, 0x02, 0x7A, 0x5A, 0x7A, 0x10, 0x7A, 0x6F, 0x7F, 0x10,
    0x78, 0x6F, 0x8F, 0x10, 0x78, 0x8F, 0x8F, 0x10, 0xA8, 0x9F,
    0x9F, 0x10, 0xA0, 0x3B, 0x00, 0x01, 0x07, 0xFF, 0x05, 0xFF,
    0x2F, 0x78, 0x27, 0x7A, 0x1E, 0x16, 0x0D, 0x55, 0x0D, 0xA1,
    0x0C, 0xE9, 0x00, 0x00, 0x00, 0x10, 0x00, 0xB4, 0x00, 0x00,
    0x00, 0x38, 0x00, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0xB0,
    0x00, 0x00, 0x03, 0x34, 0x03, 0xAE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x09, 0x00, 0x00, 0xF3,
    0x00, 0xFF, 0x00, 0x26, 0x00, 0x01, 0x00, 0x07, 0x01, 0x80,
    0x00, 0x09, 0x00, 0x2B, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x0D, 0x02, 0x71, 0x00, 0x00, 0x0C, 0x0B, 0x07, 0x0B,
    0x03, 0xE0, 0x02, 0x0C, 0x01, 0x0E, 0x00, 0x89, 0x00, 0x45,
    0x00, 0x23, 0x00, 0x11, 0x00, 0x09, 0x00, 0x04, 0x00, 0x02,
    0x00, 0x01, 0x00, 0x00, 0xF8, 0x84, 0x00, 0x1F, 0x00, 0x37,
    0x00, 0xB8, 0x40, 0x3C, 0x32, 0xD4, 0x2C, 0x1A, 0x40, 0x3C,
    0x36, 0xE0, 0x30, 0x00, 0x0F, 0xFC, 0x0F, 0x98, 0x0F, 0x70,
    0x0F, 0xFC, 0x0F, 0x98, 0x0F, 0x70, 0x00, 0x0D, 0x00, 0x08,
    0x00, 0x06, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x30, 0xFF, 0xD0, 0x00, 0x60, 0xFF, 0xA0,
    0x00, 0x90, 0xFF, 0x70, 0x00, 0xA0, 0x00, 0x02, 0x18, 0x20,
    0x24, 0x20, 0x30, 0x20, 0x2A, 0x0E, 0x32, 0x12, 0x3A, 0x16,
    0x22, 0x00, 0x18, 0x00, 0x10, 0x00, 0x80, 0x00, 0x00, 0x01,
    0x00, 0x7F, 0x00, 0x07, 0x00, 0x2B, 0x00, 0x01, 0x00, 0x7F,
    0x00, 0x01, 0x00, 0x06, 0x82, 0x0E, 0x4B, 0x32, 0xAA, 0x46,
    0x03, 0x34, 0x07, 0x59, 0xA0, 0x10, 0x82, 0x5F, 0x64, 0x32,
    0x03, 0x20, 0x07, 0x58, 0xA0, 0x10, 0x60, 0x32, 0x50, 0x1E,
    0x02, 0xBC, 0x06, 0xA5, 0x78, 0x0C, 0x4B, 0x32, 0xAA, 0x46,
    0x03, 0x34, 0x07, 0x58, 0x78, 0x0C, 0x4B, 0x32, 0xAA, 0x46,
    0x02, 0x58, 0x06, 0xA4, 0x00, 0x19, 0x00, 0x2C, 0x00, 0x21,
    0x00, 0x2C, 0x00, 0x1D, 0x00, 0x35, 0x00, 0x28, 0x00, 0x35,
    0x42, 0x59, 0x35, 0x00, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00,
    //0x80, 0x0A,          /* WAIT 010[ms] */		// Ken Add
    0x00, 0x03,          /* Length = 3 bytes */
    0x00, 0x02, 0x2E,
    //0x80, 0x0A,          /* WAIT 010[ms] */		// Ken Add
    0x00, 0x03,          /* Length = 3 bytes */
    0x00, 0x02, 0x1F,
    //0x80, 0x0A,          /* WAIT 010[ms] */		// Ken Add
    0x00, 0x05,          /* Length = 5 bytes */
    0x00, 0x00, 0x00, 0x00, 0x88,
    0x80, 0x0A,          /* WAIT 010[ms] */
    0x00, 0x04,          /* Length = 4 bytes */
    0x83, 0x37, 0xA8, 0x8F,
    //0x80, 0x0A,          /* WAIT 010[ms] */    // Maggie Add
    0x00, 0x04,          /* Length = 4 bytes */
    0x83, 0x38, 0x8F, 0x10,
    //0x80, 0x0A,          /* WAIT 010[ms] */    // Maggie Add
    0x00, 0x04,          /* Length = 4 bytes */
    0x83, 0x39, 0xA8, 0x8F,
    //0x80, 0x0A,          /* WAIT 010[ms] */    // Maggie Add
    0x00, 0x04,          /* Length = 4 bytes */
    0x83, 0x3A, 0x8F, 0x10,
    //0x80, 0x0A,          /* WAIT 010[ms] */    // Maggie Add
    0x00, 0x04,          /* Length = 4 bytes */
    0x83, 0x3B, 0xA8, 0x8F,
    //0x80, 0x0A,          /* WAIT 010[ms] */    // Maggie Add
    0x00, 0x04,          /* Length = 4 bytes */
    0x83, 0x3C, 0x8F, 0x10,
    0xFF, 0xFF           /* END OF SEQUENCE. TOTAL MEMORY REQ'D = 12370 BYTES */
};


static int xc_reset()
{
    //Reset Demod chip
    GPIO_SetOut(XC5000_GPIO, 1);  //HIGH ->LOW->HIGH
    x_thread_delay(100); //delay 1000 ms
    GPIO_SetOut(XC5000_GPIO, 0);
    x_thread_delay(200); //delay 1000 ms
    GPIO_SetOut(XC5000_GPIO, 1);
    return 0;
}

static void xc_wait(int wait_ms)
{
    x_thread_delay(wait_ms);
}

static int xc_send_i2c_data(unsigned char* bytes_to_send, int nb_bytes_to_send)
{
    if (SIF_TunerWriteNoSubAddr(cI2C_TIMING, XC5000_I2C_ADDR, &bytes_to_send[0], nb_bytes_to_send) != 0)
    {
        return 0;
    }
    else
    {
        return 2;
    }
}

static int xc_load_i2c_sequence(unsigned char i2c_sequence[])
{
    int i, nbytes_to_send, pos, result;
    unsigned int length, index;
    unsigned char buf[XC_MAX_I2C_WRITE_LENGTH];

    index = 0;
    while ((i2c_sequence[index] != 0xFF) || (i2c_sequence[index + 1] != 0xFF))
    {
        length = i2c_sequence[index] * 256 + i2c_sequence[index + 1];
        if (length == 0x0000)
        {
            //this is in fact a RESET command
            result = xc_reset();
            index += 2;
            if (result != 0)
            {
                return result;
            }
        }
        else if (length & 0x8000)
        {
            //this is in fact a WAIT command
            xc_wait(length & 0x7FFF);
            index += 2;
        }
        else
        {
            //send i2c data whilst ensuring individual transactions do
            //not exceed XC_MAX_I2C_WRITE_LENGTH bytes
            index += 2;
            buf[0] = i2c_sequence[index];
            buf[1] = i2c_sequence[index + 1];
            pos = 2;
            while (pos < length)
            {
                if ((length - pos) > XC_MAX_I2C_WRITE_LENGTH - 2)
                {
                    nbytes_to_send = XC_MAX_I2C_WRITE_LENGTH;
                }
                else
                {
                    nbytes_to_send = (length - pos + 2);
                }
                for (i = 2; i < nbytes_to_send; i++)
                {
                    buf[i] = i2c_sequence[index + pos + i - 2];
                }
                result = xc_send_i2c_data(buf, nbytes_to_send);

                if (result != 0)
                {
                    return result;
                }

                pos += nbytes_to_send - 2;
            }
            index += length;
        }
    }
    return 0;
}

static INT32 _SifSCLStretchCmd(INT32 i4Argc, const CHAR** szArgv)
{
    UINT8 u1Status = 1;
    SIF_Init();
    // Hardware reset
    xc_reset();  //liuqu,20080516,should reset the tuner board!
    // Download firmware
    Printf("reset ok!!!!\n");
    u1Status = xc_load_i2c_sequence(XC5000_firmware_SEQUENCE);
    if (u1Status != 0)
    {
        Printf(("xc_load_i2c_sequence() fail\n"));
    }
    else
    {
        Printf("xc_load_i2c_sequence() OK\n");
    }

    return 0;
}
#endif

//-------------------------------------------------------------------------
/** SifHDCPWrite
 *  write HDMI HDCP in system EEPROM function.
 *  @param  pBuf             pointer of data to be written
 *  @retval  0  SUCCESS.
 *  @retval  1  FAIL.
 */
//-------------------------------------------------------------------------
UINT8 SifHDCPWrite(UINT16 u2_offset, UINT8* pBuf, UINT16 u2_length)  // jiewen.hdcp
{
    INT32 fgSet;

#ifdef HDCP_WithSerialNum
    fgSet = EEPHDCP_Write(0, (UINT32)pBuf, SIF_HDCPWithSerialNum_SIZE);
    if (fgSet)
    {
        Printf("EEPHDCP_Write fail.\n");
        return 1;
    }
#else
    INT32 i;
    fgSet = EEPHDCP_Write(u2_offset, (UINT32)pBuf, u2_length);
    if (fgSet)
    {
        Printf("EEPHDCP_Write fail.\n");
        return 1;
    }

    fgSet = EEPHDCP_Read(u2_offset, (UINT32)_au1EEPBuf, u2_length);
    if (fgSet)
    {
        Printf("read eeprom back fail.\n");
        return 1;
    }

    for (i = 0; i < u2_length; i++)
    {
        if (*(pBuf + i) != _au1EEPBuf[i])
        {
            Printf("write fail !\n");
            return 1;
        }
    }
#endif

    Printf("write successfully !\n");
    return 0;
}

//-------------------------------------------------------------------------
/** SifHDCPRead
 *  read HDMI HDCP in system EEPROM function.
 *  @param  pBuf             pointer of data to be read
 *  @retval  0  SUCCESS.
 *  @retval  1  FAIL.
 */
//-------------------------------------------------------------------------
UINT8 SifHDCPRead(UINT16 u2_offset, UINT8* pBuf, UINT16 u2_length)  // jiewen.hdcp
{
    INT32 fgSet;

    fgSet = EEPHDCP_Read(u2_offset, (UINT32)pBuf, u2_length);
    if (fgSet)
    {
        Printf("read fail.\n");
        return 1;
    }
    return 0;
}
#ifdef CUST_SOEM_DRV
	//{ "keyheader", "kh", _SifWriteKeyHeader, NULL, "write key header", CLI_GUEST },
	//{ "rkeyheader", "rkh", _SifReadKeyHeader, NULL, "read key header", CLI_GUEST }
extern INT32 ui4SetKeyHeader(INT8 i1_key_hdr,UINT8* pui1_buffer, size_t z_size);
extern INT32 ui4GetKeyHeader(INT8 i1_key_hdr, UINT8* pui1_buffer);
static INT32 _SifWriteKeyHeader(INT32 i4Argc, const CHAR** szArgv)
{
	//kh [0,1,...]
	//CHAR* param;
	INT8 i1_part = 0;
	UINT8* pui1Buf;
	INT32 i4_ret = 0;
	UINT8 ui1Value = 0;
	if(i4Argc != 3)
	{
		Printf("[SIF CMD]Input format\n kh [0:hdcp1.4/1:hdcp2.2/2:TVID/3:netflix...] [value]");
		return -1;
	}
	
	i1_part = StrToInt(szArgv[1]);
	if(i1_part > 4)
	{
		Printf("[SIF CMD] input arg should less that 4\n");
		return -1;
	}


	pui1Buf = x_mem_alloc(64);
	if(pui1Buf == NULL){
		Printf("[SIF CMD] no memory\n");
		return -1;
	}
	ui1Value = StrToInt(szArgv[2]);
	x_memset(pui1Buf, ui1Value, 64);
	i4_ret = ui4SetKeyHeader(i1_part, pui1Buf, 64);
	x_mem_free(pui1Buf);

	return i4_ret;
	
}
static INT32 _SifReadKeyHeader(INT32 i4Argc, const CHAR** szArgv)
{
	//kh [0,1,...]
	//CHAR* param;
	INT8 i1_part = 0;
	UINT8* pui1Buf;
	INT32 i4_ret = 0;
	
	if(i4Argc != 2)
	{
		Printf("[SIF CMD]Input format\n rkh [0/1/2...]");
		return -1;
	}
	i1_part = StrToInt(szArgv[1]);
	if(i1_part > 4)
	{
		Printf("[SIF CMD] input arg should less that 4\n");
		return -1;
	}
	
	pui1Buf = x_mem_alloc(64);
	if(pui1Buf == NULL){
		Printf("[SIF CMD] no memory\n");
		return -1;
	}

	i4_ret = ui4GetKeyHeader(i1_part,pui1Buf);
	x_mem_free(pui1Buf);
	return i4_ret;
}
//{ "setkey", "sk", _SifWriteKey, NULL, "write key ", CLI_GUEST },
//{ "getkey", "gk", _SifReadKey, NULL, "read key ", CLI_GUEST },

extern INT32 ui4GetNANDKey(INT8 i1_keyID, UINT8* pui1_buffer, size_t t_size);
extern INT32 ui4SetNANDKey(INT8 i1_keyID,UINT8* pui1_buffer, size_t z_size);
static INT32 _SifWriteKey(INT32 i4Argc, const CHAR** szArgv)
{
	INT8 i1_part = 0;
	UINT8* pui1Buf;
	INT32 i4_ret = -1;
	size_t z_size = 0;
	UINT8 ui1Value = 0;
	
	if(i4Argc != 4)
	{
		Printf("[SIF CMD]Input format\n sk 2:TVID [size,default 22] [value]\n");
		return -1;
	}
	i1_part = StrToInt(szArgv[1]);
	if(i1_part > 4)
	{
		Printf("[SIF CMD] input arg should less that 4\n");
		return -1;
	}
	z_size = StrToInt(szArgv[2]);
	if(z_size < 0 || z_size > 30){
		Printf("[SIF CMD] z_size is invalid\n");
		return -1;
	}
	ui1Value = StrToInt(szArgv[3]);
	
	pui1Buf = x_mem_alloc(z_size);
	if(pui1Buf == NULL){
		Printf("[SIF CMD] the mem alloc fail\n");
		return -1;
	}
	x_memset(pui1Buf, ui1Value, z_size);
	i4_ret = ui4SetNANDKey(i1_part, pui1Buf,z_size);

	x_mem_free(pui1Buf);
	return i4_ret;

}
static INT32 _SifReadKey(INT32 i4Argc, const CHAR** szArgv)
{
	INT8 i1_part = 0;
	UINT8* pui1Buf;
	INT32 i4_ret = -1;
	size_t z_size = 0;
	
	if(i4Argc != 3)
	{
		Printf("[SIF CMD]Input format\n gk 2:TVID [size,default 22]\n");
		return -1;
	}
	i1_part = StrToInt(szArgv[1]);
	if(i1_part > 4)
	{
		Printf("[SIF CMD] input arg should less that 4\n");
		return -1;
	}
	z_size = StrToInt(szArgv[2]);
	if(z_size < 0 || z_size > 30){
		Printf("[SIF CMD] z_size is invalid\n");
		return -1;
	}
	pui1Buf = x_mem_alloc(z_size);
	if(pui1Buf == NULL){
		Printf("[SIF CMD] the mem alloc fail\n");
		return -1;
	}
	i4_ret = ui4GetNANDKey(i1_part, pui1Buf,z_size);

	x_mem_free(pui1Buf);
	return i4_ret;

}

#endif




